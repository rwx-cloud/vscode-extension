"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode2(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar2(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias2;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap2;
    exports2.isNode = isNode2;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar2;
    exports2.isSeq = isSeq2;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit2(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === "function")
        return visitor(key, node, path);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
      return void 0;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit2;
    exports2.visitAsync = visitAsync;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit2.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit2.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit2 = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit2.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit2.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map3 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map3.items.push(value);
        return map3;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent2) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent2 ? comment.replace(/^(?! *$)/gm, indent2) : comment;
    }
    var lineComment = (str, indent2, comment) => str.endsWith("\n") ? indentComment(comment, indent2) : comment.includes("\n") ? "\n" + indentComment(comment, indent2) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent2, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent2.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent2.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent2.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent2.length);
          end = i + indent2.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent2}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent2}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent2) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent2) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent2;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent2, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent2 = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent2}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent2.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent2}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent2}`);
      }
      const indentSize = indent2 ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent2}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent2, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent2}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent2}`);
      return `|${header}
${indent2}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent: indent2, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent2 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent2 === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent2}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t) => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t) => t.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent2 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent2}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    var node_process = require("node:process");
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map3, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map3, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map3, it);
      else
        mergeValue(ctx, map3, value);
    }
    function mergeValue(ctx, map3, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map3 instanceof Map) {
          if (!map3.has(key))
            map3.set(key, value2);
        } else if (map3 instanceof Set) {
          map3.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
          Object.defineProperty(map3, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map3;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log = require_log();
    var merge = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map3, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map3, value);
      else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map3, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map3 instanceof Map) {
          map3.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map3 instanceof Set) {
          map3.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map3)
            Object.defineProperty(map3, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map3[stringKey] = jsValue;
        }
      }
      return map3;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent2, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent2}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent2);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent: indent2, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent2}${line}` : "\n";
          return `${str}
${indent2}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent: indent2, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent2);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map3 = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map3.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map3.items.sort(schema.sortMapEntries);
        }
        return map3;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type2) {
        const map3 = Type2 ? new Type2() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map3, item);
        return map3;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map3 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map4, onError) {
        if (!identity.isMap(map4))
          onError("Expected a mapping for this tag");
        return map4;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map3;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map3 = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map3.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var node_buffer = require("node:buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value);
        }
        return map3;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map3, onError) {
        if (identity.isMap(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map3.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map3.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map3 = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map3.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection.isEmptyPath(path))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent2, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent2 && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map3 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map3.comment)
                map3.comment += "\n" + keyProps.comment;
              else
                map3.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map3.range = [bm.offset, offset, commentEnd ?? offset];
      return map3;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap2 = fc.start.source === "{";
      const fcName = isMap2 ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap2 && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st of start) {
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap2 && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap2 && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap2) {
            const map3 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map3.items.push(pair);
          } else {
            const map3 = new YAMLMap.YAMLMap(ctx.schema);
            map3.flow = true;
            map3.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map3.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map3);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap2 ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent2, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent2.length > trimIndent)
            trimIndent = indent2.length;
        } else {
          if (indent2.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent2.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent2.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent2.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent2, content] = lines[i];
        offset += indent2.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent2.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent2 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent2.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent2.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent2.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent2 = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent2 && n)
            indent2 = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent: indent2, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var node_process = require("node:process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent: indent2, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent: indent2, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent2, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
          return { type: "block-scalar", offset, indent: indent2, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent2, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent2, source, end };
        default:
          return { type: "scalar", offset, indent: indent2, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent2 = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent2 === "number")
        indent2 += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent2 === null,
        indent: indent2 !== null && indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent2 = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent2, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent: indent2, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent2 = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent: indent2, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit2(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports2.visit = visit2;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar2;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer2 = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent2 = 0;
          while (ch === " ")
            ch = this.buffer[++indent2 + offset];
          if (ch === "\r") {
            const next = this.buffer[indent2 + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent2 + 1;
          }
          return ch === "\n" || indent2 >= this.indentNext || !ch && !this.atEnd ? offset + indent2 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent2 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent2 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent2 !== -1 && indent2 < this.indentNext && line[0] !== "#" || indent2 === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent2 === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent2 = 0;
        let ch;
        loop:
          for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
            switch (ch) {
              case " ":
                indent2 += 1;
                break;
              case "\n":
                nl = i2;
                indent2 = 0;
                break;
              case "\r": {
                const next = this.buffer[i2 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent2 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent2;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent2 > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer2;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var node_process = require("node:process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        while (--i >= 0) {
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser2 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent2) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent2)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser2;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument2(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument2(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent2 = Math.round(options);
        options = indent2 < 1 ? void 0 : indent2 > 8 ? { indent: 8 } : { indent: indent2 };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument2;
    exports2.stringify = stringify;
  }
});

// ../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit2 = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit2.visit;
    exports2.visitAsync = visit2.visitAsync;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js
var require_version = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "10.5.0";
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol3 = root.Symbol;
    module2.exports = Symbol3;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise3 = getNative(root, "Promise");
    module2.exports = Promise3;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set5 = getNative(root, "Set");
    module2.exports = Set5;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise3 = require_Promise();
    var Set5 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise3);
    var setCtorString = toSource(Set5);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash2(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    module2.exports = Hash2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash2 = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array3 = root.Uint8Array;
    module2.exports = Uint8Array3;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var Uint8Array3 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
var require_get = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
var require_identity2 = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
var require_property = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity2();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js
var require_map2 = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map3(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map3;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity2();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js
var require_values = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module2.exports = baseHas;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
var require_has = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module2.exports = has;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array3 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap2 = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap2(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js
var require_clone = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone;
  }
});

// ../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js
var require_print = __commonJS({
  "../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
    function PRINT_ERROR(msg) {
      if (console && console.error) {
        console.error("Error: ".concat(msg));
      }
    }
    exports2.PRINT_ERROR = PRINT_ERROR;
    function PRINT_WARNING(msg) {
      if (console && console.warn) {
        console.warn("Warning: ".concat(msg));
      }
    }
    exports2.PRINT_WARNING = PRINT_WARNING;
  }
});

// ../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js
var require_timer = __commonJS({
  "../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    function timer(func) {
      var start = (/* @__PURE__ */ new Date()).getTime();
      var val = func();
      var end = (/* @__PURE__ */ new Date()).getTime();
      var total = end - start;
      return { time: total, value: val };
    }
    exports2.timer = timer;
  }
});

// ../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
var require_to_fast_properties = __commonJS({
  "../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFastProperties = void 0;
    function toFastProperties(toBecomeFast) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = toBecomeFast;
      var fakeInstance = new FakeConstructor();
      function fakeAccess() {
        return typeof fakeInstance.bar;
      }
      fakeAccess();
      fakeAccess();
      if (1)
        return toBecomeFast;
      eval(toBecomeFast);
    }
    exports.toFastProperties = toFastProperties;
  }
});

// ../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js
var require_api = __commonJS({
  "../node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
    var print_1 = require_print();
    Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
      return print_1.PRINT_WARNING;
    } });
    Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
      return print_1.PRINT_ERROR;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var to_fast_properties_1 = require_to_fast_properties();
    Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
      return to_fast_properties_1.toFastProperties;
    } });
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js
var require_drop = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    module2.exports = drop;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js
var require_isString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module2.exports = baseIsRegExp;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    module2.exports = pickBy;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity2();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity2();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js
var require_assign = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign;
  }
});

// ../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js
var require_model = __commonJS({
  "../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var pickBy_1 = __importDefault(require_pickBy());
    var assign_1 = __importDefault(require_assign());
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    var AbstractProduction = (
      /** @class */
      function() {
        function AbstractProduction2(_definition) {
          this._definition = _definition;
        }
        Object.defineProperty(AbstractProduction2.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        AbstractProduction2.prototype.accept = function(visitor) {
          visitor.visit(this);
          (0, forEach_1.default)(this.definition, function(prod) {
            prod.accept(visitor);
          });
        };
        return AbstractProduction2;
      }()
    );
    exports2.AbstractProduction = AbstractProduction;
    var NonTerminal2 = (
      /** @class */
      function(_super) {
        __extends(NonTerminal3, _super);
        function NonTerminal3(options) {
          var _this = _super.call(this, []) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(NonTerminal3.prototype, "definition", {
          get: function() {
            if (this.referencedRule !== void 0) {
              return this.referencedRule.definition;
            }
            return [];
          },
          set: function(definition) {
          },
          enumerable: false,
          configurable: true
        });
        NonTerminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return NonTerminal3;
      }(AbstractProduction)
    );
    exports2.NonTerminal = NonTerminal2;
    var Rule2 = (
      /** @class */
      function(_super) {
        __extends(Rule3, _super);
        function Rule3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.orgText = "";
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Rule3;
      }(AbstractProduction)
    );
    exports2.Rule = Rule2;
    var Alternative2 = (
      /** @class */
      function(_super) {
        __extends(Alternative3, _super);
        function Alternative3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.ignoreAmbiguities = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Alternative3;
      }(AbstractProduction)
    );
    exports2.Alternative = Alternative2;
    var Option2 = (
      /** @class */
      function(_super) {
        __extends(Option3, _super);
        function Option3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Option3;
      }(AbstractProduction)
    );
    exports2.Option = Option2;
    var RepetitionMandatory2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatory3, _super);
        function RepetitionMandatory3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatory3;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatory = RepetitionMandatory2;
    var RepetitionMandatoryWithSeparator2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatoryWithSeparator3, _super);
        function RepetitionMandatoryWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatoryWithSeparator3;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator2;
    var Repetition2 = (
      /** @class */
      function(_super) {
        __extends(Repetition3, _super);
        function Repetition3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Repetition3;
      }(AbstractProduction)
    );
    exports2.Repetition = Repetition2;
    var RepetitionWithSeparator2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionWithSeparator3, _super);
        function RepetitionWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionWithSeparator3;
      }(AbstractProduction)
    );
    exports2.RepetitionWithSeparator = RepetitionWithSeparator2;
    var Alternation2 = (
      /** @class */
      function(_super) {
        __extends(Alternation3, _super);
        function Alternation3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          _this.ignoreAmbiguities = false;
          _this.hasPredicates = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(Alternation3.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        return Alternation3;
      }(AbstractProduction)
    );
    exports2.Alternation = Alternation2;
    var Terminal2 = (
      /** @class */
      function() {
        function Terminal3(options) {
          this.idx = 1;
          (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
        }
        Terminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return Terminal3;
      }()
    );
    exports2.Terminal = Terminal2;
    function serializeGrammar2(topRules) {
      return (0, map_1.default)(topRules, serializeProduction2);
    }
    exports2.serializeGrammar = serializeGrammar2;
    function serializeProduction2(node) {
      function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction2);
      }
      if (node instanceof NonTerminal2) {
        var serializedNonTerminal = {
          type: "NonTerminal",
          name: node.nonTerminalName,
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
      } else if (node instanceof Alternative2) {
        return {
          type: "Alternative",
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Option2) {
        return {
          type: "Option",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatory2) {
        return {
          type: "RepetitionMandatory",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatoryWithSeparator2) {
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionWithSeparator2) {
        return {
          type: "RepetitionWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Repetition2) {
        return {
          type: "Repetition",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Alternation2) {
        return {
          type: "Alternation",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Terminal2) {
        var serializedTerminal = {
          type: "Terminal",
          name: node.terminalType.name,
          label: tokenLabel2(node.terminalType),
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedTerminal.terminalLabel = node.label;
        }
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
          serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
      } else if (node instanceof Rule2) {
        return {
          type: "Rule",
          name: node.name,
          orgText: node.orgText,
          definition: convertDefinition(node.definition)
        };
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.serializeProduction = serializeProduction2;
  }
});

// ../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js
var require_visitor = __commonJS({
  "../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GAstVisitor = void 0;
    var model_1 = require_model();
    var GAstVisitor2 = (
      /** @class */
      function() {
        function GAstVisitor3() {
        }
        GAstVisitor3.prototype.visit = function(node) {
          var nodeAny = node;
          switch (nodeAny.constructor) {
            case model_1.NonTerminal:
              return this.visitNonTerminal(nodeAny);
            case model_1.Alternative:
              return this.visitAlternative(nodeAny);
            case model_1.Option:
              return this.visitOption(nodeAny);
            case model_1.RepetitionMandatory:
              return this.visitRepetitionMandatory(nodeAny);
            case model_1.RepetitionMandatoryWithSeparator:
              return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case model_1.RepetitionWithSeparator:
              return this.visitRepetitionWithSeparator(nodeAny);
            case model_1.Repetition:
              return this.visitRepetition(nodeAny);
            case model_1.Alternation:
              return this.visitAlternation(nodeAny);
            case model_1.Terminal:
              return this.visitTerminal(nodeAny);
            case model_1.Rule:
              return this.visitRule(nodeAny);
            default:
              throw Error("non exhaustive match");
          }
        };
        GAstVisitor3.prototype.visitNonTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitAlternative = function(node) {
        };
        GAstVisitor3.prototype.visitOption = function(node) {
        };
        GAstVisitor3.prototype.visitRepetition = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatory = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitAlternation = function(node) {
        };
        GAstVisitor3.prototype.visitTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitRule = function(node) {
        };
        return GAstVisitor3;
      }()
    );
    exports2.GAstVisitor = GAstVisitor2;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module2.exports = baseSome;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js
var require_some = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js"(exports2, module2) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = some;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js
var require_arrayEvery = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js"(exports2, module2) {
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = arrayEvery;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js
var require_baseEvery = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection2) {
        result = !!predicate(value, index, collection2);
        return result;
      });
      return result;
    }
    module2.exports = baseEvery;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js
var require_every = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js"(exports2, module2) {
    var arrayEvery = require_arrayEvery();
    var baseEvery = require_baseEvery();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = every;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js
var require_includes = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module2.exports = includes;
  }
});

// ../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js
var require_helpers = __commonJS({
  "../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
    var some_1 = __importDefault(require_some());
    var every_1 = __importDefault(require_every());
    var includes_1 = __importDefault(require_includes());
    var model_1 = require_model();
    function isSequenceProd(prod) {
      return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
    }
    exports2.isSequenceProd = isSequenceProd;
    function isOptionalProd(prod, alreadyVisited) {
      if (alreadyVisited === void 0) {
        alreadyVisited = [];
      }
      var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
      if (isDirectlyOptional) {
        return true;
      }
      if (prod instanceof model_1.Alternation) {
        return (0, some_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
        return false;
      } else if (prod instanceof model_1.AbstractProduction) {
        if (prod instanceof model_1.NonTerminal) {
          alreadyVisited.push(prod);
        }
        return (0, every_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else {
        return false;
      }
    }
    exports2.isOptionalProd = isOptionalProd;
    function isBranchingProd(prod) {
      return prod instanceof model_1.Alternation;
    }
    exports2.isBranchingProd = isBranchingProd;
    function getProductionDslName(prod) {
      if (prod instanceof model_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof model_1.Option) {
        return "OPTION";
      } else if (prod instanceof model_1.Alternation) {
        return "OR";
      } else if (prod instanceof model_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof model_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof model_1.Repetition) {
        return "MANY";
      } else if (prod instanceof model_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProductionDslName = getProductionDslName;
  }
});

// ../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js
var require_api2 = __commonJS({
  "../node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
    var model_1 = require_model();
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return model_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return model_1.Terminal;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return model_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return model_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return model_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return model_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return model_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return model_1.Alternative;
    } });
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return model_1.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return model_1.serializeProduction;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return visitor_1.GAstVisitor;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
      return helpers_1.getProductionDslName;
    } });
    Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
      return helpers_1.isOptionalProd;
    } });
    Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
      return helpers_1.isBranchingProd;
    } });
    Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
      return helpers_1.isSequenceProd;
    } });
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js
var require_rest = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestWalker = void 0;
    var drop_1 = __importDefault(require_drop());
    var forEach_1 = __importDefault(require_forEach());
    var gast_1 = require_api2();
    var RestWalker = (
      /** @class */
      function() {
        function RestWalker2() {
        }
        RestWalker2.prototype.walk = function(prod, prevRest) {
          var _this = this;
          if (prevRest === void 0) {
            prevRest = [];
          }
          (0, forEach_1.default)(prod.definition, function(subProd, index) {
            var currRest = (0, drop_1.default)(prod.definition, index + 1);
            if (subProd instanceof gast_1.NonTerminal) {
              _this.walkProdRef(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Terminal) {
              _this.walkTerminal(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternative) {
              _this.walkFlat(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Option) {
              _this.walkOption(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatory) {
              _this.walkAtLeastOne(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
              _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
              _this.walkManySep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Repetition) {
              _this.walkMany(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternation) {
              _this.walkOr(subProd, currRest, prevRest);
            } else {
              throw Error("non exhaustive match");
            }
          });
        };
        RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        };
        RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(flatProd, fullOrRest);
        };
        RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(optionProd, fullOrRest);
        };
        RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          var fullAtLeastOneRest = [
            new gast_1.Option({ definition: atLeastOneProd.definition })
          ].concat(currRest, prevRest);
          this.walk(atLeastOneProd, fullAtLeastOneRest);
        };
        RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
        };
        RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          var fullManyRest = [
            new gast_1.Option({ definition: manyProd.definition })
          ].concat(currRest, prevRest);
          this.walk(manyProd, fullManyRest);
        };
        RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
          this.walk(manySepProd, fullManySepRest);
        };
        RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
          var _this = this;
          var fullOrRest = currRest.concat(prevRest);
          (0, forEach_1.default)(orProd.definition, function(alt) {
            var prodWrapper = new gast_1.Alternative({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
          });
        };
        return RestWalker2;
      }()
    );
    exports2.RestWalker = RestWalker;
    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
      var repSepRest = [
        new gast_1.Option({
          definition: [
            new gast_1.Terminal({ terminalType: repSepProd.separator })
          ].concat(repSepProd.definition)
        })
      ];
      var fullRepSepRest = repSepRest.concat(currRest, prevRest);
      return fullRepSepRest;
    }
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol3 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set5 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set5 && 1 / setToArray(new Set5([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set5(values);
    };
    module2.exports = createSet;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js
var require_first = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var uniq_1 = __importDefault(require_uniq());
    var map_1 = __importDefault(require_map2());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    function first(prod) {
      if (prod instanceof gast_1.NonTerminal) {
        return first(prod.referencedRule);
      } else if (prod instanceof gast_1.Terminal) {
        return firstForTerminal(prod);
      } else if ((0, gast_2.isSequenceProd)(prod)) {
        return firstForSequence(prod);
      } else if ((0, gast_2.isBranchingProd)(prod)) {
        return firstForBranching(prod);
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.first = first;
    function firstForSequence(prod) {
      var firstSet = [];
      var seq = prod.definition;
      var nextSubProdIdx = 0;
      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      var currSubProd;
      var isLastInnerProdOptional = true;
      while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      }
      return (0, uniq_1.default)(firstSet);
    }
    exports2.firstForSequence = firstForSequence;
    function firstForBranching(prod) {
      var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
        return first(innerProd);
      });
      return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
    }
    exports2.firstForBranching = firstForBranching;
    function firstForTerminal(terminal) {
      return [terminal.terminalType];
    }
    exports2.firstForTerminal = firstForTerminal;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js
var require_constants = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IN = void 0;
    exports2.IN = "_~IN~_";
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js
var require_follow = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = require_first();
    var forEach_1 = __importDefault(require_forEach());
    var assign_1 = __importDefault(require_assign());
    var constants_1 = require_constants();
    var gast_1 = require_api2();
    var ResyncFollowsWalker = (
      /** @class */
      function(_super) {
        __extends(ResyncFollowsWalker2, _super);
        function ResyncFollowsWalker2(topProd) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.follows = {};
          return _this;
        }
        ResyncFollowsWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.follows;
        };
        ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
          var fullRest = currRest.concat(prevRest);
          var restProd = new gast_1.Alternative({ definition: fullRest });
          var t_in_topProd_follows = (0, first_1.first)(restProd);
          this.follows[followName] = t_in_topProd_follows;
        };
        return ResyncFollowsWalker2;
      }(rest_1.RestWalker)
    );
    exports2.ResyncFollowsWalker = ResyncFollowsWalker;
    function computeAllProdsFollows(topProductions) {
      var reSyncFollows = {};
      (0, forEach_1.default)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, assign_1.default)(reSyncFollows, currRefsFollow);
      });
      return reSyncFollows;
    }
    exports2.computeAllProdsFollows = computeAllProdsFollows;
    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
      return inner.name + occurenceInParent + constants_1.IN;
    }
    exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
    function buildInProdFollowPrefix(terminal) {
      var terminalName = terminal.terminalType.name;
      return terminalName + terminal.idx + constants_1.IN;
    }
    exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// ../node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js
var require_regexp_to_ast = __commonJS({
  "../node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.regexpToAst = factory();
      }
    })(
      typeof self !== "undefined" ? (
        // istanbul ignore next
        self
      ) : exports2,
      function() {
        function RegExpParser() {
        }
        RegExpParser.prototype.saveState = function() {
          return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
          };
        };
        RegExpParser.prototype.restoreState = function(newState) {
          this.idx = newState.idx;
          this.input = newState.input;
          this.groupIdx = newState.groupIdx;
        };
        RegExpParser.prototype.pattern = function(input) {
          this.idx = 0;
          this.input = input;
          this.groupIdx = 0;
          this.consumeChar("/");
          var value = this.disjunction();
          this.consumeChar("/");
          var flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
          };
          while (this.isRegExpFlag()) {
            switch (this.popChar()) {
              case "g":
                addFlag(flags, "global");
                break;
              case "i":
                addFlag(flags, "ignoreCase");
                break;
              case "m":
                addFlag(flags, "multiLine");
                break;
              case "u":
                addFlag(flags, "unicode");
                break;
              case "y":
                addFlag(flags, "sticky");
                break;
            }
          }
          if (this.idx !== this.input.length) {
            throw Error(
              "Redundant input: " + this.input.substring(this.idx)
            );
          }
          return {
            type: "Pattern",
            flags,
            value,
            loc: this.loc(0)
          };
        };
        RegExpParser.prototype.disjunction = function() {
          var alts = [];
          var begin = this.idx;
          alts.push(this.alternative());
          while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
          }
          return { type: "Disjunction", value: alts, loc: this.loc(begin) };
        };
        RegExpParser.prototype.alternative = function() {
          var terms = [];
          var begin = this.idx;
          while (this.isTerm()) {
            terms.push(this.term());
          }
          return { type: "Alternative", value: terms, loc: this.loc(begin) };
        };
        RegExpParser.prototype.term = function() {
          if (this.isAssertion()) {
            return this.assertion();
          } else {
            return this.atom();
          }
        };
        RegExpParser.prototype.assertion = function() {
          var begin = this.idx;
          switch (this.popChar()) {
            case "^":
              return {
                type: "StartAnchor",
                loc: this.loc(begin)
              };
            case "$":
              return { type: "EndAnchor", loc: this.loc(begin) };
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return {
                    type: "WordBoundary",
                    loc: this.loc(begin)
                  };
                case "B":
                  return {
                    type: "NonWordBoundary",
                    loc: this.loc(begin)
                  };
              }
              throw Error("Invalid Assertion Escape");
            case "(":
              this.consumeChar("?");
              var type;
              switch (this.popChar()) {
                case "=":
                  type = "Lookahead";
                  break;
                case "!":
                  type = "NegativeLookahead";
                  break;
              }
              ASSERT_EXISTS(type);
              var disjunction = this.disjunction();
              this.consumeChar(")");
              return {
                type,
                value: disjunction,
                loc: this.loc(begin)
              };
          }
          ASSERT_NEVER_REACH_HERE();
        };
        RegExpParser.prototype.quantifier = function(isBacktracking) {
          var range;
          var begin = this.idx;
          switch (this.popChar()) {
            case "*":
              range = {
                atLeast: 0,
                atMost: Infinity
              };
              break;
            case "+":
              range = {
                atLeast: 1,
                atMost: Infinity
              };
              break;
            case "?":
              range = {
                atLeast: 0,
                atMost: 1
              };
              break;
            case "{":
              var atLeast = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  range = {
                    atLeast,
                    atMost: atLeast
                  };
                  break;
                case ",":
                  var atMost;
                  if (this.isDigit()) {
                    atMost = this.integerIncludingZero();
                    range = {
                      atLeast,
                      atMost
                    };
                  } else {
                    range = {
                      atLeast,
                      atMost: Infinity
                    };
                  }
                  this.consumeChar("}");
                  break;
              }
              if (isBacktracking === true && range === void 0) {
                return void 0;
              }
              ASSERT_EXISTS(range);
              break;
          }
          if (isBacktracking === true && range === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range);
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
          } else {
            range.greedy = true;
          }
          range.type = "Quantifier";
          range.loc = this.loc(begin);
          return range;
        };
        RegExpParser.prototype.atom = function() {
          var atom;
          var begin = this.idx;
          switch (this.peekChar()) {
            case ".":
              atom = this.dotAll();
              break;
            case "\\":
              atom = this.atomEscape();
              break;
            case "[":
              atom = this.characterClass();
              break;
            case "(":
              atom = this.group();
              break;
          }
          if (atom === void 0 && this.isPatternCharacter()) {
            atom = this.patternCharacter();
          }
          ASSERT_EXISTS(atom);
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        };
        RegExpParser.prototype.dotAll = function() {
          this.consumeChar(".");
          return {
            type: "Set",
            complement: true,
            value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
          };
        };
        RegExpParser.prototype.atomEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.decimalEscapeAtom = function() {
          var value = this.positiveInteger();
          return { type: "GroupBackReference", value };
        };
        RegExpParser.prototype.characterClassEscape = function() {
          var set;
          var complement = false;
          switch (this.popChar()) {
            case "d":
              set = digitsCharCodes;
              break;
            case "D":
              set = digitsCharCodes;
              complement = true;
              break;
            case "s":
              set = whitespaceCodes;
              break;
            case "S":
              set = whitespaceCodes;
              complement = true;
              break;
            case "w":
              set = wordCharCodes;
              break;
            case "W":
              set = wordCharCodes;
              complement = true;
              break;
          }
          ASSERT_EXISTS(set);
          return { type: "Set", value: set, complement };
        };
        RegExpParser.prototype.controlEscapeAtom = function() {
          var escapeCode;
          switch (this.popChar()) {
            case "f":
              escapeCode = cc("\f");
              break;
            case "n":
              escapeCode = cc("\n");
              break;
            case "r":
              escapeCode = cc("\r");
              break;
            case "t":
              escapeCode = cc("	");
              break;
            case "v":
              escapeCode = cc("\v");
              break;
          }
          ASSERT_EXISTS(escapeCode);
          return { type: "Character", value: escapeCode };
        };
        RegExpParser.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var letter = this.popChar();
          if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
          }
          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: letterCode };
        };
        RegExpParser.prototype.nulCharacterAtom = function() {
          this.consumeChar("0");
          return { type: "Character", value: cc("\0") };
        };
        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
          this.consumeChar("x");
          return this.parseHexDigits(2);
        };
        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          this.consumeChar("u");
          return this.parseHexDigits(4);
        };
        RegExpParser.prototype.identityEscapeAtom = function() {
          var escapedChar = this.popChar();
          return { type: "Character", value: cc(escapedChar) };
        };
        RegExpParser.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "\\":
            case "]":
              throw Error("TBD");
            default:
              var nextChar = this.popChar();
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.characterClass = function() {
          var set = [];
          var complement = false;
          this.consumeChar("[");
          if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
          }
          while (this.isClassAtom()) {
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
              this.consumeChar("-");
              var to = this.classAtom();
              var isToSingleChar = to.type === "Character";
              if (isToSingleChar) {
                if (to.value < from.value) {
                  throw Error("Range out of order in character class");
                }
                set.push({ from: from.value, to: to.value });
              } else {
                insertToSet(from.value, set);
                set.push(cc("-"));
                insertToSet(to.value, set);
              }
            } else {
              insertToSet(from.value, set);
            }
          }
          this.consumeChar("]");
          return { type: "Set", complement, value: set };
        };
        RegExpParser.prototype.classAtom = function() {
          switch (this.peekChar()) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        };
        RegExpParser.prototype.classEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "b":
              this.consumeChar("b");
              return { type: "Character", value: cc("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.group = function() {
          var capturing = true;
          this.consumeChar("(");
          switch (this.peekChar(0)) {
            case "?":
              this.consumeChar("?");
              this.consumeChar(":");
              capturing = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var value = this.disjunction();
          this.consumeChar(")");
          var groupAst = {
            type: "Group",
            capturing,
            value
          };
          if (capturing) {
            groupAst.idx = this.groupIdx;
          }
          return groupAst;
        };
        RegExpParser.prototype.positiveInteger = function() {
          var number = this.popChar();
          if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.integerIncludingZero = function() {
          var number = this.popChar();
          if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.patternCharacter = function() {
          var nextChar = this.popChar();
          switch (nextChar) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        };
        RegExpParser.prototype.isDigit = function() {
          return decimalPattern.test(this.peekChar(0));
        };
        RegExpParser.prototype.isClassAtom = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        };
        RegExpParser.prototype.isAtom = function() {
          if (this.isPatternCharacter()) {
            return true;
          }
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            case "[":
            case "(":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        };
        RegExpParser.prototype.isQuantifier = function() {
          var prevState = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch (e) {
            return false;
          } finally {
            this.restoreState(prevState);
          }
        };
        RegExpParser.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.parseHexDigits = function(howMany) {
          var hexString = "";
          for (var i2 = 0; i2 < howMany; i2++) {
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
              throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
          }
          var charCode = parseInt(hexString, 16);
          return { type: "Character", value: charCode };
        };
        RegExpParser.prototype.peekChar = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          return this.input[this.idx + howMuch];
        };
        RegExpParser.prototype.popChar = function() {
          var nextChar = this.peekChar(0);
          this.consumeChar();
          return nextChar;
        };
        RegExpParser.prototype.consumeChar = function(char) {
          if (char !== void 0 && this.input[this.idx] !== char) {
            throw Error(
              "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
            );
          }
          if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
          }
          this.idx++;
        };
        RegExpParser.prototype.loc = function(begin) {
          return { begin, end: this.idx };
        };
        var hexDigitPattern = /[0-9a-fA-F]/;
        var decimalPattern = /[0-9]/;
        var decimalPatternNoZero = /[1-9]/;
        function cc(char) {
          return char.charCodeAt(0);
        }
        function insertToSet(item, set) {
          if (item.length !== void 0) {
            item.forEach(function(subItem) {
              set.push(subItem);
            });
          } else {
            set.push(item);
          }
        }
        function addFlag(flagObj, flagKey) {
          if (flagObj[flagKey] === true) {
            throw "duplicate flag " + flagKey;
          }
          flagObj[flagKey] = true;
        }
        function ASSERT_EXISTS(obj) {
          if (obj === void 0) {
            throw Error("Internal Error - Should never get here!");
          }
        }
        function ASSERT_NEVER_REACH_HERE() {
          throw Error("Internal Error - Should never get here!");
        }
        var i;
        var digitsCharCodes = [];
        for (i = cc("0"); i <= cc("9"); i++) {
          digitsCharCodes.push(i);
        }
        var wordCharCodes = [cc("_")].concat(digitsCharCodes);
        for (i = cc("a"); i <= cc("z"); i++) {
          wordCharCodes.push(i);
        }
        for (i = cc("A"); i <= cc("Z"); i++) {
          wordCharCodes.push(i);
        }
        var whitespaceCodes = [
          cc(" "),
          cc("\f"),
          cc("\n"),
          cc("\r"),
          cc("	"),
          cc("\v"),
          cc("	"),
          cc("\xA0"),
          cc("\u1680"),
          cc("\u2000"),
          cc("\u2001"),
          cc("\u2002"),
          cc("\u2003"),
          cc("\u2004"),
          cc("\u2005"),
          cc("\u2006"),
          cc("\u2007"),
          cc("\u2008"),
          cc("\u2009"),
          cc("\u200A"),
          cc("\u2028"),
          cc("\u2029"),
          cc("\u202F"),
          cc("\u205F"),
          cc("\u3000"),
          cc("\uFEFF")
        ];
        function BaseRegExpVisitor() {
        }
        BaseRegExpVisitor.prototype.visitChildren = function(node) {
          for (var key in node) {
            var child = node[key];
            if (node.hasOwnProperty(key)) {
              if (child.type !== void 0) {
                this.visit(child);
              } else if (Array.isArray(child)) {
                child.forEach(function(subChild) {
                  this.visit(subChild);
                }, this);
              }
            }
          }
        };
        BaseRegExpVisitor.prototype.visit = function(node) {
          switch (node.type) {
            case "Pattern":
              this.visitPattern(node);
              break;
            case "Flags":
              this.visitFlags(node);
              break;
            case "Disjunction":
              this.visitDisjunction(node);
              break;
            case "Alternative":
              this.visitAlternative(node);
              break;
            case "StartAnchor":
              this.visitStartAnchor(node);
              break;
            case "EndAnchor":
              this.visitEndAnchor(node);
              break;
            case "WordBoundary":
              this.visitWordBoundary(node);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(node);
              break;
            case "Lookahead":
              this.visitLookahead(node);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              break;
            case "Character":
              this.visitCharacter(node);
              break;
            case "Set":
              this.visitSet(node);
              break;
            case "Group":
              this.visitGroup(node);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(node);
              break;
            case "Quantifier":
              this.visitQuantifier(node);
              break;
          }
          this.visitChildren(node);
        };
        BaseRegExpVisitor.prototype.visitPattern = function(node) {
        };
        BaseRegExpVisitor.prototype.visitFlags = function(node) {
        };
        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
        };
        BaseRegExpVisitor.prototype.visitAlternative = function(node) {
        };
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {
        };
        BaseRegExpVisitor.prototype.visitSet = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroup = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
        };
        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
        };
        return {
          RegExpParser,
          BaseRegExpVisitor,
          VERSION: "0.5.0"
        };
      }
    );
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js
var require_head = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js"(exports2, module2) {
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    module2.exports = head;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js
var require_first2 = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js"(exports2, module2) {
    module2.exports = require_head();
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js
var require_compact = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js"(exports2, module2) {
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module2.exports = baseFilter;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js
var require_negate = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js
var require_reject = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    module2.exports = reject;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js
var require_difference = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module2.exports = indexOf;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js
var require_find = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js"(exports2, module2) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js
var require_filter = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = filter;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
var require_reg_exp_parser = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regExpAstCache = {};
    var regExpParser = new regexp_to_ast_1.RegExpParser();
    function getRegExpAst(regExp) {
      var regExpStr = regExp.toString();
      if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
      } else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
      }
    }
    exports2.getRegExpAst = getRegExpAst;
    function clearRegExpParserCache() {
      regExpAstCache = {};
    }
    exports2.clearRegExpParserCache = clearRegExpParserCache;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js
var require_reg_exp = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var isArray_1 = __importDefault(require_isArray());
    var every_1 = __importDefault(require_every());
    var forEach_1 = __importDefault(require_forEach());
    var find_1 = __importDefault(require_find());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var lexer_1 = require_lexer2();
    var complementErrorMessage = "Complement Sets are not supported for first char optimization";
    exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
      if (ensureOptimizations === void 0) {
        ensureOptimizations = false;
      }
      try {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
      } catch (e) {
        if (e.message === complementErrorMessage) {
          if (ensureOptimizations) {
            (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
          }
        } else {
          var msgSuffix = "";
          if (ensureOptimizations) {
            msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
          }
          (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
      }
      return [];
    }
    exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
    function firstCharOptimizedIndices(ast, result, ignoreCase) {
      switch (ast.type) {
        case "Disjunction":
          for (var i = 0; i < ast.value.length; i++) {
            firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
          }
          break;
        case "Alternative":
          var terms = ast.value;
          for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            switch (term.type) {
              case "EndAnchor":
              case "GroupBackReference":
              case "Lookahead":
              case "NegativeLookahead":
              case "StartAnchor":
              case "WordBoundary":
              case "NonWordBoundary":
                continue;
            }
            var atom = term;
            switch (atom.type) {
              case "Character":
                addOptimizedIdxToResult(atom.value, result, ignoreCase);
                break;
              case "Set":
                if (atom.complement === true) {
                  throw Error(complementErrorMessage);
                }
                (0, forEach_1.default)(atom.value, function(code) {
                  if (typeof code === "number") {
                    addOptimizedIdxToResult(code, result, ignoreCase);
                  } else {
                    var range = code;
                    if (ignoreCase === true) {
                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                    } else {
                      for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                      if (range.to >= lexer_1.minOptimizationVal) {
                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                        var maxUnOptVal = range.to;
                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                          result[currOptIdx] = currOptIdx;
                        }
                      }
                    }
                  }
                });
                break;
              case "Group":
                firstCharOptimizedIndices(atom.value, result, ignoreCase);
                break;
              default:
                throw Error("Non Exhaustive Match");
            }
            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
            if (
              // A group may be optional due to empty contents /(?:)/
              // or if everything inside it is optional /((a)?)/
              atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
              atom.type !== "Group" && isOptionalQuantifier === false
            ) {
              break;
            }
          }
          break;
        default:
          throw Error("non exhaustive match!");
      }
      return (0, values_1.default)(result);
    }
    exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
    function addOptimizedIdxToResult(code, result, ignoreCase) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
      result[optimizedCharIdx] = optimizedCharIdx;
      if (ignoreCase === true) {
        handleIgnoreCase(code, result);
      }
    }
    function handleIgnoreCase(code, result) {
      var char = String.fromCharCode(code);
      var upperChar = char.toUpperCase();
      if (upperChar !== char) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        }
      }
    }
    function findCode(setNode, targetCharCodes) {
      return (0, find_1.default)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") {
          return (0, includes_1.default)(targetCharCodes, codeOrRange);
        } else {
          var range_1 = codeOrRange;
          return (0, find_1.default)(targetCharCodes, function(targetCode) {
            return range_1.from <= targetCode && targetCode <= range_1.to;
          }) !== void 0;
        }
      });
    }
    function isWholeOptional(ast) {
      var quantifier = ast.quantifier;
      if (quantifier && quantifier.atLeast === 0) {
        return true;
      }
      if (!ast.value) {
        return false;
      }
      return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
    }
    var CharCodeFinder = (
      /** @class */
      function(_super) {
        __extends(CharCodeFinder2, _super);
        function CharCodeFinder2(targetCharCodes) {
          var _this = _super.call(this) || this;
          _this.targetCharCodes = targetCharCodes;
          _this.found = false;
          return _this;
        }
        CharCodeFinder2.prototype.visitChildren = function(node) {
          if (this.found === true) {
            return;
          }
          switch (node.type) {
            case "Lookahead":
              this.visitLookahead(node);
              return;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              return;
          }
          _super.prototype.visitChildren.call(this, node);
        };
        CharCodeFinder2.prototype.visitCharacter = function(node) {
          if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
            this.found = true;
          }
        };
        CharCodeFinder2.prototype.visitSet = function(node) {
          if (node.complement) {
            if (findCode(node, this.targetCharCodes) === void 0) {
              this.found = true;
            }
          } else {
            if (findCode(node, this.targetCharCodes) !== void 0) {
              this.found = true;
            }
          }
        };
        return CharCodeFinder2;
      }(regexp_to_ast_1.BaseRegExpVisitor)
    );
    function canMatchCharCode(charCodes, pattern) {
      if (pattern instanceof RegExp) {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
      } else {
        return (0, find_1.default)(pattern, function(char) {
          return (0, includes_1.default)(charCodes, char.charCodeAt(0));
        }) !== void 0;
      }
    }
    exports2.canMatchCharCode = canMatchCharCode;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js
var require_lexer2 = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var lexer_public_1 = require_lexer_public();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var values_1 = __importDefault(require_values());
    var flatten_1 = __importDefault(require_flatten());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var indexOf_1 = __importDefault(require_indexOf());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var filter_1 = __importDefault(require_filter());
    var defaults_1 = __importDefault(require_defaults());
    var reduce_1 = __importDefault(require_reduce());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_1 = require_reg_exp();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var PATTERN = "PATTERN";
    exports2.DEFAULT_MODE = "defaultMode";
    exports2.MODES = "modes";
    exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    function disableSticky() {
      exports2.SUPPORT_STICKY = false;
    }
    exports2.disableSticky = disableSticky;
    function enableSticky() {
      exports2.SUPPORT_STICKY = true;
    }
    exports2.enableSticky = enableSticky;
    function analyzeTokenTypes(tokenTypes, options) {
      options = (0, defaults_1.default)(options, {
        useSticky: exports2.SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function(msg, action) {
          return action();
        }
      });
      var tracer = options.tracer;
      tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
      });
      var onlyRelevantTypes;
      tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
      });
      var hasCustom = false;
      var allTransformedPatterns;
      tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          var currPattern = currType[PATTERN];
          if ((0, isRegExp_1.default)(currPattern)) {
            var regExpSource = currPattern.source;
            if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
            regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
              return regExpSource;
            } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
            !(0, includes_1.default)([
              "d",
              "D",
              "s",
              "S",
              "t",
              "r",
              "n",
              "t",
              "0",
              "c",
              "b",
              "B",
              "f",
              "v",
              "w",
              "W"
            ], regExpSource[1])) {
              return regExpSource[1];
            } else {
              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            }
          } else if ((0, isFunction_1.default)(currPattern)) {
            hasCustom = true;
            return { exec: currPattern };
          } else if (typeof currPattern === "object") {
            hasCustom = true;
            return currPattern;
          } else if (typeof currPattern === "string") {
            if (currPattern.length === 1) {
              return currPattern;
            } else {
              var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
              var wrappedRegExp = new RegExp(escapedRegExpString);
              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
            }
          } else {
            throw Error("non exhaustive match");
          }
        });
      });
      var patternIdxToType;
      var patternIdxToGroup;
      var patternIdxToLongerAltIdxArr;
      var patternIdxToPushMode;
      var patternIdxToPopMode;
      tracer("misc mapping", function() {
        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var groupName = clazz.GROUP;
          if (groupName === lexer_public_1.Lexer.SKIPPED) {
            return void 0;
          } else if ((0, isString_1.default)(groupName)) {
            return groupName;
          } else if ((0, isUndefined_1.default)(groupName)) {
            return false;
          } else {
            throw Error("non exhaustive match");
          }
        });
        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var longerAltType = clazz.LONGER_ALT;
          if (longerAltType) {
            var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
              return (0, indexOf_1.default)(onlyRelevantTypes, type);
            }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
            return longerAltIdxArr;
          }
        });
        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return (0, has_1.default)(clazz, "POP_MODE");
        });
      });
      var patternIdxToCanLineTerminator;
      tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
          return false;
        });
        if (options.positionTracking !== "onlyOffset") {
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              return !!tokType.LINE_BREAKS;
            } else {
              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
          });
        }
      });
      var patternIdxToIsCustom;
      var patternIdxToShort;
      var emptyGroups;
      var patternIdxToConfig;
      tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
          var groupName = clazz.GROUP;
          if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
            acc[groupName] = [];
          }
          return acc;
        }, {});
        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
          return {
            pattern: allTransformedPatterns[idx],
            longerAlt: patternIdxToLongerAltIdxArr[idx],
            canLineTerminator: patternIdxToCanLineTerminator[idx],
            isCustom: patternIdxToIsCustom[idx],
            short: patternIdxToShort[idx],
            group: patternIdxToGroup[idx],
            push: patternIdxToPushMode[idx],
            pop: patternIdxToPopMode[idx],
            tokenTypeIdx: patternIdxToType[idx],
            tokenType: onlyRelevantTypes[idx]
          };
        });
      });
      var canBeOptimized = true;
      var charCodeToPatternIdxToConfig = [];
      if (!options.safeMode) {
        tracer("First Char Optimization", function() {
          charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
              var charCode = currTokType.PATTERN.charCodeAt(0);
              var optimizedIdx = charCodeToOptimizedIndex(charCode);
              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
              var lastOptimizedIdx_1;
              (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                  lastOptimizedIdx_1 = currOptimizedIdx;
                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                }
              });
            } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
              if (currTokType.PATTERN.unicode) {
                canBeOptimized = false;
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                }
              } else {
                var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                if ((0, isEmpty_1.default)(optimizedCodes)) {
                  canBeOptimized = false;
                }
                (0, forEach_1.default)(optimizedCodes, function(code) {
                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                });
              }
            } else {
              if (options.ensureOptimizations) {
                (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
              }
              canBeOptimized = false;
            }
            return result;
          }, []);
        });
      }
      return {
        emptyGroups,
        patternIdxToConfig,
        charCodeToPatternIdxToConfig,
        hasCustom,
        canBeOptimized
      };
    }
    exports2.analyzeTokenTypes = analyzeTokenTypes;
    function validatePatterns(tokenTypes, validModesNames) {
      var errors = [];
      var missingResult = findMissingPatterns(tokenTypes);
      errors = errors.concat(missingResult.errors);
      var invalidResult = findInvalidPatterns(missingResult.valid);
      var validTokenTypes = invalidResult.valid;
      errors = errors.concat(invalidResult.errors);
      errors = errors.concat(validateRegExpPattern(validTokenTypes));
      errors = errors.concat(findInvalidGroupType(validTokenTypes));
      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
      errors = errors.concat(findUnreachablePatterns(validTokenTypes));
      return errors;
    }
    exports2.validatePatterns = validatePatterns;
    function validateRegExpPattern(tokenTypes) {
      var errors = [];
      var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
        return (0, isRegExp_1.default)(currTokType[PATTERN]);
      });
      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
      return errors;
    }
    function findMissingPatterns(tokenTypes) {
      var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        return !(0, has_1.default)(currType, PATTERN);
      });
      var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
          type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid2 = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
      return { errors, valid: valid2 };
    }
    exports2.findMissingPatterns = findMissingPatterns;
    function findInvalidPatterns(tokenTypes) {
      var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
      });
      var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid2 = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
      return { errors, valid: valid2 };
    }
    exports2.findInvalidPatterns = findInvalidPatterns;
    var end_of_input = /[^\\][$]/;
    function findEndOfInputAnchor(tokenTypes) {
      var EndAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(EndAnchorFinder2, _super);
          function EndAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
            this.found = true;
          };
          return EndAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var endAnchorVisitor = new EndAnchorFinder();
          endAnchorVisitor.visit(regexpAst);
          return endAnchorVisitor.found;
        } catch (e) {
          return end_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEndOfInputAnchor = findEndOfInputAnchor;
    function findEmptyMatchRegExps(tokenTypes) {
      var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        return pattern.test("");
      });
      var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
          type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
    var start_of_input = /[^\\[][\^]|^\^/;
    function findStartOfInputAnchor(tokenTypes) {
      var StartAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(StartAnchorFinder2, _super);
          function StartAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
            this.found = true;
          };
          return StartAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var startAnchorVisitor = new StartAnchorFinder();
          startAnchorVisitor.visit(regexpAst);
          return startAnchorVisitor.found;
        } catch (e) {
          return start_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findStartOfInputAnchor = findStartOfInputAnchor;
    function findUnsupportedFlags(tokenTypes) {
      var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
      });
      var errors = (0, map_1.default)(invalidFlags, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
          type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findUnsupportedFlags = findUnsupportedFlags;
    function findDuplicatePatterns(tokenTypes) {
      var found = [];
      var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
        return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
          if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
            found.push(innerType);
            result.push(innerType);
            return result;
          }
          return result;
        }, []);
      });
      identicalPatterns = (0, compact_1.default)(identicalPatterns);
      var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
      });
      var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
          return currType.name;
        });
        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
        return {
          message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
          type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
          tokenTypes: setOfIdentical
        };
      });
      return errors;
    }
    exports2.findDuplicatePatterns = findDuplicatePatterns;
    function findInvalidGroupType(tokenTypes) {
      var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
        if (!(0, has_1.default)(clazz, "GROUP")) {
          return false;
        }
        var group = clazz.GROUP;
        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
      });
      var errors = (0, map_1.default)(invalidTypes, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findInvalidGroupType = findInvalidGroupType;
    function findModesThatDoNotExist(tokenTypes, validModes) {
      var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
      });
      var errors = (0, map_1.default)(invalidModes, function(tokType) {
        var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
        return {
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
          tokenTypes: [tokType]
        };
      });
      return errors;
    }
    exports2.findModesThatDoNotExist = findModesThatDoNotExist;
    function findUnreachablePatterns(tokenTypes) {
      var errors = [];
      var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === lexer_public_1.Lexer.NA) {
          return result;
        }
        if ((0, isString_1.default)(pattern)) {
          result.push({ str: pattern, idx, tokenType: tokType });
        } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
          result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
      }, []);
      (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
        (0, forEach_1.default)(canBeTested, function(_a) {
          var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
            var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
            errors.push({
              message: msg,
              type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
              tokenTypes: [tokType, tokenType]
            });
          }
        });
      });
      return errors;
    }
    exports2.findUnreachablePatterns = findUnreachablePatterns;
    function testTokenType(str, pattern) {
      if ((0, isRegExp_1.default)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
      } else if ((0, isFunction_1.default)(pattern)) {
        return pattern(str, 0, [], {});
      } else if ((0, has_1.default)(pattern, "exec")) {
        return pattern.exec(str, 0, [], {});
      } else if (typeof pattern === "string") {
        return pattern === str;
      } else {
        throw Error("non exhaustive match");
      }
    }
    function noMetaChar(regExp) {
      var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
      ];
      return (0, find_1.default)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
      }) === void 0;
    }
    function addStartOfInput(pattern) {
      var flags = pattern.ignoreCase ? "i" : "";
      return new RegExp("^(?:".concat(pattern.source, ")"), flags);
    }
    exports2.addStartOfInput = addStartOfInput;
    function addStickyFlag(pattern) {
      var flags = pattern.ignoreCase ? "iy" : "y";
      return new RegExp("".concat(pattern.source), flags);
    }
    exports2.addStickyFlag = addStickyFlag;
    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var errors = [];
      if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
      }
      if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
        (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
          (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
            if ((0, isUndefined_1.default)(currTokType)) {
              errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
              });
            } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
              var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
              (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                  errors.push({
                    message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                    type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                  });
                }
              });
            }
          });
        });
      }
      return errors;
    }
    exports2.performRuntimeChecks = performRuntimeChecks;
    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var warnings = [];
      var hasAnyLineBreak = false;
      var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
      var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
        return currType[PATTERN] === lexer_public_1.Lexer.NA;
      });
      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
      if (trackLines) {
        (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
          if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
              message,
              type: currIssue.issue,
              tokenType: tokType
            };
            warnings.push(warningDescriptor);
          } else {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              if (tokType.LINE_BREAKS === true) {
                hasAnyLineBreak = true;
              }
            } else {
              if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                hasAnyLineBreak = true;
              }
            }
          }
        });
      }
      if (trackLines && !hasAnyLineBreak) {
        warnings.push({
          message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
      }
      return warnings;
    }
    exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
    function cloneEmptyGroups(emptyGroups) {
      var clonedResult = {};
      var groupKeys = (0, keys_1.default)(emptyGroups);
      (0, forEach_1.default)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        if ((0, isArray_1.default)(currGroupValue)) {
          clonedResult[currKey] = [];
        } else {
          throw Error("non exhaustive match");
        }
      });
      return clonedResult;
    }
    exports2.cloneEmptyGroups = cloneEmptyGroups;
    function isCustomPattern(tokenType) {
      var pattern = tokenType.PATTERN;
      if ((0, isRegExp_1.default)(pattern)) {
        return false;
      } else if ((0, isFunction_1.default)(pattern)) {
        return true;
      } else if ((0, has_1.default)(pattern, "exec")) {
        return true;
      } else if ((0, isString_1.default)(pattern)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.isCustomPattern = isCustomPattern;
    function isShortPattern(pattern) {
      if ((0, isString_1.default)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
      } else {
        return false;
      }
    }
    exports2.isShortPattern = isShortPattern;
    exports2.LineTerminatorOptimizedTester = {
      // implements /\n|\r\n?/g.test
      test: function(text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
          var c = text.charCodeAt(i);
          if (c === 10) {
            this.lastIndex = i + 1;
            return true;
          } else if (c === 13) {
            if (text.charCodeAt(i + 1) === 10) {
              this.lastIndex = i + 2;
            } else {
              this.lastIndex = i + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
      if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
        return false;
      } else {
        if ((0, isRegExp_1.default)(tokType.PATTERN)) {
          try {
            (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
          } catch (e) {
            return {
              issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
              errMsg: e.message
            };
          }
          return false;
        } else if ((0, isString_1.default)(tokType.PATTERN)) {
          return false;
        } else if (isCustomPattern(tokType)) {
          return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        } else {
          throw Error("non exhaustive match");
        }
      }
    }
    function buildLineBreakIssueMessage(tokType, details) {
      if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
    function getCharCodes(charsOrCodes) {
      var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
        if ((0, isString_1.default)(numOrString)) {
          return numOrString.charCodeAt(0);
        } else {
          return numOrString;
        }
      });
      return charCodes;
    }
    function addToMapOfArrays(map3, key, value) {
      if (map3[key] === void 0) {
        map3[key] = [value];
      } else {
        map3[key].push(value);
      }
    }
    exports2.minOptimizationVal = 256;
    var charCodeToOptimizedIdxMap = [];
    function charCodeToOptimizedIndex(charCode) {
      return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
    }
    exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
    function initCharCodeToOptimizedIndexMap() {
      if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
          charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
        }
      }
    }
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js
var require_last = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js
var require_tokens = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    function tokenStructuredMatcher(tokInstance, tokConstructor) {
      var instanceType = tokInstance.tokenTypeIdx;
      if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
      } else {
        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
      }
    }
    exports2.tokenStructuredMatcher = tokenStructuredMatcher;
    function tokenStructuredMatcherNoCategories(token, tokType) {
      return token.tokenTypeIdx === tokType.tokenTypeIdx;
    }
    exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
    exports2.tokenShortNameIdx = 1;
    exports2.tokenIdxToClass = {};
    function augmentTokenTypes(tokenTypes) {
      var tokenTypesAndParents = expandCategories(tokenTypes);
      assignTokenDefaultProps(tokenTypesAndParents);
      assignCategoriesMapProp(tokenTypesAndParents);
      assignCategoriesTokensProp(tokenTypesAndParents);
      (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
      });
    }
    exports2.augmentTokenTypes = augmentTokenTypes;
    function expandCategories(tokenTypes) {
      var result = (0, clone_1.default)(tokenTypes);
      var categories = tokenTypes;
      var searching = true;
      while (searching) {
        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
          return currTokType.CATEGORIES;
        })));
        var newCategories = (0, difference_1.default)(categories, result);
        result = result.concat(newCategories);
        if ((0, isEmpty_1.default)(newCategories)) {
          searching = false;
        } else {
          categories = newCategories;
        }
      }
      return result;
    }
    exports2.expandCategories = expandCategories;
    function assignTokenDefaultProps(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
          exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
          currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
        }
        if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
          currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
          currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
          currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
          currTokType.categoryMatchesMap = {};
        }
      });
    }
    exports2.assignTokenDefaultProps = assignTokenDefaultProps;
    function assignCategoriesTokensProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        currTokType.categoryMatches = [];
        (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
          currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
        });
      });
    }
    exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
    function assignCategoriesMapProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
      });
    }
    exports2.assignCategoriesMapProp = assignCategoriesMapProp;
    function singleAssignCategoriesToksMap(path, nextNode) {
      (0, forEach_1.default)(path, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
      });
      (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path.concat(nextNode);
        if (!(0, includes_1.default)(newPath, nextCategory)) {
          singleAssignCategoriesToksMap(newPath, nextCategory);
        }
      });
    }
    exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
    function hasShortKeyProperty(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.hasShortKeyProperty = hasShortKeyProperty;
    function hasCategoriesProperty(tokType) {
      return (0, has_1.default)(tokType, "CATEGORIES");
    }
    exports2.hasCategoriesProperty = hasCategoriesProperty;
    function hasExtendingTokensTypesProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatches");
    }
    exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
    function hasExtendingTokensTypesMapProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatchesMap");
    }
    exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
    function isTokenType(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.isTokenType = isTokenType;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var require_lexer_errors_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLexerErrorProvider = void 0;
    exports2.defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
      },
      buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
        return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
      }
    };
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js
var require_lexer_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
    var lexer_1 = require_lexer2();
    var noop_1 = __importDefault(require_noop());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var last_1 = __importDefault(require_last());
    var reject_1 = __importDefault(require_reject());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var identity_1 = __importDefault(require_identity2());
    var assign_1 = __importDefault(require_assign());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var tokens_1 = require_tokens();
    var lexer_errors_public_1 = require_lexer_errors_public();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var LexerDefinitionErrorType2;
    (function(LexerDefinitionErrorType3) {
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType2 = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
    var DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    var Lexer2 = (
      /** @class */
      function() {
        function Lexer3(lexerDefinition, config) {
          if (config === void 0) {
            config = DEFAULT_LEXER_CONFIG;
          }
          var _this = this;
          this.lexerDefinition = lexerDefinition;
          this.lexerDefinitionErrors = [];
          this.lexerDefinitionWarning = [];
          this.patternIdxToConfig = {};
          this.charCodeToPatternIdxToConfig = {};
          this.modes = [];
          this.emptyGroups = {};
          this.trackStartLines = true;
          this.trackEndLines = true;
          this.hasCustom = false;
          this.canModeBeOptimized = {};
          this.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (_this.traceInitPerf === true) {
              _this.traceInitIndent++;
              var indent2 = new Array(_this.traceInitIndent + 1).join("	");
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                console.log("".concat(indent2, "--> <").concat(phaseDesc, ">"));
              }
              var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                traceMethod("".concat(indent2, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              _this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
          }
          this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);
          var traceInitVal = this.config.traceInitPerf;
          if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
          } else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
          }
          this.traceInitIndent = -1;
          this.TRACE_INIT("Lexer Constructor", function() {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function() {
              if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
              } else {
                if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                  throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                }
              }
              if (config.safeMode && config.ensureOptimizations) {
                throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
              }
              _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
              _this.trackEndLines = /full/i.test(_this.config.positionTracking);
              if ((0, isArray_1.default)(lexerDefinition)) {
                actualDefinition = {
                  modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                  defaultMode: lexer_1.DEFAULT_MODE
                };
              } else {
                hasOnlySingleMode = false;
                actualDefinition = (0, clone_1.default)(lexerDefinition);
              }
            });
            if (_this.config.skipValidations === false) {
              _this.TRACE_INIT("performRuntimeChecks", function() {
                _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
              _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
            }
            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
            (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
              actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                return (0, isUndefined_1.default)(currTokType);
              });
            });
            var allModeNames = (0, keys_1.default)(actualDefinition.modes);
            (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
              _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                _this.modes.push(currModName);
                if (_this.config.skipValidations === false) {
                  _this.TRACE_INIT("validatePatterns", function() {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                  });
                }
                if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                  (0, tokens_1.augmentTokenTypes)(currModDef);
                  var currAnalyzeResult_1;
                  _this.TRACE_INIT("analyzeTokenTypes", function() {
                    currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                      lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                      positionTracking: config.positionTracking,
                      ensureOptimizations: config.ensureOptimizations,
                      safeMode: config.safeMode,
                      tracer: _this.TRACE_INIT
                    });
                  });
                  _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                  _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                  _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                  _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                  _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                }
              });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
              var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
              (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function() {
              if (lexer_1.SUPPORT_STICKY) {
                _this.chopInput = identity_1.default;
                _this.match = _this.matchWithTest;
              } else {
                _this.updateLastIndex = noop_1.default;
                _this.match = _this.matchWithExec;
              }
              if (hasOnlySingleMode) {
                _this.handleModes = noop_1.default;
              }
              if (_this.trackStartLines === false) {
                _this.computeNewColumn = identity_1.default;
              }
              if (_this.trackEndLines === false) {
                _this.updateTokenEndLineColumnLocation = noop_1.default;
              }
              if (/full/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createFullToken;
              } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createStartOnlyToken;
              } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createOffsetOnlyToken;
              } else {
                throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
              }
              if (_this.hasCustom) {
                _this.addToken = _this.addTokenUsingPush;
                _this.handlePayload = _this.handlePayloadWithCustom;
              } else {
                _this.addToken = _this.addTokenUsingMemberAccess;
                _this.handlePayload = _this.handlePayloadNoCustom;
              }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function() {
              var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                if (canBeOptimized === false) {
                  cannotBeOptimized.push(modeName);
                }
                return cannotBeOptimized;
              }, []);
              if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
              }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function() {
              (0, reg_exp_parser_1.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function() {
              (0, utils_1.toFastProperties)(_this);
            });
          });
        }
        Lexer3.prototype.tokenize = function(text, initialMode) {
          if (initialMode === void 0) {
            initialMode = this.defaultMode;
          }
          if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
              return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          return this.tokenizeInternal(text, initialMode);
        };
        Lexer3.prototype.tokenizeInternal = function(text, initialMode) {
          var _this = this;
          var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
          var orgText = text;
          var orgLength = orgText.length;
          var offset = 0;
          var matchedTokensIndex = 0;
          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
          var matchedTokens = new Array(guessedNumberOfTokens);
          var errors = [];
          var line = this.trackStartLines ? 1 : void 0;
          var column = this.trackStartLines ? 1 : void 0;
          var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
          var trackLines = this.trackStartLines;
          var lineTerminatorPattern = this.config.lineTerminatorsPattern;
          var currModePatternsLength = 0;
          var patternIdxToConfig = [];
          var currCharCodeToPatternIdxToConfig = [];
          var modeStack = [];
          var emptyArray = [];
          Object.freeze(emptyArray);
          var getPossiblePatterns;
          function getPossiblePatternsSlow() {
            return patternIdxToConfig;
          }
          function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === void 0) {
              return emptyArray;
            } else {
              return possiblePatterns;
            }
          }
          var pop_mode = function(popToken) {
            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
            // So no error should occur.
            popToken.tokenType.PUSH_MODE === void 0) {
              var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
              errors.push({
                offset: popToken.startOffset,
                line: popToken.startLine,
                column: popToken.startColumn,
                length: popToken.image.length,
                message: msg_1
              });
            } else {
              modeStack.pop();
              var newMode = (0, last_1.default)(modeStack);
              patternIdxToConfig = _this.patternIdxToConfig[newMode];
              currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
          };
          function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
          push_mode.call(this, initialMode);
          var currConfig;
          var recoveryEnabled = this.config.recoveryEnabled;
          while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
              currConfig = chosenPatternIdxToConfig[i];
              var currPattern = currConfig.pattern;
              payload = null;
              var singleCharCode = currConfig.short;
              if (singleCharCode !== false) {
                if (nextCharCode === singleCharCode) {
                  matchedImage = currPattern;
                }
              } else if (currConfig.isCustom === true) {
                match = currPattern.exec(orgText, offset, matchedTokens, groups);
                if (match !== null) {
                  matchedImage = match[0];
                  if (match.payload !== void 0) {
                    payload = match.payload;
                  }
                } else {
                  matchedImage = null;
                }
              } else {
                this.updateLastIndex(currPattern, offset);
                matchedImage = this.match(currPattern, text, offset);
              }
              if (matchedImage !== null) {
                longerAlt = currConfig.longerAlt;
                if (longerAlt !== void 0) {
                  var longerAltLength = longerAlt.length;
                  for (k = 0; k < longerAltLength; k++) {
                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                    var longerAltPattern = longerAltConfig.pattern;
                    altPayload = null;
                    if (longerAltConfig.isCustom === true) {
                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                      if (match !== null) {
                        matchAltImage = match[0];
                        if (match.payload !== void 0) {
                          altPayload = match.payload;
                        }
                      } else {
                        matchAltImage = null;
                      }
                    } else {
                      this.updateLastIndex(longerAltPattern, offset);
                      matchAltImage = this.match(longerAltPattern, text, offset);
                    }
                    if (matchAltImage && matchAltImage.length > matchedImage.length) {
                      matchedImage = matchAltImage;
                      payload = altPayload;
                      currConfig = longerAltConfig;
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (matchedImage !== null) {
              imageLength = matchedImage.length;
              group = currConfig.group;
              if (group !== void 0) {
                tokType = currConfig.tokenTypeIdx;
                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                this.handlePayload(newToken, payload);
                if (group === false) {
                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                } else {
                  groups[group].push(newToken);
                }
              }
              text = this.chopInput(text, imageLength);
              offset = offset + imageLength;
              column = this.computeNewColumn(column, imageLength);
              if (trackLines === true && currConfig.canLineTerminator === true) {
                var numOfLTsInMatch = 0;
                var foundTerminator = void 0;
                var lastLTEndOffset = void 0;
                lineTerminatorPattern.lastIndex = 0;
                do {
                  foundTerminator = lineTerminatorPattern.test(matchedImage);
                  if (foundTerminator === true) {
                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                    numOfLTsInMatch++;
                  }
                } while (foundTerminator === true);
                if (numOfLTsInMatch !== 0) {
                  line = line + numOfLTsInMatch;
                  column = imageLength - lastLTEndOffset;
                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                }
              }
              this.handleModes(currConfig, pop_mode, push_mode, newToken);
            } else {
              var errorStartOffset = offset;
              var errorLine = line;
              var errorColumn = column;
              var foundResyncPoint = recoveryEnabled === false;
              while (foundResyncPoint === false && offset < orgLength) {
                text = this.chopInput(text, 1);
                offset++;
                for (j = 0; j < currModePatternsLength; j++) {
                  var currConfig_1 = patternIdxToConfig[j];
                  var currPattern = currConfig_1.pattern;
                  var singleCharCode = currConfig_1.short;
                  if (singleCharCode !== false) {
                    if (orgText.charCodeAt(offset) === singleCharCode) {
                      foundResyncPoint = true;
                    }
                  } else if (currConfig_1.isCustom === true) {
                    foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                  } else {
                    this.updateLastIndex(currPattern, offset);
                    foundResyncPoint = currPattern.exec(text) !== null;
                  }
                  if (foundResyncPoint === true) {
                    break;
                  }
                }
              }
              errLength = offset - errorStartOffset;
              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
              errors.push({
                offset: errorStartOffset,
                line: errorLine,
                column: errorColumn,
                length: errLength,
                message: msg
              });
              if (recoveryEnabled === false) {
                break;
              }
            }
          }
          if (!this.hasCustom) {
            matchedTokens.length = matchedTokensIndex;
          }
          return {
            tokens: matchedTokens,
            groups,
            errors
          };
        };
        Lexer3.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
          if (config.pop === true) {
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== void 0) {
              push_mode.call(this, pushMode);
            }
          } else if (config.push !== void 0) {
            push_mode.call(this, config.push);
          }
        };
        Lexer3.prototype.chopInput = function(text, length) {
          return text.substring(length);
        };
        Lexer3.prototype.updateLastIndex = function(regExp, newLastIndex) {
          regExp.lastIndex = newLastIndex;
        };
        Lexer3.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
          var lastCharIsLT, fixForEndingInLT;
          if (group !== void 0) {
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
              newToken.endLine = line + fixForEndingInLT;
              newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
          }
        };
        Lexer3.prototype.computeNewColumn = function(oldColumn, imageLength) {
          return oldColumn + imageLength;
        };
        Lexer3.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
          return {
            image,
            startOffset,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
          return {
            image,
            startOffset,
            startLine,
            startColumn,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
          return {
            image,
            startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine,
            endLine: startLine,
            startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
          tokenVector.push(tokenToAdd);
          return index;
        };
        Lexer3.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
          tokenVector[index] = tokenToAdd;
          index++;
          return index;
        };
        Lexer3.prototype.handlePayloadNoCustom = function(token, payload) {
        };
        Lexer3.prototype.handlePayloadWithCustom = function(token, payload) {
          if (payload !== null) {
            token.payload = payload;
          }
        };
        Lexer3.prototype.matchWithTest = function(pattern, text, offset) {
          var found = pattern.test(text);
          if (found === true) {
            return text.substring(offset, pattern.lastIndex);
          }
          return null;
        };
        Lexer3.prototype.matchWithExec = function(pattern, text) {
          var regExpArray = pattern.exec(text);
          return regExpArray !== null ? regExpArray[0] : null;
        };
        Lexer3.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
        Lexer3.NA = /NOT_APPLICABLE/;
        return Lexer3;
      }()
    );
    exports2.Lexer = Lexer2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js
var require_tokens_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
    var isString_1 = __importDefault(require_isString());
    var has_1 = __importDefault(require_has());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    exports2.tokenLabel = tokenLabel2;
    function tokenName2(tokType) {
      return tokType.name;
    }
    exports2.tokenName = tokenName2;
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    exports2.hasTokenLabel = hasTokenLabel;
    var PARENT = "parent";
    var CATEGORIES = "categories";
    var LABEL = "label";
    var GROUP = "group";
    var PUSH_MODE = "push_mode";
    var POP_MODE = "pop_mode";
    var LONGER_ALT = "longer_alt";
    var LINE_BREAKS = "line_breaks";
    var START_CHARS_HINT = "start_chars_hint";
    function createToken2(config) {
      return createTokenInternal(config);
    }
    exports2.createToken = createToken2;
    function createTokenInternal(config) {
      var pattern = config.pattern;
      var tokenType = {};
      tokenType.name = config.name;
      if (!(0, isUndefined_1.default)(pattern)) {
        tokenType.PATTERN = pattern;
      }
      if ((0, has_1.default)(config, PARENT)) {
        throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      if ((0, has_1.default)(config, CATEGORIES)) {
        tokenType.CATEGORIES = config[CATEGORIES];
      }
      (0, tokens_1.augmentTokenTypes)([tokenType]);
      if ((0, has_1.default)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
      }
      if ((0, has_1.default)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
      }
      if ((0, has_1.default)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
      }
      if ((0, has_1.default)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
      }
      if ((0, has_1.default)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
      }
      if ((0, has_1.default)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
      }
      if ((0, has_1.default)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
      }
      return tokenType;
    }
    exports2.EOF = createToken2({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
    function createTokenInstance2(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
      return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
      };
    }
    exports2.createTokenInstance = createTokenInstance2;
    function tokenMatcher2(token, tokType) {
      return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
    }
    exports2.tokenMatcher = tokenMatcher2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js
var require_errors_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
    var tokens_public_1 = require_tokens_public();
    var first_1 = __importDefault(require_first2());
    var map_1 = __importDefault(require_map2());
    var reduce_1 = __importDefault(require_reduce());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    exports2.defaultParserErrorProvider = {
      buildMismatchTokenMessage: function(_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
        var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
        return msg;
      },
      buildNotAllInputParsedMessage: function(_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage: function(_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
            return result.concat(currAltPaths);
          }, []);
          var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(", "), "]");
          });
          var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
            return "  ".concat(idx + 1, ". ").concat(itemMsg);
          });
          var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage: function(_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(","), "]");
          });
          var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(exports2.defaultParserErrorProvider);
    exports2.defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    exports2.defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
          if (prod instanceof gast_1.Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof gast_1.NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, first_1.default)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
          return (0, tokens_public_1.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        return errMsg;
      },
      buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
          return (0, tokens_public_1.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
        return currMessage;
      },
      buildEmptyRepetitionError: function(options) {
        var dslName = (0, gast_2.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildTokenNameError: function(options) {
        return "deprecated";
      },
      buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
      },
      buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
        return errMsg;
      },
      buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
          return currRule.name;
        });
        var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
        var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildInvalidRuleNameError: function(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof gast_1.Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
        return errMsg;
      }
    };
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js
var require_resolver = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
    var parser_1 = require_parser2();
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var gast_1 = require_api2();
    function resolveGrammar(topLevels, errMsgProvider) {
      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
      refResolver.resolveRefs();
      return refResolver.errors;
    }
    exports2.resolveGrammar = resolveGrammar;
    var GastRefResolverVisitor = (
      /** @class */
      function(_super) {
        __extends(GastRefResolverVisitor2, _super);
        function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
          var _this = _super.call(this) || this;
          _this.nameToTopRule = nameToTopRule;
          _this.errMsgProvider = errMsgProvider;
          _this.errors = [];
          return _this;
        }
        GastRefResolverVisitor2.prototype.resolveRefs = function() {
          var _this = this;
          (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
          });
        };
        GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
          var ref = this.nameToTopRule[node.nonTerminalName];
          if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
              message: msg,
              type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: node.nonTerminalName
            });
          } else {
            node.referencedRule = ref;
          }
        };
        return GastRefResolverVisitor2;
      }(gast_1.GAstVisitor)
    );
    exports2.GastRefResolverVisitor = GastRefResolverVisitor;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js"(exports2, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module2.exports = groupBy;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var map3 = require_map2();
    function flatMap(collection, iteratee) {
      return baseFlatten(map3(collection, iteratee), 1);
    }
    module2.exports = flatMap;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js
var require_dropRight = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module2.exports = dropRight;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
var require_interpreter = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var drop_1 = __importDefault(require_drop());
    var last_1 = __importDefault(require_last());
    var forEach_1 = __importDefault(require_forEach());
    var clone_1 = __importDefault(require_clone());
    var first_2 = require_first();
    var gast_1 = require_api2();
    var AbstractNextPossibleTokensWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextPossibleTokensWalker2, _super);
        function AbstractNextPossibleTokensWalker2(topProd, path) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.path = path;
          _this.possibleTokTypes = [];
          _this.nextProductionName = "";
          _this.nextProductionOccurrence = 0;
          _this.found = false;
          _this.isAtEndOfPath = false;
          return _this;
        }
        AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
          this.found = false;
          if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
          }
          this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
          this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
          this.ruleStack.pop();
          this.occurrenceStack.pop();
          this.updateExpectedNext();
          this.walk(this.topProd);
          return this.possibleTokTypes;
        };
        AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
          if (prevRest === void 0) {
            prevRest = [];
          }
          if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
          if ((0, isEmpty_1.default)(this.ruleStack)) {
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
          } else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
          }
        };
        return AbstractNextPossibleTokensWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
    var NextAfterTokenWalker = (
      /** @class */
      function(_super) {
        __extends(NextAfterTokenWalker2, _super);
        function NextAfterTokenWalker2(topProd, path) {
          var _this = _super.call(this, topProd, path) || this;
          _this.path = path;
          _this.nextTerminalName = "";
          _this.nextTerminalOccurrence = 0;
          _this.nextTerminalName = _this.path.lastTok.name;
          _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
          return _this;
        }
        NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            this.possibleTokTypes = (0, first_2.first)(restProd);
            this.found = true;
          }
        };
        return NextAfterTokenWalker2;
      }(AbstractNextPossibleTokensWalker)
    );
    exports2.NextAfterTokenWalker = NextAfterTokenWalker;
    var AbstractNextTerminalAfterProductionWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextTerminalAfterProductionWalker2, _super);
        function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
          var _this = _super.call(this) || this;
          _this.topRule = topRule;
          _this.occurrence = occurrence;
          _this.result = {
            token: void 0,
            occurrence: void 0,
            isEndOfRule: void 0
          };
          return _this;
        }
        AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
          this.walk(this.topRule);
          return this.result;
        };
        return AbstractNextTerminalAfterProductionWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
    var NextTerminalAfterManyWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManyWalker2, _super);
        function NextTerminalAfterManyWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === void 0;
            if (firstAfterMany instanceof gast_1.Terminal) {
              this.result.token = firstAfterMany.terminalType;
              this.result.occurrence = firstAfterMany.idx;
            }
          } else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManyWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
    var NextTerminalAfterManySepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManySepWalker2, _super);
        function NextTerminalAfterManySepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === void 0;
            if (firstAfterManySep instanceof gast_1.Terminal) {
              this.result.token = firstAfterManySep.terminalType;
              this.result.occurrence = firstAfterManySep.idx;
            }
          } else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManySepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
    var NextTerminalAfterAtLeastOneWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneWalker2, _super);
        function NextTerminalAfterAtLeastOneWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
            if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
              this.result.token = firstAfterAtLeastOne.terminalType;
              this.result.occurrence = firstAfterAtLeastOne.idx;
            }
          } else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
    var NextTerminalAfterAtLeastOneSepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
        function NextTerminalAfterAtLeastOneSepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
          if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
          } else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneSepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
    function possiblePathsFrom(targetDef, maxLength, currPath) {
      if (currPath === void 0) {
        currPath = [];
      }
      currPath = (0, clone_1.default)(currPath);
      var result = [];
      var i = 0;
      function remainingPathWith(nextDef) {
        return nextDef.concat((0, drop_1.default)(targetDef, i + 1));
      }
      function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
      }
      while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        if (prod instanceof gast_1.Alternative) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.NonTerminal) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.Option) {
          result = getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var newDef = [
            new gast_1.Alternative({ definition: prod.definition }),
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ];
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Repetition) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Alternation) {
          (0, forEach_1.default)(prod.definition, function(currAlt) {
            if ((0, isEmpty_1.default)(currAlt.definition) === false) {
              result = getAlternativesForProd(currAlt.definition);
            }
          });
          return result;
        } else if (prod instanceof gast_1.Terminal) {
          currPath.push(prod.terminalType);
        } else {
          throw Error("non exhaustive match");
        }
        i++;
      }
      result.push({
        partialPath: currPath,
        suffixDef: (0, drop_1.default)(targetDef, i)
      });
      return result;
    }
    exports2.possiblePathsFrom = possiblePathsFrom;
    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
      var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
      var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
      var foundCompletePath = false;
      var tokenVectorLength = tokenVector.length;
      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
      var result = [];
      var possiblePaths = [];
      possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
      });
      while (!(0, isEmpty_1.default)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        if (currPath === EXIT_ALTERNATIVE) {
          if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
            possiblePaths.pop();
          }
          continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        if ((0, isEmpty_1.default)(currDef)) {
          continue;
        }
        var prod = currDef[0];
        if (prod === EXIT_NON_TERMINAL) {
          var nextPath = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: (0, dropRight_1.default)(currRuleStack),
            occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Terminal) {
          if (currIdx < tokenVectorLength - 1) {
            var nextIdx = currIdx + 1;
            var actualToken = tokenVector[nextIdx];
            if (tokMatcher(actualToken, prod.terminalType)) {
              var nextPath = {
                idx: nextIdx,
                def: (0, drop_1.default)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(nextPath);
            }
          } else if (currIdx === tokenVectorLength - 1) {
            result.push({
              nextTokenType: prod.terminalType,
              nextTokenOccurrence: prod.idx,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
            foundCompletePath = true;
          } else {
            throw Error("non exhaustive match");
          }
        } else if (prod instanceof gast_1.NonTerminal) {
          var newRuleStack = (0, clone_1.default)(currRuleStack);
          newRuleStack.push(prod.nonTerminalName);
          var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
          newOccurrenceStack.push(prod.idx);
          var nextPath = {
            idx: currIdx,
            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
            ruleStack: newRuleStack,
            occurrenceStack: newOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Option) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nextPathWith = {
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var secondIteration = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var secondIteration = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var nthRepetition = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Repetition) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nthRepetition = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Alternation) {
          for (var i = prod.definition.length - 1; i >= 0; i--) {
            var currAlt = prod.definition[i];
            var currAltPath = {
              idx: currIdx,
              def: currAlt.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
          }
        } else if (prod instanceof gast_1.Alternative) {
          possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
        } else if (prod instanceof gast_1.Rule) {
          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        } else {
          throw Error("non exhaustive match");
        }
      }
      return result;
    }
    exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
      var newRuleStack = (0, clone_1.default)(currRuleStack);
      newRuleStack.push(topRule.name);
      var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
      newCurrOccurrenceStack.push(1);
      return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
      };
    }
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
var require_lookahead = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var reduce_1 = __importDefault(require_reduce());
    var interpreter_1 = require_interpreter();
    var rest_1 = require_rest();
    var tokens_1 = require_tokens();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var PROD_TYPE;
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
    function getProdType(prod) {
      if (prod instanceof gast_1.Option || prod === "Option") {
        return PROD_TYPE.OPTION;
      } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
        return PROD_TYPE.REPETITION;
      } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
        return PROD_TYPE.REPETITION_MANDATORY;
      } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
        return PROD_TYPE.ALTERNATION;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProdType = getProdType;
    function getLookaheadPaths2(options) {
      var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
      var type = getProdType(prodType);
      if (type === PROD_TYPE.ALTERNATION) {
        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
      } else {
        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
      }
    }
    exports2.getLookaheadPaths = getLookaheadPaths2;
    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
      var numOfAlts = alts.length;
      var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
        return (0, every_1.default)(currAlt, function(currPath) {
          return currPath.length === 1;
        });
      });
      if (hasPredicates) {
        return function(orAlts) {
          var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
            return currAlt2.GATE;
          });
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t];
            if (currPredicate !== void 0 && currPredicate.call(this) === false) {
              continue;
            }
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher2(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
          }
          return void 0;
        };
      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
          return (0, flatten_1.default)(currAlt);
        });
        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
          (0, forEach_1.default)(currAlt, function(currTokType) {
            if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
              result[currTokType.tokenTypeIdx] = idx;
            }
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              if (!(0, has_1.default)(result, currExtendingType)) {
                result[currExtendingType] = idx;
              }
            });
          });
          return result;
        }, {});
        return function() {
          var nextToken = this.LA(1);
          return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
      } else {
        return function() {
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher2(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
          }
          return void 0;
        };
      }
    }
    exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
      var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
        return currPath.length === 1;
      });
      var numOfPaths = alt.length;
      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, flatten_1.default)(alt);
        if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
          var expectedTokenType = singleTokensTypes[0];
          var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
          };
        } else {
          var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
            result[currTokType.tokenTypeIdx] = true;
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              result[currExtendingType] = true;
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
          };
        }
      } else {
        return function() {
          nextPath:
            for (var j = 0; j < numOfPaths; j++) {
              var currPath = alt[j];
              var currPathLength = currPath.length;
              for (var i = 0; i < currPathLength; i++) {
                var nextToken = this.LA(i + 1);
                if (tokenMatcher2(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return true;
            }
          return false;
        };
      }
    }
    exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
    var RestDefinitionFinderWalker = (
      /** @class */
      function(_super) {
        __extends(RestDefinitionFinderWalker2, _super);
        function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          return _this;
        }
        RestDefinitionFinderWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.restDef;
        };
        RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
          }
          return false;
        };
        RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
          }
        };
        return RestDefinitionFinderWalker2;
      }(rest_1.RestWalker)
    );
    var InsideDefinitionFinderVisitor = (
      /** @class */
      function(_super) {
        __extends(InsideDefinitionFinderVisitor2, _super);
        function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
          var _this = _super.call(this) || this;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          _this.targetRef = targetRef;
          _this.result = [];
          return _this;
        }
        InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
            this.result = node.definition;
          }
        };
        InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
          this.checkIsTarget(node, PROD_TYPE.OPTION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
        };
        return InsideDefinitionFinderVisitor2;
      }(gast_2.GAstVisitor)
    );
    function initializeArrayOfArrays(size) {
      var result = new Array(size);
      for (var i = 0; i < size; i++) {
        result[i] = [];
      }
      return result;
    }
    function pathToHashKeys(path) {
      var keys = [""];
      for (var i = 0; i < path.length; i++) {
        var tokType = path[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
          var currShorterKey = keys[j];
          longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
          for (var t = 0; t < tokType.categoryMatches.length; t++) {
            var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
            longerKeys.push(currShorterKey + categoriesKeySuffix);
          }
        }
        keys = longerKeys;
      }
      return keys;
    }
    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        if (currAltIdx === idx) {
          continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
          var searchKey = searchPathKeys[searchIdx];
          if (otherAltKnownPathsKeys[searchKey] === true) {
            return false;
          }
        }
      }
      return true;
    }
    function lookAheadSequenceFromAlternatives(altsDefs, k) {
      var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
      });
      var finalResult = initializeArrayOfArrays(partialAlts.length);
      var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, forEach_1.default)(currAltPaths, function(item) {
          var keys = pathToHashKeys(item.partialPath);
          (0, forEach_1.default)(keys, function(currKey) {
            dict[currKey] = true;
          });
        });
        return dict;
      });
      var newData = partialAlts;
      for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx2) {
          var currAltPathsAndSuffixes = currDataset[altIdx2];
          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
            var prefixKeys = pathToHashKeys(currPathPrefix);
            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
            if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
              var currAltResult = finalResult[altIdx2];
              if (containsPath(currAltResult, currPathPrefix) === false) {
                currAltResult.push(currPathPrefix);
                for (var j = 0; j < prefixKeys.length; j++) {
                  var currKey = prefixKeys[j];
                  altsHashes[altIdx2][currKey] = true;
                }
              }
            } else {
              var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
              newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
              (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                var prefixKeys2 = pathToHashKeys(item.partialPath);
                (0, forEach_1.default)(prefixKeys2, function(key) {
                  altsHashes[altIdx2][key] = true;
                });
              });
            }
          }
        };
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
          _loop_1(altIdx);
        }
      }
      return finalResult;
    }
    exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
      ruleGrammar.accept(visitor);
      return lookAheadSequenceFromAlternatives(visitor.result, k);
    }
    exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
      ruleGrammar.accept(insideDefVisitor);
      var insideDef = insideDefVisitor.result;
      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
      var afterDef = afterDefWalker.startWalking();
      var insideFlat = new gast_1.Alternative({ definition: insideDef });
      var afterFlat = new gast_1.Alternative({ definition: afterDef });
      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
    }
    exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
    function containsPath(alternative, searchPath) {
      compareOtherPath:
        for (var i = 0; i < alternative.length; i++) {
          var otherPath = alternative[i];
          if (otherPath.length !== searchPath.length) {
            continue;
          }
          for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
            if (matchingTokens === false) {
              continue compareOtherPath;
            }
          }
          return true;
        }
      return false;
    }
    exports2.containsPath = containsPath;
    function isStrictPrefixOfPath(prefix, other) {
      return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
      });
    }
    exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
    function areTokenCategoriesNotUsed(lookAheadPaths) {
      return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
        return (0, every_1.default)(singleAltPaths, function(singlePath) {
          return (0, every_1.default)(singlePath, function(token) {
            return (0, isEmpty_1.default)(token.categoryMatches);
          });
        });
      });
    }
    exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js
var require_checks = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var drop_1 = __importDefault(require_drop());
    var flatten_1 = __importDefault(require_flatten());
    var filter_1 = __importDefault(require_filter());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var groupBy_1 = __importDefault(require_groupBy());
    var reduce_1 = __importDefault(require_reduce());
    var pickBy_1 = __importDefault(require_pickBy());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var flatMap_1 = __importDefault(require_flatMap());
    var clone_1 = __importDefault(require_clone());
    var parser_1 = require_parser2();
    var gast_1 = require_api2();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var gast_2 = require_api2();
    var gast_3 = require_api2();
    var dropRight_1 = __importDefault(require_dropRight());
    var compact_1 = __importDefault(require_compact());
    var tokens_1 = require_tokens();
    function validateLookahead(options) {
      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
        rules: options.rules,
        tokenTypes: options.tokenTypes,
        grammarName: options.grammarName
      });
      return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
        return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
      });
    }
    exports2.validateLookahead = validateLookahead;
    function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
      var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
      });
      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
      var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
      });
      var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
      });
      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
    }
    exports2.validateGrammar = validateGrammar;
    function validateDuplicateProductions(topLevelRule, errMsgProvider) {
      var collectorVisitor = new OccurrenceValidationCollector();
      topLevelRule.accept(collectorVisitor);
      var allRuleProductions = collectorVisitor.allProductions;
      var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
      var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
        return currGroup.length > 1;
      });
      var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
        var firstProd = (0, first_1.default)(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, gast_1.getProductionDslName)(firstProd);
        var defError = {
          message: msg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
          ruleName: topLevelRule.name,
          dslName,
          occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
          defError.parameter = param;
        }
        return defError;
      });
      return errors;
    }
    function identifyProductionForDuplicates(prod) {
      return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
    }
    exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_2.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_2.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }
    var OccurrenceValidationCollector = (
      /** @class */
      function(_super) {
        __extends(OccurrenceValidationCollector2, _super);
        function OccurrenceValidationCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
          this.allProductions.push(subrule);
        };
        OccurrenceValidationCollector2.prototype.visitOption = function(option) {
          this.allProductions.push(option);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
          this.allProductions.push(or);
        };
        OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
          this.allProductions.push(terminal);
        };
        return OccurrenceValidationCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
      var errors = [];
      var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) {
          return result + 1;
        }
        return result;
      }, 0);
      if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
          topLevelRule: rule,
          grammarName: className
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: rule.name
        });
      }
      return errors;
    }
    exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
      var errors = [];
      var errMsg;
      if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
          ruleName
        });
      }
      return errors;
    }
    exports2.validateRuleIsOverridden = validateRuleIsOverridden;
    function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
      if (path === void 0) {
        path = [];
      }
      var errors = [];
      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
      if ((0, isEmpty_1.default)(nextNonTerminals)) {
        return [];
      } else {
        var ruleName = topRule.name;
        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
          errors.push({
            message: errMsgProvider.buildLeftRecursionError({
              topLevelRule: topRule,
              leftRecursionPath: path
            }),
            type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
            ruleName
          });
        }
        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
          var newPath = (0, clone_1.default)(path);
          newPath.push(currRefRule);
          return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
      }
    }
    exports2.validateNoLeftRecursion = validateNoLeftRecursion;
    function getFirstNoneTerminal(definition) {
      var result = [];
      if ((0, isEmpty_1.default)(definition)) {
        return result;
      }
      var firstProd = (0, first_1.default)(definition);
      if (firstProd instanceof gast_2.NonTerminal) {
        result.push(firstProd.referencedRule);
      } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
      } else if (firstProd instanceof gast_2.Alternation) {
        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
          return getFirstNoneTerminal(currSubDef.definition);
        }));
      } else if (firstProd instanceof gast_2.Terminal) {
      } else {
        throw Error("non exhaustive match");
      }
      var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
      var hasMore = definition.length > 1;
      if (isFirstOptional && hasMore) {
        var rest = (0, drop_1.default)(definition);
        return result.concat(getFirstNoneTerminal(rest));
      } else {
        return result;
      }
    }
    exports2.getFirstNoneTerminal = getFirstNoneTerminal;
    var OrCollector = (
      /** @class */
      function(_super) {
        __extends(OrCollector2, _super);
        function OrCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.alternations = [];
          return _this;
        }
        OrCollector2.prototype.visitAlternation = function(node) {
          this.alternations.push(node);
        };
        return OrCollector2;
      }(gast_3.GAstVisitor)
    );
    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var exceptLast = (0, dropRight_1.default)(currOr.definition);
        return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
          var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
          if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
            return [
              {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              }
            ];
          } else {
            return [];
          }
        });
      });
      return errors;
    }
    exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
    function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      ors = (0, reject_1.default)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
      });
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
      });
      return errors;
    }
    exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
    var RepetitionCollector = (
      /** @class */
      function(_super) {
        __extends(RepetitionCollector2, _super);
        function RepetitionCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        RepetitionCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        return RepetitionCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.RepetitionCollector = RepetitionCollector;
    function validateTooManyAlts(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        if (currOr.definition.length > 255) {
          return [
            {
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            }
          ];
        } else {
          return [];
        }
      });
      return errors;
    }
    exports2.validateTooManyAlts = validateTooManyAlts;
    function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
      var errors = [];
      (0, forEach_1.default)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, forEach_1.default)(allRuleProductions, function(currProd) {
          var prodType = (0, lookahead_1.getProdType)(currProd);
          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
          var currOccurrence = currProd.idx;
          var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
          var pathsInsideProduction = paths[0];
          if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
            var errMsg = errMsgProvider.buildEmptyRepetitionError({
              topLevelRule: currTopRule,
              repetition: currProd
            });
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: currTopRule.name
            });
          }
        });
      });
      return errors;
    }
    exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var foundAmbiguousPaths = [];
      var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
          return result;
        }
        (0, forEach_1.default)(currAlt, function(currPath) {
          var altsCurrPathAppearsIn = [currAltIdx];
          (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
            if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
              altsCurrPathAppearsIn.push(currOtherAltIdx);
            }
          });
          if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
            foundAmbiguousPaths.push(currPath);
            result.push({
              alts: altsCurrPathAppearsIn,
              path: currPath
            });
          }
        });
        return result;
      }, []);
      var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
          return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
          topLevelRule: rule,
          alternation,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbDescriptor.path
        });
        return {
          message: currMessage,
          type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
          ruleName: rule.name,
          occurrence: alternation.idx,
          alternatives: currAmbDescriptor.alts
        };
      });
      return currErrors;
    }
    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
          return { idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
      }, []);
      var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        if (alternativeGast.ignoreAmbiguities === true) {
          return [];
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
          return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
            // will be be detected using a different validation.
            (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
          );
        });
        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
          var occurrence = alternation.idx === 0 ? "" : alternation.idx;
          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbPathAndIdx.path
          });
          return {
            message,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
            ruleName: rule.name,
            occurrence,
            alternatives: ambgIndices
          };
        });
        return currPathPrefixErrors;
      }));
      return errors;
    }
    exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
      var errors = [];
      var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
        return currToken.name;
      });
      (0, forEach_1.default)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, includes_1.default)(tokenNames, currRuleName)) {
          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: currRuleName
          });
        }
      });
      return errors;
    }
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
var require_gast_resolver_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateGrammar = exports2.resolveGrammar = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var defaults_1 = __importDefault(require_defaults());
    var resolver_1 = require_resolver();
    var checks_1 = require_checks();
    var errors_public_1 = require_errors_public();
    function resolveGrammar(options) {
      var actualOptions = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
      });
      var topRulesTable = {};
      (0, forEach_1.default)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
      });
      return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
    }
    exports2.resolveGrammar = resolveGrammar;
    function validateGrammar(options) {
      options = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
      });
      return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
    }
    exports2.validateGrammar = validateGrammar;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js
var require_exceptions_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
    var includes_1 = __importDefault(require_includes());
    var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    var EARLY_EXIT_EXCEPTION = "EarlyExitException";
    var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    var RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    function isRecognitionException2(error) {
      return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
    }
    exports2.isRecognitionException = isRecognitionException2;
    var RecognitionException = (
      /** @class */
      function(_super) {
        __extends(RecognitionException2, _super);
        function RecognitionException2(message, token) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.token = token;
          _this.resyncedTokens = [];
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
          }
          return _this;
        }
        return RecognitionException2;
      }(Error)
    );
    var MismatchedTokenException2 = (
      /** @class */
      function(_super) {
        __extends(MismatchedTokenException3, _super);
        function MismatchedTokenException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = MISMATCHED_TOKEN_EXCEPTION;
          return _this;
        }
        return MismatchedTokenException3;
      }(RecognitionException)
    );
    exports2.MismatchedTokenException = MismatchedTokenException2;
    var NoViableAltException2 = (
      /** @class */
      function(_super) {
        __extends(NoViableAltException3, _super);
        function NoViableAltException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = NO_VIABLE_ALT_EXCEPTION;
          return _this;
        }
        return NoViableAltException3;
      }(RecognitionException)
    );
    exports2.NoViableAltException = NoViableAltException2;
    var NotAllInputParsedException2 = (
      /** @class */
      function(_super) {
        __extends(NotAllInputParsedException3, _super);
        function NotAllInputParsedException3(message, token) {
          var _this = _super.call(this, message, token) || this;
          _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
          return _this;
        }
        return NotAllInputParsedException3;
      }(RecognitionException)
    );
    exports2.NotAllInputParsedException = NotAllInputParsedException2;
    var EarlyExitException2 = (
      /** @class */
      function(_super) {
        __extends(EarlyExitException3, _super);
        function EarlyExitException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = EARLY_EXIT_EXCEPTION;
          return _this;
        }
        return EarlyExitException3;
      }(RecognitionException)
    );
    exports2.EarlyExitException = EarlyExitException2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
var require_recoverable = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
    var tokens_public_1 = require_tokens_public();
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var flatten_1 = __importDefault(require_flatten());
    var map_1 = __importDefault(require_map2());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    var exceptions_public_1 = require_exceptions_public();
    var constants_1 = require_constants();
    var parser_1 = require_parser2();
    exports2.EOF_FOLLOW_KEY = {};
    exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    var InRuleRecoveryException = (
      /** @class */
      function(_super) {
        __extends(InRuleRecoveryException2, _super);
        function InRuleRecoveryException2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
          return _this;
        }
        return InRuleRecoveryException2;
      }(Error)
    );
    exports2.InRuleRecoveryException = InRuleRecoveryException;
    var Recoverable = (
      /** @class */
      function() {
        function Recoverable2() {
        }
        Recoverable2.prototype.initRecoverable = function(config) {
          this.firstAfterRepMap = {};
          this.resyncFollows = {};
          this.recoveryEnabled = (0, has_1.default)(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
          if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
          }
        };
        Recoverable2.prototype.getTokenToInsert = function(tokType) {
          var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
          tokToInsert.isInsertedInRecovery = true;
          return tokToInsert;
        };
        Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
          var _this = this;
          var reSyncTokType = this.findReSyncTokenType();
          var savedLexerState = this.exportLexerState();
          var resyncedTokens = [];
          var passedResyncPoint = false;
          var nextTokenWithoutResync = this.LA(1);
          var currToken = this.LA(1);
          var generateErrorMessage = function() {
            var previousToken = _this.LA(0);
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
              expected: expectedTokType,
              actual: nextTokenWithoutResync,
              previous: previousToken,
              ruleName: _this.getCurrRuleFullName()
            });
            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
            _this.SAVE_ERROR(error);
          };
          while (!passedResyncPoint) {
            if (this.tokenMatcher(currToken, expectedTokType)) {
              generateErrorMessage();
              return;
            } else if (lookAheadFunc.call(this)) {
              generateErrorMessage();
              grammarRule.apply(this, grammarRuleArgs);
              return;
            } else if (this.tokenMatcher(currToken, reSyncTokType)) {
              passedResyncPoint = true;
            } else {
              currToken = this.SKIP_TOKEN();
              this.addToResyncTokens(currToken, resyncedTokens);
            }
          }
          this.importLexerState(savedLexerState);
        };
        Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
          if (notStuck === false) {
            return false;
          }
          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
          }
          if (this.isBackTracking()) {
            return false;
          }
          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
          }
          return true;
        };
        Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
          var follows = this.getNextPossibleTokenTypes(grammarPath);
          return follows;
        };
        Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
          }
          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
          }
          throw new InRuleRecoveryException("sad sad panda");
        };
        Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
        };
        Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
          var _this = this;
          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
          }
          if ((0, isEmpty_1.default)(follows)) {
            return false;
          }
          var mismatchedTok = this.LA(1);
          var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
          }) !== void 0;
          return isMisMatchedTokInFollows;
        };
        Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
            return false;
          }
          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
          return isNextTokenWhatIsExpected;
        };
        Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
          var followKey = this.getCurrFollowKey();
          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
          return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
        };
        Recoverable2.prototype.findReSyncTokenType = function() {
          var allPossibleReSyncTokTypes = this.flattenFollowSet();
          var nextToken = this.LA(1);
          var k = 2;
          while (true) {
            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
              var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
              return canMatch;
            });
            if (foundMatch !== void 0) {
              return foundMatch;
            }
            nextToken = this.LA(k);
            k++;
          }
        };
        Recoverable2.prototype.getCurrFollowKey = function() {
          if (this.RULE_STACK.length === 1) {
            return exports2.EOF_FOLLOW_KEY;
          }
          var currRuleShortName = this.getLastExplicitRuleShortName();
          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
          var prevRuleShortName = this.getPreviousExplicitRuleShortName();
          return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
          };
        };
        Recoverable2.prototype.buildFullFollowKeyStack = function() {
          var _this = this;
          var explicitRuleStack = this.RULE_STACK;
          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
          return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
            if (idx === 0) {
              return exports2.EOF_FOLLOW_KEY;
            }
            return {
              ruleName: _this.shortRuleNameToFullName(ruleName),
              idxInCallingRule: explicitOccurrenceStack[idx],
              inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
          });
        };
        Recoverable2.prototype.flattenFollowSet = function() {
          var _this = this;
          var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
          });
          return (0, flatten_1.default)(followStack);
        };
        Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
          if (followKey === exports2.EOF_FOLLOW_KEY) {
            return [tokens_public_1.EOF];
          }
          var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
          return this.resyncFollows[followName];
        };
        Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
          if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
            resyncTokens.push(token);
          }
          return resyncTokens;
        };
        Recoverable2.prototype.reSyncTo = function(tokType) {
          var resyncedTokens = [];
          var nextTok = this.LA(1);
          while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
          }
          return (0, dropRight_1.default)(resyncedTokens);
        };
        Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        };
        Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
          var pathRuleStack = this.getHumanReadableRuleStack();
          var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
          var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
          };
          return grammarPath;
        };
        Recoverable2.prototype.getHumanReadableRuleStack = function() {
          var _this = this;
          return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
            return _this.shortRuleNameToFullName(currShortName);
          });
        };
        return Recoverable2;
      }()
    );
    exports2.Recoverable = Recoverable;
    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
      var firstAfterRepInfo = this.firstAfterRepMap[key];
      if (firstAfterRepInfo === void 0) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
      }
      var expectTokAfterLastMatch = firstAfterRepInfo.token;
      var nextTokIdx = firstAfterRepInfo.occurrence;
      var isEndOfRule = firstAfterRepInfo.isEndOfRule;
      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
        expectTokAfterLastMatch = tokens_public_1.EOF;
        nextTokIdx = 1;
      }
      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
        return;
      }
      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
      }
    }
    exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js
var require_keys2 = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
    exports2.BITS_FOR_METHOD_TYPE = 4;
    exports2.BITS_FOR_OCCURRENCE_IDX = 8;
    exports2.BITS_FOR_RULE_IDX = 12;
    exports2.BITS_FOR_ALT_IDX = 8;
    exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
    function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
      return occurrence | dslMethodIdx | ruleIdx;
    }
    exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
    var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
var require_llk_lookahead = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLkLookaheadStrategy = void 0;
    var flatMap_1 = __importDefault(require_flatMap());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var errors_public_1 = require_errors_public();
    var parser_1 = require_parser2();
    var checks_1 = require_checks();
    var lookahead_1 = require_lookahead();
    var LLkLookaheadStrategy2 = (
      /** @class */
      function() {
        function LLkLookaheadStrategy3(options) {
          var _a;
          this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
        }
        LLkLookaheadStrategy3.prototype.validate = function(options) {
          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
          if ((0, isEmpty_1.default)(leftRecursionErrors)) {
            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
            return allErrors;
          }
          return leftRecursionErrors;
        };
        LLkLookaheadStrategy3.prototype.validateNoLeftRecursion = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateEmptyOrAlternatives = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
          return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForAlternation = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForOptional = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
        };
        return LLkLookaheadStrategy3;
      }()
    );
    exports2.LLkLookaheadStrategy = LLkLookaheadStrategy2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
var require_looksahead = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectMethods = exports2.LooksAhead = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var parser_1 = require_parser2();
    var keys_1 = require_keys2();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var llk_lookahead_1 = require_llk_lookahead();
    var LooksAhead = (
      /** @class */
      function() {
        function LooksAhead2() {
        }
        LooksAhead2.prototype.initLooksAhead = function(config) {
          this.dynamicTokensEnabled = (0, has_1.default)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
          this.maxLookahead = (0, has_1.default)(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          this.lookaheadStrategy = (0, has_1.default)(config, "lookaheadStrategy") ? config.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
          this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
        };
        LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
          var _this = this;
          (0, forEach_1.default)(rules, function(currRule) {
            _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
              var _a = collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
              (0, forEach_1.default)(alternation, function(currProd) {
                var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                  var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                    prodOccurrence: currProd.idx,
                    rule: currRule,
                    maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                    hasPredicates: currProd.hasPredicates,
                    dynamicTokensEnabled: _this.dynamicTokensEnabled
                  });
                  var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                  _this.setLaFuncCache(key, laFunc);
                });
              });
              (0, forEach_1.default)(repetition, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(option, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
            });
          });
        };
        LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
          var _this = this;
          this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
            var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
              prodOccurrence,
              rule,
              maxLookahead: prodMaxLookahead || _this.maxLookahead,
              dynamicTokensEnabled: _this.dynamicTokensEnabled,
              prodType
            });
            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
          });
        };
        LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
          var currRuleShortName = this.getLastExplicitRuleShortName();
          return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
        };
        LooksAhead2.prototype.getLaFuncFromCache = function(key) {
          return this.lookAheadFuncsCache.get(key);
        };
        LooksAhead2.prototype.setLaFuncCache = function(key, value) {
          this.lookAheadFuncsCache.set(key, value);
        };
        return LooksAhead2;
      }()
    );
    exports2.LooksAhead = LooksAhead;
    var DslMethodsCollectorVisitor = (
      /** @class */
      function(_super) {
        __extends(DslMethodsCollectorVisitor2, _super);
        function DslMethodsCollectorVisitor2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
          return _this;
        }
        DslMethodsCollectorVisitor2.prototype.reset = function() {
          this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
        };
        DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
          this.dslMethods.option.push(option);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.dslMethods.repetitionWithSeparator.push(manySep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.dslMethods.repetitionMandatory.push(atLeastOne);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
          this.dslMethods.repetition.push(many);
        };
        DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
          this.dslMethods.alternation.push(or);
        };
        return DslMethodsCollectorVisitor2;
      }(gast_1.GAstVisitor)
    );
    var collectorVisitor = new DslMethodsCollectorVisitor();
    function collectMethods(rule) {
      collectorVisitor.reset();
      rule.accept(collectorVisitor);
      var dslMethods = collectorVisitor.dslMethods;
      collectorVisitor.reset();
      return dslMethods;
    }
    exports2.collectMethods = collectMethods;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js
var require_cst2 = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      }
    }
    exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
    function setNodeLocationFull(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      }
    }
    exports2.setNodeLocationFull = setNodeLocationFull;
    function addTerminalToCst(node, token, tokenTypeName) {
      if (node.children[tokenTypeName] === void 0) {
        node.children[tokenTypeName] = [token];
      } else {
        node.children[tokenTypeName].push(token);
      }
    }
    exports2.addTerminalToCst = addTerminalToCst;
    function addNoneTerminalToCst(node, ruleName, ruleResult) {
      if (node.children[ruleName] === void 0) {
        node.children[ruleName] = [ruleResult];
      } else {
        node.children[ruleName].push(ruleResult);
      }
    }
    exports2.addNoneTerminalToCst = addNoneTerminalToCst;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js
var require_lang_extensions = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineNameProp = void 0;
    var NAME = "name";
    function defineNameProp(obj, nameValue) {
      Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue
      });
    }
    exports2.defineNameProp = defineNameProp;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
var require_cst_visitor = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var filter_1 = __importDefault(require_filter());
    var keys_1 = __importDefault(require_keys());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lang_extensions_1 = require_lang_extensions();
    function defaultVisit(ctx, param) {
      var childrenNames = (0, keys_1.default)(ctx);
      var childrenNamesLength = childrenNames.length;
      for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
          var currChild = currChildArray[j];
          if (currChild.tokenTypeIdx === void 0) {
            this[currChild.name](currChild.children, param);
          }
        }
      }
    }
    exports2.defaultVisit = defaultVisit;
    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
      var semanticProto = {
        visit: function(cstNode, param) {
          if ((0, isArray_1.default)(cstNode)) {
            cstNode = cstNode[0];
          }
          if ((0, isUndefined_1.default)(cstNode)) {
            return void 0;
          }
          return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
          var semanticDefinitionErrors = validateVisitor(this, ruleNames);
          if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
            var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
              return currDefError.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
          }
        }
      };
      derivedConstructor.prototype = semanticProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      derivedConstructor._RULE_NAMES = ruleNames;
      return derivedConstructor;
    }
    exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
      var withDefaultsProto = Object.create(baseConstructor.prototype);
      (0, forEach_1.default)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
      });
      derivedConstructor.prototype = withDefaultsProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      return derivedConstructor;
    }
    exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
    var CstVisitorDefinitionError;
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
    function validateVisitor(visitorInstance, ruleNames) {
      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
      return missingErrors;
    }
    exports2.validateVisitor = validateVisitor;
    function validateMissingCstMethods(visitorInstance, ruleNames) {
      var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
      });
      var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
        return {
          msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
          type: CstVisitorDefinitionError.MISSING_METHOD,
          methodName: currRuleName
        };
      });
      return (0, compact_1.default)(errors);
    }
    exports2.validateMissingCstMethods = validateMissingCstMethods;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var require_tree_builder = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeBuilder = void 0;
    var cst_1 = require_cst2();
    var noop_1 = __importDefault(require_noop());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var cst_visitor_1 = require_cst_visitor();
    var parser_1 = require_parser2();
    var TreeBuilder = (
      /** @class */
      function() {
        function TreeBuilder2() {
        }
        TreeBuilder2.prototype.initTreeBuilder = function(config) {
          this.CST_STACK = [];
          this.outputCst = config.outputCst;
          this.nodeLocationTracking = (0, has_1.default)(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
          if (!this.outputCst) {
            this.cstInvocationStateUpdate = noop_1.default;
            this.cstFinallyStateUpdate = noop_1.default;
            this.cstPostTerminal = noop_1.default;
            this.cstPostNonTerminal = noop_1.default;
            this.cstPostRule = noop_1.default;
          } else {
            if (/full/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleFull;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
              }
            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleOnlyOffset;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
              }
            } else if (/none/i.test(this.nodeLocationTracking)) {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = noop_1.default;
            } else {
              throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config.nodeLocationTracking, '"'));
            }
          }
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
          cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
          var nextToken = this.LA(1);
          cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
          var cstNode = {
            name: fullRuleName,
            children: /* @__PURE__ */ Object.create(null)
          };
          this.setInitialNodeLocation(cstNode);
          this.CST_STACK.push(cstNode);
        };
        TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
          this.CST_STACK.pop();
        };
        TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
          } else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
          } else {
            loc.startOffset = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
          this.setNodeLocationFromToken(rootCst.location, consumedToken);
        };
        TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
          }
          return this.baseCstVisitorConstructor;
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        };
        TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 1];
        };
        TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 2];
        };
        TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
          var occurrenceStack = this.RULE_OCCURRENCE_STACK;
          return occurrenceStack[occurrenceStack.length - 1];
        };
        return TreeBuilder2;
      }()
    );
    exports2.TreeBuilder = TreeBuilder;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var require_lexer_adapter = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerAdapter = void 0;
    var parser_1 = require_parser2();
    var LexerAdapter = (
      /** @class */
      function() {
        function LexerAdapter2() {
        }
        LexerAdapter2.prototype.initLexerAdapter = function() {
          this.tokVector = [];
          this.tokVectorLength = 0;
          this.currIdx = -1;
        };
        Object.defineProperty(LexerAdapter2.prototype, "input", {
          get: function() {
            return this.tokVector;
          },
          set: function(newInput) {
            if (this.selfAnalysisDone !== true) {
              throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
          },
          enumerable: false,
          configurable: true
        });
        LexerAdapter2.prototype.SKIP_TOKEN = function() {
          if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
          } else {
            return parser_1.END_OF_FILE;
          }
        };
        LexerAdapter2.prototype.LA = function(howMuch) {
          var soughtIdx = this.currIdx + howMuch;
          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return parser_1.END_OF_FILE;
          } else {
            return this.tokVector[soughtIdx];
          }
        };
        LexerAdapter2.prototype.consumeToken = function() {
          this.currIdx++;
        };
        LexerAdapter2.prototype.exportLexerState = function() {
          return this.currIdx;
        };
        LexerAdapter2.prototype.importLexerState = function(newState) {
          this.currIdx = newState;
        };
        LexerAdapter2.prototype.resetLexerState = function() {
          this.currIdx = -1;
        };
        LexerAdapter2.prototype.moveToTerminatedState = function() {
          this.currIdx = this.tokVector.length - 1;
        };
        LexerAdapter2.prototype.getLexerPosition = function() {
          return this.exportLexerState();
        };
        return LexerAdapter2;
      }()
    );
    exports2.LexerAdapter = LexerAdapter;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var require_recognizer_api = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerApi = void 0;
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var exceptions_public_1 = require_exceptions_public();
    var parser_1 = require_parser2();
    var errors_public_1 = require_errors_public();
    var checks_1 = require_checks();
    var gast_1 = require_api2();
    var RecognizerApi = (
      /** @class */
      function() {
        function RecognizerApi2() {
        }
        RecognizerApi2.prototype.ACTION = function(impl) {
          return impl.call(this);
        };
        RecognizerApi2.prototype.consume = function(idx, tokType, options) {
          return this.consumeInternal(tokType, idx, options);
        };
        RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
          return this.subruleInternal(ruleToCall, idx, options);
        };
        RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, idx);
        };
        RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
          return this.orInternal(altsOrOpts, idx);
        };
        RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
          return this.manyInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
          return this.atLeastOneInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.CONSUME = function(tokType, options) {
          return this.consumeInternal(tokType, 0, options);
        };
        RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
          return this.consumeInternal(tokType, 1, options);
        };
        RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
          return this.consumeInternal(tokType, 2, options);
        };
        RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
          return this.consumeInternal(tokType, 3, options);
        };
        RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
          return this.consumeInternal(tokType, 4, options);
        };
        RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
          return this.consumeInternal(tokType, 5, options);
        };
        RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
          return this.consumeInternal(tokType, 6, options);
        };
        RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
          return this.consumeInternal(tokType, 7, options);
        };
        RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
          return this.consumeInternal(tokType, 8, options);
        };
        RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
          return this.consumeInternal(tokType, 9, options);
        };
        RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 0, options);
        };
        RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 1, options);
        };
        RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 2, options);
        };
        RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 3, options);
        };
        RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 4, options);
        };
        RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 5, options);
        };
        RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 6, options);
        };
        RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 7, options);
        };
        RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 8, options);
        };
        RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 9, options);
        };
        RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 0);
        };
        RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 1);
        };
        RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 2);
        };
        RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 3);
        };
        RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 4);
        };
        RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 5);
        };
        RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 6);
        };
        RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 7);
        };
        RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 8);
        };
        RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 9);
        };
        RecognizerApi2.prototype.OR = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 0);
        };
        RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 1);
        };
        RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 2);
        };
        RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 3);
        };
        RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 4);
        };
        RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 5);
        };
        RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 6);
        };
        RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 7);
        };
        RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 8);
        };
        RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 9);
        };
        RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
          this.manyInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
          this.manyInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
          this.manyInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
          this.manyInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
          this.manyInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
          this.manyInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
          this.manyInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
          this.manyInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
          this.manyInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
          this.manyInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY_SEP = function(options) {
          this.manySepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.MANY_SEP1 = function(options) {
          this.manySepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.MANY_SEP2 = function(options) {
          this.manySepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.MANY_SEP3 = function(options) {
          this.manySepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.MANY_SEP4 = function(options) {
          this.manySepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.MANY_SEP5 = function(options) {
          this.manySepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.MANY_SEP6 = function(options) {
          this.manySepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.MANY_SEP7 = function(options) {
          this.manySepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.MANY_SEP8 = function(options) {
          this.manySepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.MANY_SEP9 = function(options) {
          this.manySepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
          this.atLeastOneInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
          return this.atLeastOneInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
          this.atLeastOneInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
          this.atLeastOneInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
          this.atLeastOneInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
          this.atLeastOneInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
          this.atLeastOneInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
          this.atLeastOneInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
          this.atLeastOneInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
          this.atLeastOneInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
          this.atLeastOneSepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
          this.atLeastOneSepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
          this.atLeastOneSepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
          this.atLeastOneSepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
          this.atLeastOneSepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
          this.atLeastOneSepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
          this.atLeastOneSepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
          this.atLeastOneSepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
          this.atLeastOneSepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
          this.atLeastOneSepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.RULE = function(name, implementation, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          if ((0, includes_1.default)(this.definedRulesNames, name)) {
            var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
              topLevelRule: name,
              grammarName: this.className
            });
            var error = {
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
              ruleName: name
            };
            this.definitionErrors.push(error);
          }
          this.definedRulesNames.push(name);
          var ruleImplementation = this.defineRule(name, implementation, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(ruleErrors);
          var ruleImplementation = this.defineRule(name, impl, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
          return function() {
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
              grammarRule.apply(this, args);
              return true;
            } catch (e) {
              if ((0, exceptions_public_1.isRecognitionException)(e)) {
                return false;
              } else {
                throw e;
              }
            } finally {
              this.reloadRecogState(orgState);
              this.isBackTrackingStack.pop();
            }
          };
        };
        RecognizerApi2.prototype.getGAstProductions = function() {
          return this.gastProductionsCache;
        };
        RecognizerApi2.prototype.getSerializedGastProductions = function() {
          return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
        };
        return RecognizerApi2;
      }()
    );
    exports2.RecognizerApi = RecognizerApi;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var require_recognizer_engine = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerEngine = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var uniq_1 = __importDefault(require_uniq());
    var isObject_1 = __importDefault(require_isObject());
    var has_1 = __importDefault(require_has());
    var values_1 = __importDefault(require_values());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var keys_1 = require_keys2();
    var exceptions_public_1 = require_exceptions_public();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var parser_1 = require_parser2();
    var recoverable_1 = require_recoverable();
    var tokens_public_1 = require_tokens_public();
    var tokens_1 = require_tokens();
    var RecognizerEngine = (
      /** @class */
      function() {
        function RecognizerEngine2() {
        }
        RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
          this.className = this.constructor.name;
          this.shortRuleNameToFull = {};
          this.fullRuleNameToShort = {};
          this.ruleShortNameIdx = 256;
          this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
          this.subruleIdx = 0;
          this.definedRulesNames = [];
          this.tokensMap = {};
          this.isBackTrackingStack = [];
          this.RULE_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
          this.gastProductionsCache = {};
          if ((0, has_1.default)(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            if ((0, isEmpty_1.default)(tokenVocabulary)) {
              throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
              throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
            }
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, isObject_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, clone_1.default)(tokenVocabulary);
          } else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
          }
          this.tokensMap["EOF"] = tokens_public_1.EOF;
          var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
          var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
          });
          this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
          (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
        };
        RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
          if (this.selfAnalysisDone) {
            throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
          }
          var resyncEnabled = (0, has_1.default)(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
          var recoveryValueFunc = (0, has_1.default)(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
          var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
          this.ruleShortNameIdx++;
          this.shortRuleNameToFull[shortName] = ruleName;
          this.fullRuleNameToShort[ruleName] = shortName;
          var invokeRuleWithTry;
          if (this.outputCst === true) {
            invokeRuleWithTry = function invokeRuleWithTry2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                impl.apply(this, args);
                var cst = this.CST_STACK[this.CST_STACK.length - 1];
                this.cstPostRule(cst);
                return cst;
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          } else {
            invokeRuleWithTry = function invokeRuleWithTryCst() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                return impl.apply(this, args);
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          }
          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
          return wrappedGrammarRule;
        };
        RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
          var isFirstInvokedRule = this.RULE_STACK.length === 1;
          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
          if ((0, exceptions_public_1.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
              var reSyncTokType = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  return partialCstResult;
                } else {
                  return recoveryValueFunc(e);
                }
              } else {
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  recogError.partialCstResult = partialCstResult;
                }
                throw recogError;
              }
            } else if (isFirstInvokedRule) {
              this.moveToTerminatedState();
              return recoveryValueFunc(e);
            } else {
              throw recogError;
            }
          } else {
            throw e;
          }
        };
        RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
          var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
          return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        };
        RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_1 = actionORMethodDef.GATE;
            if (predicate_1 !== void 0) {
              var orgLookaheadFunction_1 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            return action.call(this);
          }
          return void 0;
        };
        RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_2 = actionORMethodDef.GATE;
            if (predicate_2 !== void 0) {
              var orgLookaheadFunction_2 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
          }
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
          if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
          }
        };
        RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookaheadFunction = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_3 = actionORMethodDef.GATE;
            if (predicate_3 !== void 0) {
              var orgLookaheadFunction_3 = lookaheadFunction;
              lookaheadFunction = function() {
                return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          var notStuck = true;
          while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
          this.attemptInRepetitionRecovery(
            this.manyInternal,
            [prodOccurrence, actionORMethodDef],
            lookaheadFunction,
            keys_1.MANY_IDX,
            prodOccurrence,
            interpreter_1.NextTerminalAfterManyWalker,
            // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
            // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
            // An infinite loop cannot occur as:
            // - Either the lookahead is guaranteed to consume something (Single Token Separator)
            // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
            notStuck
          );
        };
        RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLaFunc = this.getLaFuncFromCache(key);
          if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
          }
        };
        RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
          while (separatorLookAheadFunc()) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
          ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
        };
        RecognizerEngine2.prototype.doSingleRepetition = function(action) {
          var beforeIteration = this.getLexerPosition();
          action.call(this);
          var afterIteration = this.getLexerPosition();
          return afterIteration > beforeIteration;
        };
        RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
          var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
          var laFunc = this.getLaFuncFromCache(laKey);
          var altIdxToTake = laFunc.call(this, alts);
          if (altIdxToTake !== void 0) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
          }
          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        };
        RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
          this.RULE_STACK.pop();
          this.RULE_OCCURRENCE_STACK.pop();
          this.cstFinallyStateUpdate();
          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
              firstRedundant: firstRedundantTok,
              ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
          }
        };
        RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
          var ruleResult;
          try {
            var args = options !== void 0 ? options.ARGS : void 0;
            this.subruleIdx = idx;
            ruleResult = ruleToCall.apply(this, args);
            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
            return ruleResult;
          } catch (e) {
            throw this.subruleInternalError(e, options, ruleToCall.ruleName);
          }
        };
        RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
          if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
            delete e.partialCstResult;
          }
          throw e;
        };
        RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
          var consumedToken;
          try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
              this.consumeToken();
              consumedToken = nextToken;
            } else {
              this.consumeInternalError(tokType, nextToken, options);
            }
          } catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
          }
          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
          return consumedToken;
        };
        RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
          var msg;
          var previousToken = this.LA(0);
          if (options !== void 0 && options.ERR_MSG) {
            msg = options.ERR_MSG;
          } else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
              expected: tokType,
              actual: nextToken,
              previous: previousToken,
              ruleName: this.getCurrRuleFullName()
            });
          }
          throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
        };
        RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
          if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
          eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
              return this.tryInRuleRecovery(tokType, follows);
            } catch (eFromInRuleRecovery) {
              if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                throw eFromConsumption;
              } else {
                throw eFromInRuleRecovery;
              }
            }
          } else {
            throw eFromConsumption;
          }
        };
        RecognizerEngine2.prototype.saveRecogState = function() {
          var savedErrors = this.errors;
          var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
          return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK
          };
        };
        RecognizerEngine2.prototype.reloadRecogState = function(newState) {
          this.errors = newState.errors;
          this.importLexerState(newState.lexerState);
          this.RULE_STACK = newState.RULE_STACK;
        };
        RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
          this.RULE_STACK.push(shortName);
          this.cstInvocationStateUpdate(fullName);
        };
        RecognizerEngine2.prototype.isBackTracking = function() {
          return this.isBackTrackingStack.length !== 0;
        };
        RecognizerEngine2.prototype.getCurrRuleFullName = function() {
          var shortName = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.isAtEndOfInput = function() {
          return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
        };
        RecognizerEngine2.prototype.reset = function() {
          this.resetLexerState();
          this.subruleIdx = 0;
          this.isBackTrackingStack = [];
          this.errors = [];
          this.RULE_STACK = [];
          this.CST_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
        };
        return RecognizerEngine2;
      }()
    );
    exports2.RecognizerEngine = RecognizerEngine;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var require_error_handler = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorHandler = void 0;
    var exceptions_public_1 = require_exceptions_public();
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var lookahead_1 = require_lookahead();
    var parser_1 = require_parser2();
    var ErrorHandler = (
      /** @class */
      function() {
        function ErrorHandler2() {
        }
        ErrorHandler2.prototype.initErrorHandler = function(config) {
          this._errors = [];
          this.errorMessageProvider = (0, has_1.default)(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
        };
        ErrorHandler2.prototype.SAVE_ERROR = function(error) {
          if ((0, exceptions_public_1.isRecognitionException)(error)) {
            error.context = {
              ruleStack: this.getHumanReadableRuleStack(),
              ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
          } else {
            throw Error("Trying to save an Error which is not a RecognitionException");
          }
        };
        Object.defineProperty(ErrorHandler2.prototype, "errors", {
          get: function() {
            return (0, clone_1.default)(this._errors);
          },
          set: function(newErrors) {
            this._errors = newErrors;
          },
          enumerable: false,
          configurable: true
        });
        ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
          var insideProdPaths = lookAheadPathsPerAlternative[0];
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName
          });
          throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
        };
        ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var previousToken = this.LA(0);
          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
          });
          throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
        };
        return ErrorHandler2;
      }()
    );
    exports2.ErrorHandler = ErrorHandler;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var require_context_assist = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentAssist = void 0;
    var interpreter_1 = require_interpreter();
    var first_1 = __importDefault(require_first2());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var ContentAssist = (
      /** @class */
      function() {
        function ContentAssist2() {
        }
        ContentAssist2.prototype.initContentAssist = function() {
        };
        ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
          var startRuleGast = this.gastProductionsCache[startRuleName];
          if ((0, isUndefined_1.default)(startRuleGast)) {
            throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
          }
          return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
        };
        ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
          var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
          var gastProductions = this.getGAstProductions();
          var topProduction = gastProductions[topRuleName];
          var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
          return nextPossibleTokenTypes;
        };
        return ContentAssist2;
      }()
    );
    exports2.ContentAssist = ContentAssist;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
var require_gast_recorder = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRecorder = void 0;
    var last_1 = __importDefault(require_last());
    var isArray_1 = __importDefault(require_isArray());
    var some_1 = __importDefault(require_some());
    var forEach_1 = __importDefault(require_forEach());
    var isFunction_1 = __importDefault(require_isFunction());
    var has_1 = __importDefault(require_has());
    var gast_1 = require_api2();
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    var tokens_public_1 = require_tokens_public();
    var parser_1 = require_parser2();
    var keys_1 = require_keys2();
    var RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    var HANDLE_SEPARATOR = true;
    var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
    var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([RFT]);
    var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
      // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    var RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    var GastRecorder = (
      /** @class */
      function() {
        function GastRecorder2() {
        }
        GastRecorder2.prototype.initGastRecorder = function(config) {
          this.recordingProdStack = [];
          this.RECORDING_PHASE = false;
        };
        GastRecorder2.prototype.enableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = true;
          this.TRACE_INIT("Enable Recording", function() {
            var _loop_1 = function(i2) {
              var idx = i2 > 0 ? i2 : "";
              _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                return this.consumeInternalRecord(arg1, i2, arg2);
              };
              _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                return this.subruleInternalRecord(arg1, i2, arg2);
              };
              _this["OPTION".concat(idx)] = function(arg1) {
                return this.optionInternalRecord(arg1, i2);
              };
              _this["OR".concat(idx)] = function(arg1) {
                return this.orInternalRecord(arg1, i2);
              };
              _this["MANY".concat(idx)] = function(arg1) {
                this.manyInternalRecord(i2, arg1);
              };
              _this["MANY_SEP".concat(idx)] = function(arg1) {
                this.manySepFirstInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                this.atLeastOneInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                this.atLeastOneSepFirstInternalRecord(i2, arg1);
              };
            };
            for (var i = 0; i < 10; i++) {
              _loop_1(i);
            }
            _this["consume"] = function(idx, arg1, arg2) {
              return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function(idx, arg1, arg2) {
              return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function(idx, arg1) {
              return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function(idx, arg1) {
              return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function(idx, arg1) {
              this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function(idx, arg1) {
              this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
          });
        };
        GastRecorder2.prototype.disableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = false;
          this.TRACE_INIT("Deleting Recording methods", function() {
            var that = _this;
            for (var i = 0; i < 10; i++) {
              var idx = i > 0 ? i : "";
              delete that["CONSUME".concat(idx)];
              delete that["SUBRULE".concat(idx)];
              delete that["OPTION".concat(idx)];
              delete that["OR".concat(idx)];
              delete that["MANY".concat(idx)];
              delete that["MANY_SEP".concat(idx)];
              delete that["AT_LEAST_ONE".concat(idx)];
              delete that["AT_LEAST_ONE_SEP".concat(idx)];
            }
            delete that["consume"];
            delete that["subrule"];
            delete that["option"];
            delete that["or"];
            delete that["many"];
            delete that["atLeastOne"];
            delete that.ACTION;
            delete that.BACKTRACK;
            delete that.LA;
          });
        };
        GastRecorder2.prototype.ACTION_RECORD = function(impl) {
        };
        GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
          return function() {
            return true;
          };
        };
        GastRecorder2.prototype.LA_RECORD = function(howMuch) {
          return parser_1.END_OF_FILE;
        };
        GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
          try {
            var newTopLevelRule = new gast_1.Rule({ definition: [], name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
          } catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
              try {
                originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
              } catch (mutabilityError) {
                throw originalError;
              }
            }
            throw originalError;
          }
        };
        GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
          return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
          return recordOrProd.call(this, altsOrOpts, occurrence);
        };
        GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var ruleName = ruleToCall.ruleName;
          var newNoneTerminal = new gast_1.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: void 0
          });
          prevProd.definition.push(newNoneTerminal);
          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
        };
        GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var newNoneTerminal = new gast_1.Terminal({
            idx: occurrence,
            terminalType: tokType,
            label: options === null || options === void 0 ? void 0 : options.LABEL
          });
          prevProd.definition.push(newNoneTerminal);
          return RECORDING_PHASE_TOKEN;
        };
        return GastRecorder2;
      }()
    );
    exports2.GastRecorder = GastRecorder;
    function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
      if (handleSep === void 0) {
        handleSep = false;
      }
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
      var newProd = new prodConstructor({ definition: [], idx: occurrence });
      if (handleSep) {
        newProd.separator = mainProdArg.SEP;
      }
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      this.recordingProdStack.push(newProd);
      grammarAction.call(this);
      prevProd.definition.push(newProd);
      this.recordingProdStack.pop();
      return RECORDING_NULL_OBJECT;
    }
    function recordOrProd(mainProdArg, occurrence) {
      var _this = this;
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
      var newOrProd = new gast_1.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
      });
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
        return (0, isFunction_1.default)(currAlt.GATE);
      });
      newOrProd.hasPredicates = hasPredicates;
      prevProd.definition.push(newOrProd);
      (0, forEach_1.default)(alts, function(currAlt) {
        var currAltFlat = new gast_1.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        } else if ((0, has_1.default)(currAlt, "GATE")) {
          currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
      });
      return RECORDING_NULL_OBJECT;
    }
    function getIdxSuffix(idx) {
      return idx === 0 ? "" : "".concat(idx);
    }
    function assertMethodIdxIsValid(idx) {
      if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
          // The stack trace will contain all the needed details
          "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
        );
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
    }
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var require_perf_tracer = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceTracer = void 0;
    var has_1 = __importDefault(require_has());
    var utils_1 = require_api();
    var parser_1 = require_parser2();
    var PerformanceTracer = (
      /** @class */
      function() {
        function PerformanceTracer2() {
        }
        PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
          if ((0, has_1.default)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
          } else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
          }
          this.traceInitIndent = -1;
        };
        PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent2 = new Array(this.traceInitIndent + 1).join("	");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              console.log("".concat(indent2, "--> <").concat(phaseDesc, ">"));
            }
            var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              traceMethod("".concat(indent2, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
            }
            this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        return PerformanceTracer2;
      }()
    );
    exports2.PerformanceTracer = PerformanceTracer;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
var require_apply_mixins = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyMixins = void 0;
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
          if (propName === "constructor") {
            return;
          }
          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
          } else {
            derivedCtor.prototype[propName] = baseCtor.prototype[propName];
          }
        });
      });
    }
    exports2.applyMixins = applyMixins;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js
var require_parser2 = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var map_1 = __importDefault(require_map2());
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var follow_1 = require_follow();
    var tokens_public_1 = require_tokens_public();
    var errors_public_1 = require_errors_public();
    var gast_resolver_public_1 = require_gast_resolver_public();
    var recoverable_1 = require_recoverable();
    var looksahead_1 = require_looksahead();
    var tree_builder_1 = require_tree_builder();
    var lexer_adapter_1 = require_lexer_adapter();
    var recognizer_api_1 = require_recognizer_api();
    var recognizer_engine_1 = require_recognizer_engine();
    var error_handler_1 = require_error_handler();
    var context_assist_1 = require_context_assist();
    var gast_recorder_1 = require_gast_recorder();
    var perf_tracer_1 = require_perf_tracer();
    var apply_mixins_1 = require_apply_mixins();
    var checks_1 = require_checks();
    exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(exports2.END_OF_FILE);
    exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: errors_public_1.defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    exports2.DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: function() {
        return void 0;
      },
      resyncEnabled: true
    });
    var ParserDefinitionErrorType2;
    (function(ParserDefinitionErrorType3) {
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
    })(ParserDefinitionErrorType2 = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
    function EMPTY_ALT2(value) {
      if (value === void 0) {
        value = void 0;
      }
      return function() {
        return value;
      };
    }
    exports2.EMPTY_ALT = EMPTY_ALT2;
    var Parser2 = (
      /** @class */
      function() {
        function Parser3(tokenVocabulary, config) {
          this.definitionErrors = [];
          this.selfAnalysisDone = false;
          var that = this;
          that.initErrorHandler(config);
          that.initLexerAdapter();
          that.initLooksAhead(config);
          that.initRecognizerEngine(tokenVocabulary, config);
          that.initRecoverable(config);
          that.initTreeBuilder(config);
          that.initContentAssist();
          that.initGastRecorder(config);
          that.initPerformanceTracer(config);
          if ((0, has_1.default)(config, "ignoredIssues")) {
            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
          }
          this.skipValidations = (0, has_1.default)(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
        }
        Parser3.performSelfAnalysis = function(parserInstance) {
          throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
        };
        Parser3.prototype.performSelfAnalysis = function() {
          var _this = this;
          this.TRACE_INIT("performSelfAnalysis", function() {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function() {
              (0, utils_1.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function() {
              try {
                _this.enableRecording();
                (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                  var wrappedRule = _this[currRuleName];
                  var originalGrammarAction = wrappedRule["originalGrammarAction"];
                  var recordedRuleGast;
                  _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                    recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                  });
                  _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                });
              } finally {
                _this.disableRecording();
              }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function() {
              resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                rules: (0, values_1.default)(_this.gastProductionsCache)
              });
              _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
            });
            _this.TRACE_INIT("Grammar Validations", function() {
              if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                  grammarName: className
                });
                var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                  lookaheadStrategy: _this.lookaheadStrategy,
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  grammarName: className
                });
                _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
              }
            });
            if ((0, isEmpty_1.default)(_this.definitionErrors)) {
              if (_this.recoveryEnabled) {
                _this.TRACE_INIT("computeAllProdsFollows", function() {
                  var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                  _this.resyncFollows = allFollows;
                });
              }
              _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                var _a, _b;
                (_b = (_a = _this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
              });
            }
            if (!Parser3.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
              defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                return defError.message;
              });
              throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
            }
          });
        };
        Parser3.DEFER_DEFINITION_ERRORS_HANDLING = false;
        return Parser3;
      }()
    );
    exports2.Parser = Parser2;
    (0, apply_mixins_1.applyMixins)(Parser2, [
      recoverable_1.Recoverable,
      looksahead_1.LooksAhead,
      tree_builder_1.TreeBuilder,
      lexer_adapter_1.LexerAdapter,
      recognizer_engine_1.RecognizerEngine,
      recognizer_api_1.RecognizerApi,
      error_handler_1.ErrorHandler,
      context_assist_1.ContentAssist,
      gast_recorder_1.GastRecorder,
      perf_tracer_1.PerformanceTracer
    ]);
    var CstParser2 = (
      /** @class */
      function(_super) {
        __extends(CstParser3, _super);
        function CstParser3(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = true;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return CstParser3;
      }(Parser2)
    );
    exports2.CstParser = CstParser2;
    var EmbeddedActionsParser2 = (
      /** @class */
      function(_super) {
        __extends(EmbeddedActionsParser3, _super);
        function EmbeddedActionsParser3(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = false;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return EmbeddedActionsParser3;
      }(Parser2)
    );
    exports2.EmbeddedActionsParser = EmbeddedActionsParser2;
  }
});

// ../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var require_model2 = __commonJS({
  "../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildModel = void 0;
    var gast_1 = require_api2();
    var map_1 = __importDefault(require_map2());
    var flatten_1 = __importDefault(require_flatten());
    var values_1 = __importDefault(require_values());
    var some_1 = __importDefault(require_some());
    var groupBy_1 = __importDefault(require_groupBy());
    var assign_1 = __importDefault(require_assign());
    function buildModel(productions) {
      var generator = new CstNodeDefinitionGenerator();
      var allRules = (0, values_1.default)(productions);
      return (0, map_1.default)(allRules, function(rule) {
        return generator.visitRule(rule);
      });
    }
    exports2.buildModel = buildModel;
    var CstNodeDefinitionGenerator = (
      /** @class */
      function(_super) {
        __extends(CstNodeDefinitionGenerator2, _super);
        function CstNodeDefinitionGenerator2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
          var rawElements = this.visitEach(node.definition);
          var grouped = (0, groupBy_1.default)(rawElements, function(el) {
            return el.propertyName;
          });
          var properties = (0, map_1.default)(grouped, function(group, propertyName) {
            var allNullable = !(0, some_1.default)(group, function(el) {
              return !el.canBeNull;
            });
            var propertyType = group[0].type;
            if (group.length > 1) {
              propertyType = (0, map_1.default)(group, function(g) {
                return g.type;
              });
            }
            return {
              name: propertyName,
              type: propertyType,
              optional: allNullable
            };
          });
          return {
            name: node.name,
            properties
          };
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
          return this.visitEach(node.definition);
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
          return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
          }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.terminalType.name,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.nonTerminalName,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
          return (0, map_1.default)(this.visitEach(definition), function(definition2) {
            return (0, assign_1.default)({}, definition2, override);
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
          var _this = this;
          return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
            return _this.visit(definition2);
          }));
        };
        return CstNodeDefinitionGenerator2;
      }(gast_1.GAstVisitor)
    );
    function getType(production) {
      if (production instanceof gast_1.NonTerminal) {
        return {
          kind: "rule",
          name: production.referencedRule.name
        };
      }
      return { kind: "token" };
    }
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module2.exports = castSlice;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// ../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// ../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var require_generate = __commonJS({
  "../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genDts = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map2());
    var reduce_1 = __importDefault(require_reduce());
    var uniq_1 = __importDefault(require_uniq());
    var upperFirst_1 = __importDefault(require_upperFirst());
    function genDts(model, options) {
      var contentParts = [];
      contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
      contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
        return genCstNodeTypes(node);
      })));
      if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
      }
      return contentParts.join("\n\n") + "\n";
    }
    exports2.genDts = genDts;
    function genCstNodeTypes(node) {
      var nodeCstInterface = genNodeInterface(node);
      var nodeChildrenInterface = genNodeChildrenType(node);
      return [nodeCstInterface, nodeChildrenInterface];
    }
    function genNodeInterface(node) {
      var nodeInterfaceName = getNodeInterfaceName(node.name);
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
    }
    function genNodeChildrenType(node) {
      var typeName = getNodeChildrenTypeName(node.name);
      return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
        return genChildProperty(property);
      }).join("\n  "), "\n};");
    }
    function genChildProperty(prop) {
      var typeName = buildTypeString(prop.type);
      return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
    }
    function genVisitor(name, nodes) {
      return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
        return genVisitorFunction(node);
      }).join("\n  "), "\n}");
    }
    function genVisitorFunction(node) {
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
    }
    function buildTypeString(type) {
      if ((0, isArray_1.default)(type)) {
        var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t) {
          return getTypeString(t);
        }));
        var typeString = (0, reduce_1.default)(typeNames, function(sum, t) {
          return sum + " | " + t;
        });
        return "(" + typeString + ")";
      } else {
        return getTypeString(type);
      }
    }
    function getTypeString(type) {
      if (type.kind === "token") {
        return "IToken";
      }
      return getNodeInterfaceName(type.name);
    }
    function getNodeInterfaceName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstNode";
    }
    function getNodeChildrenTypeName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstChildren";
    }
  }
});

// ../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var require_api3 = __commonJS({
  "../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCstDts = void 0;
    var model_1 = require_model2();
    var generate_1 = require_generate();
    var defaultOptions = {
      includeVisitorInterface: true,
      visitorInterfaceName: "ICstNodeVisitor"
    };
    function generateCstDts2(productions, options) {
      var effectiveOptions = __assign(__assign({}, defaultOptions), options);
      var model = (0, model_1.buildModel)(productions);
      return (0, generate_1.genDts)(model, effectiveOptions);
    }
    exports2.generateCstDts = generateCstDts2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js
var require_render_public = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxDiagramsCode = void 0;
    var version_1 = require_version();
    function createSyntaxDiagramsCode2(grammar, _a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
      var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
      var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
      var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'></script>\n<script src='").concat(resourceBase, "src/main.js'></script>\n");
      var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
      var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n</script>\n");
      var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n';
      return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
    }
    exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode2;
  }
});

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js
var require_api4 = __commonJS({
  "../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var parser_1 = require_parser2();
    Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
      return parser_1.CstParser;
    } });
    Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
      return parser_1.EmbeddedActionsParser;
    } });
    Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
      return parser_1.ParserDefinitionErrorType;
    } });
    Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
      return parser_1.EMPTY_ALT;
    } });
    var lexer_public_1 = require_lexer_public();
    Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
      return lexer_public_1.Lexer;
    } });
    Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
      return lexer_public_1.LexerDefinitionErrorType;
    } });
    var tokens_public_1 = require_tokens_public();
    Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
      return tokens_public_1.createToken;
    } });
    Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
      return tokens_public_1.createTokenInstance;
    } });
    Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
      return tokens_public_1.EOF;
    } });
    Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
      return tokens_public_1.tokenLabel;
    } });
    Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
      return tokens_public_1.tokenMatcher;
    } });
    Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
      return tokens_public_1.tokenName;
    } });
    var lookahead_1 = require_lookahead();
    Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
      return lookahead_1.getLookaheadPaths;
    } });
    var llk_lookahead_1 = require_llk_lookahead();
    Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
      return llk_lookahead_1.LLkLookaheadStrategy;
    } });
    var errors_public_1 = require_errors_public();
    Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
      return errors_public_1.defaultParserErrorProvider;
    } });
    var exceptions_public_1 = require_exceptions_public();
    Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
      return exceptions_public_1.EarlyExitException;
    } });
    Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
      return exceptions_public_1.isRecognitionException;
    } });
    Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
      return exceptions_public_1.MismatchedTokenException;
    } });
    Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
      return exceptions_public_1.NotAllInputParsedException;
    } });
    Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
      return exceptions_public_1.NoViableAltException;
    } });
    var lexer_errors_public_1 = require_lexer_errors_public();
    Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
      return lexer_errors_public_1.defaultLexerErrorProvider;
    } });
    var gast_1 = require_api2();
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return gast_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return gast_1.Alternative;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return gast_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return gast_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return gast_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return gast_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return gast_1.Terminal;
    } });
    var gast_2 = require_api2();
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return gast_2.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return gast_2.serializeProduction;
    } });
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return gast_2.GAstVisitor;
    } });
    var cst_dts_gen_1 = require_api3();
    Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
      return cst_dts_gen_1.generateCstDts;
    } });
    function clearCache2() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
    }
    exports2.clearCache = clearCache2;
    var render_public_1 = require_render_public();
    Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
      return render_public_1.createSyntaxDiagramsCode;
    } });
    var Parser2 = (
      /** @class */
      /* @__PURE__ */ function() {
        function Parser3() {
          throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
        }
        return Parser3;
      }()
    );
    exports2.Parser = Parser2;
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/format.js
var require_format = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class _InvalidFormatError extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, _InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format2(options = {}) {
        this.options = options;
      }
      Format2.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format2(opts);
      }
      createFormatWrap.Format = Format2;
      return createFormatWrap;
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map4, str) {
      var exploded = str.split("");
      exploded = exploded.map(map4);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map3 in colors.maps) {
      (function(map4) {
        colors[map4] = function(str) {
          return sequencer(colors.maps[map4], str);
        };
      })(map3);
    }
    var map3;
    defineProps(colors, init());
  }
});

// ../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "../node_modules/.pnpm/@colors+colors@1.6.0/node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// ../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// ../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// ../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// ../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// ../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "../node_modules/.pnpm/triple-beam@1.4.1/node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class _Colorizer {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        _Colorizer.allColors = Object.assign({}, _Colorizer.allColors || {}, nextColors);
        return _Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return _Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(_Colorizer.allColors[lookup])) {
          return colors[_Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = _Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[_Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/levels.js
var require_levels = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/align.js
var require_align = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/errors.js
var require_errors2 = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format2((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        if (cause)
          info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      if (cause)
        einfo.cause = err.cause;
      return einfo;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class _Padder {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = _Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = _Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = _Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/combine.js
var require_combine = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format2(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// ../node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "../node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/json.js
var require_json = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format2((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/label.js
var require_label = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format2((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// ../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var ms = require_ms();
    module2.exports = format2((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format2 = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format2((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/printf.js
var require_printf = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/simple.js
var require_simple = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/splat.js
var require_splat = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// ../node_modules/.pnpm/fecha@4.2.3/node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "../node_modules/.pnpm/fecha@4.2.3/node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format2 = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse(dateStr, format3, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format3 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format3 = globalMasks[format3] || format3;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format3.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format: format2,
        parse,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign;
      exports3.default = fecha;
      exports3.format = format2;
      exports3.parse = parse;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format2 = require_format();
    module2.exports = format2((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format2((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// ../node_modules/.pnpm/logform@2.7.0/node_modules/logform/index.js
var require_logform = __commonJS({
  "../node_modules/.pnpm/logform@2.7.0/node_modules/logform/index.js"(exports2) {
    "use strict";
    var format2 = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format2, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors2();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format2 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format2("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format2("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/package.json
var require_package = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.17.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.7.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.9.0"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.24.0",
        "@babel/preset-env": "^7.24.0",
        "@dabh/eslint-config-populist": "^4.4.0",
        "@types/node": "^20.11.24",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.57.0",
        hock: "^1.4.1",
        mocha: "^10.3.0",
        nyc: "^17.1.0",
        rimraf: "5.0.1",
        split2: "^4.1.0",
        "std-mocks": "^2.0.0",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "rimraf test/fixtures/logs/* && mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// ../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor2) {
      if (!(instance instanceof Constructor2)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor2, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor2.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor2, staticProps);
      Object.defineProperty(Constructor2, "prototype", { writable: false });
      return Constructor2;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/modern.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log)
        this.log = options.log;
      if (options.logv)
        this.logv = options.logv;
      if (options.close)
        this.close = options.close;
      this.once("pipe", (logger3) => {
        this.levels = logger3.levels;
        this.parent = logger3;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// ../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// ../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "../node_modules/.pnpm/winston-transport@4.9.0/node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.forceConsole = options.forceConsole || false;
        this._consoleLog = console.log.bind(console);
        this._consoleWarn = console.warn.bind(console);
        this._consoleError = console.error.bind(console);
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleError(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleWarn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout && !this.forceConsole) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleLog(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/isArrayLike.js
var require_isArrayLike2 = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/once.js
var require_once = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/series.js
var require_series = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform();
    require_inherits()(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger3 = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger3 = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger3.apply(logger3, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force))
        return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// ../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../node_modules/.pnpm/is-arrayish@0.3.2/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../node_modules/.pnpm/is-arrayish@0.3.2/node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// ../node_modules/.pnpm/simple-swizzle@0.2.2/node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "../node_modules/.pnpm/simple-swizzle@0.2.2/node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// ../node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js
var require_color_string = __commonJS({
  "../node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// ../node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "../node_modules/.pnpm/color-name@1.1.3/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js
var require_route = __commonJS({
  "../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../node_modules/.pnpm/color-convert@1.9.3/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../node_modules/.pnpm/color@3.2.1/node_modules/color/index.js
var require_color = __commonJS({
  "../node_modules/.pnpm/color@3.2.1/node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// ../node_modules/.pnpm/text-hex@1.0.0/node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "../node_modules/.pnpm/text-hex@1.0.0/node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// ../node_modules/.pnpm/colorspace@1.1.4/node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "../node_modules/.pnpm/colorspace@1.1.4/node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// ../node_modules/.pnpm/kuler@2.0.0/node_modules/kuler/index.js
var require_kuler = __commonJS({
  "../node_modules/.pnpm/kuler@2.0.0/node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// ../node_modules/.pnpm/enabled@2.0.0/node_modules/enabled/index.js
var require_enabled = __commonJS({
  "../node_modules/.pnpm/enabled@2.0.0/node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// ../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "../node_modules/.pnpm/@dabh+diagnostics@2.0.3/node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy)
          this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (!this._stream.emit("rotate")) {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
          tasks.push(
            function(cb) {
              const num = this._created > 0 && !this.tailable ? this._created : "";
              this._compressFile(
                path.join(this.dirname, `${basename2}${num}${ext}`),
                path.join(this.dirname, `${basename2}${num}${ext}.gz`),
                cb
              );
            }.bind(this)
          );
        }
        tasks.push(
          function(cb) {
            if (!this.tailable) {
              this._created += 1;
              this._checkMaxFilesIncrementing(ext, basename2, cb);
            } else {
              this._checkMaxFilesTailable(ext, basename2, cb);
            }
          }.bind(this)
        );
        asyncSeries(tasks, callback);
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? `${basename2}${isRotation}${ext}` : `${basename2}${ext}`;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename2, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename2}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename2, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename2}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename2}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename2}${ext}${isZipped}`),
            path.join(this.dirname, `${basename2}1${ext}${isZipped}`),
            callback
          );
        });
      }
      /**
       * Compresses src to dest with gzip and unlinks src
       * @param {string} src - path to source file.
       * @param {string} dest - path to zipped destination file.
       * @param {Function} callback - callback called after file has been compressed.
       * @returns {undefined}
       * @private
       */
      _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, (err) => {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(src);
          var out = fs.createWriteStream(dest);
          out.on("finish", () => {
            fs.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var { configure } = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        const jsonStringify = configure({
          ...this.maximumDepth && { maximumDepth: this.maximumDepth }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// ../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/stream.js
var require_stream2 = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream2();
      }
    });
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/async@3.2.6/node_modules/async/forEach.js
var require_forEach2 = __commonJS({
  "../node_modules/.pnpm/async@3.2.6/node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2.default;
  }
});

// ../node_modules/.pnpm/fn.name@1.1.0/node_modules/fn.name/index.js
var require_fn = __commonJS({
  "../node_modules/.pnpm/fn.name@1.1.0/node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// ../node_modules/.pnpm/one-time@1.0.0/node_modules/one-time/index.js
var require_one_time = __commonJS({
  "../node_modules/.pnpm/one-time@1.0.0/node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// ../node_modules/.pnpm/stack-trace@0.0.10/node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "../node_modules/.pnpm/stack-trace@0.0.10/node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach2();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger3) {
        if (!logger3) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger3;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/rejection-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class RejectionStream extends Writable {
      /**
       * Constructor function for the RejectionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.rejection` set to true.
       * @param {!TransportStream} transport - Stream to filter to rejections
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `rejection` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach2();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var RejectionStream = require_rejection_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger3) {
        if (!logger3) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger3;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          rejection: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger3) {
        const Logger2 = require_logger();
        if (typeof logger3 !== "object" || Array.isArray(logger3) || !(logger3 instanceof Logger2)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger3;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform: Transform2 } = require_readable();
    var asyncForEach = require_forEach2();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger2 = class extends Transform2 {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger3 = this;
        return Object.create(logger3, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger3.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format: format2,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format2 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            if (meta.cause)
              info.cause = meta.cause;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished)
              return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger2.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger2;
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger2 = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger2 {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger3 = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger3;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger3;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger3).isLevelEnabled(level);
        };
      });
      return logger3;
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger2 = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger3 = createLogger2(options);
          logger3.on("close", () => this._delete(id));
          this.loggers.set(id, logger3);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger3 = this.loggers.get(id);
        logger3.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// ../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "../node_modules/.pnpm/winston@3.17.0/node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.Logger = require_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    Object.defineProperty(exports2, "rejections", {
      get() {
        return defaultLogger.rejections;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// ../node_modules/.pnpm/damerau-levenshtein@1.0.8/node_modules/damerau-levenshtein/index.js
var require_damerau_levenshtein = __commonJS({
  "../node_modules/.pnpm/damerau-levenshtein@1.0.8/node_modules/damerau-levenshtein/index.js"(exports2, module2) {
    module2.exports = function(__this, that, limit) {
      var thisLength = __this.length, thatLength = that.length, matrix = [];
      limit = (limit || (thatLength > thisLength ? thatLength : thisLength)) + 1;
      for (var i = 0; i < limit; i++) {
        matrix[i] = [i];
        matrix[i].length = limit;
      }
      for (i = 0; i < limit; i++) {
        matrix[0][i] = i;
      }
      if (Math.abs(thisLength - thatLength) > (limit || 100)) {
        return prepare(limit || 100);
      }
      if (thisLength === 0) {
        return prepare(thatLength);
      }
      if (thatLength === 0) {
        return prepare(thisLength);
      }
      var j, this_i, that_j, cost, min, t;
      for (i = 1; i <= thisLength; ++i) {
        this_i = __this[i - 1];
        for (j = 1; j <= thatLength; ++j) {
          if (i === j && matrix[i][j] > 4)
            return prepare(thisLength);
          that_j = that[j - 1];
          cost = this_i === that_j ? 0 : 1;
          min = matrix[i - 1][j] + 1;
          if ((t = matrix[i][j - 1] + 1) < min)
            min = t;
          if ((t = matrix[i - 1][j - 1] + cost) < min)
            min = t;
          matrix[i][j] = i > 1 && j > 1 && this_i === that[j - 2] && __this[i - 2] === that_j && (t = matrix[i - 2][j - 2] + cost) < min ? t : min;
        }
      }
      return prepare(matrix[thisLength][thatLength]);
      function prepare(steps) {
        var length = Math.max(thisLength, thatLength);
        var relative = length === 0 ? 0 : steps / length;
        var similarity = 1 - relative;
        return {
          steps,
          relative,
          similarity
        };
      }
    };
  }
});

// ../packages/task-parser/yaml-dsl/parser2.ts
var parser2_exports = {};
__export(parser2_exports, {
  YamlParser: () => YamlParser
});
module.exports = __toCommonJS(parser2_exports);

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports = {};
__export(value_exports, {
  HasPropertyKey: () => HasPropertyKey,
  IsArray: () => IsArray,
  IsAsyncIterator: () => IsAsyncIterator,
  IsBigInt: () => IsBigInt,
  IsBoolean: () => IsBoolean,
  IsDate: () => IsDate,
  IsFunction: () => IsFunction,
  IsIterator: () => IsIterator,
  IsNull: () => IsNull,
  IsNumber: () => IsNumber,
  IsObject: () => IsObject,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString,
  IsSymbol: () => IsSymbol,
  IsUint8Array: () => IsUint8Array,
  IsUndefined: () => IsUndefined
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === void 0;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === void 0 ? Clone(schema) : Clone({ ...options, ...schema });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === void 0;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== void 0 ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
var TypeBoxError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports = {};
__export(type_exports, {
  IsAny: () => IsAny2,
  IsArgument: () => IsArgument2,
  IsArray: () => IsArray4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsBigInt: () => IsBigInt4,
  IsBoolean: () => IsBoolean4,
  IsComputed: () => IsComputed2,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate4,
  IsFunction: () => IsFunction4,
  IsImport: () => IsImport,
  IsInteger: () => IsInteger3,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator4,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue2,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull4,
  IsNumber: () => IsNumber4,
  IsObject: () => IsObject4,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise3,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString4,
  IsSymbol: () => IsSymbol4,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array4,
  IsUndefined: () => IsUndefined4,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var format_exports = {};
__export(format_exports, {
  Clear: () => Clear,
  Delete: () => Delete,
  Entries: () => Entries,
  Get: () => Get,
  Has: () => Has,
  Set: () => Set2
});
var map = /* @__PURE__ */ new Map();
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format2) {
  return map.delete(format2);
}
function Has(format2) {
  return map.has(format2);
}
function Set2(format2, func) {
  map.set(format2, func);
}
function Get(format2) {
  return map.get(format2);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var type_exports2 = {};
__export(type_exports2, {
  Clear: () => Clear2,
  Delete: () => Delete2,
  Entries: () => Entries2,
  Get: () => Get2,
  Has: () => Has2,
  Set: () => Set3
});
var map2 = /* @__PURE__ */ new Map();
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2; i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0; i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return (
    // unevaluated modifier types
    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : (
        // unevaluated types
        IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T
      )
    )
  );
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult.True : type_exports.IsUnion(right) ? ExtendsResult.Union : type_exports.IsUnknown(right) ? ExtendsResult.True : type_exports.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return type_exports.IsNot(left) ? Visit3(UnwrapTNot(left), right) : type_exports.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports.IsString(left) && IsObjectStringLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsNumber(left) && IsObjectNumberLike(right) || type_exports.IsInteger(left) && IsObjectNumberLike(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports.IsDate(left) && IsObjectDateLike(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : !type_exports.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit3(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = type_exports.IsRegExp(left) ? String2() : left;
  const R = type_exports.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult.True : type_exports.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : type_exports.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult.True : type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports.IsTuple(right) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsVoid(right) ? FromVoidRight(left, right) : type_exports.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsString(right) ? FromStringRight(left, right) : type_exports.IsNumber(right) ? FromNumberRight(left, right) : type_exports.IsInteger(right) ? FromIntegerRight(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight(left, right) : type_exports.IsArray(right) ? FromArrayRight(left, right) : type_exports.IsTuple(right) ? FromTupleRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult.True : type_exports.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight(left, right) : type_exports.IsAny(right) ? FromAnyRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return (
    // resolvable
    type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot(left, right) : (
      // standard
      type_exports.IsAny(left) ? FromAny(left, right) : type_exports.IsArray(left) ? FromArray4(left, right) : type_exports.IsBigInt(left) ? FromBigInt(left, right) : type_exports.IsBoolean(left) ? FromBoolean(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : type_exports.IsConstructor(left) ? FromConstructor(left, right) : type_exports.IsDate(left) ? FromDate(left, right) : type_exports.IsFunction(left) ? FromFunction(left, right) : type_exports.IsInteger(left) ? FromInteger(left, right) : type_exports.IsIntersect(left) ? FromIntersect4(left, right) : type_exports.IsIterator(left) ? FromIterator(left, right) : type_exports.IsLiteral(left) ? FromLiteral2(left, right) : type_exports.IsNever(left) ? FromNever(left, right) : type_exports.IsNull(left) ? FromNull(left, right) : type_exports.IsNumber(left) ? FromNumber(left, right) : type_exports.IsObject(left) ? FromObject(left, right) : type_exports.IsRecord(left) ? FromRecord(left, right) : type_exports.IsString(left) ? FromString(left, right) : type_exports.IsSymbol(left) ? FromSymbol(left, right) : type_exports.IsTuple(left) ? FromTuple3(left, right) : type_exports.IsPromise(left) ? FromPromise2(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array(left, right) : type_exports.IsUndefined(left) ? FromUndefined(left, right) : type_exports.IsUnion(left) ? FromUnion6(left, right) : type_exports.IsUnknown(left) ? FromUnknown(left, right) : type_exports.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : (
        // Default Type
        CreateType(schema, options)
      )
    )
  );
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : (
      // Intrinsic
      IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return (
    // Modifiers
    IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : (
      // Transform
      IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : (
        // Types
        IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type
      )
    )
  );
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
var TModule = class {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  /** `[Json]` Imports a Type by Key. */
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  // prettier-ignore
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module(properties) {
  return new TModule(properties);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode2 = (value) => schema[TransformKind].Encode(encode(value));
    const Decode2 = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports3 = {};
__export(type_exports3, {
  Any: () => Any,
  Argument: () => Argument,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean2,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function2,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Instantiate: () => Instantiate,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Module: () => Module,
  Never: () => Never,
  Not: () => Not2,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  String: () => String2,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports3;

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function SetErrorFunction(callback) {
  errorFunction = callback;
}
function GetErrorFunction() {
  return errorFunction;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
var TypeDereferenceError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
};
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === void 0)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
var ValueHashError = class extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
};
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt(
  "18446744073709551616"
  /* 2 ^ 64 */
)];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0; i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0; i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0; i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
var ValueCheckUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
};
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== void 0;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!format_exports.Has(schema.format))
      return false;
    const func = format_exports.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === void 0 && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0; i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!type_exports2.Has(schema[Kind]))
    return false;
  const func = type_exports2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));
var ValueErrorsUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== void 0;
}
var ValueErrorIterator = class {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  /** Returns the first value error or undefined if no errors */
  First() {
    const next = this.iterator.next();
    return next.done ? void 0 : next.value;
  }
};
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {
}
function* FromArgument3(schema, references, path, value) {
}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0; i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value) {
      const hashed = Hash(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!format_exports.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format2 = format_exports.Get(schema.format);
      if (!format2(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === void 0 && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0; i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {
}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = type_exports2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
var TransformDecodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformDecodeError = class extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
};
function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray9(schema, references, path, value) {
  return IsArray2(value) ? Default(schema, path, value.map((value2, index) => Visit7(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit7(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromImport3(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit7(target, [...references, ...additional], path, value);
  return Default(schema, path, result);
}
function FromNot4(schema, references, path, value) {
  return Default(schema, path, Visit7(schema.not, references, path, value));
}
function FromObject10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit7(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRecord6(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit7(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRef7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromThis3(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromTuple8(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit7(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit7(subschema, references, path, value);
    return Default(schema, path, decoded);
  }
  return Default(schema, path, value);
}
function Visit7(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, path, value);
    case "Import":
      return FromImport3(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot4(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord6(schema_, references_, path, value);
    case "Ref":
      return FromRef7(schema_, references_, path, value);
    case "Symbol":
      return Default(schema_, path, value);
    case "This":
      return FromThis3(schema_, references_, path, value);
    case "Tuple":
      return FromTuple8(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit7(schema, references, "", value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
var TransformEncodeCheckError = class extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
};
var TransformEncodeError = class extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
};
function Default2(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray10(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit8(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport4(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default2(schema, path, value);
  return Visit8(target, [...references, ...additional], path, result);
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit8(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot5(schema, references, path, value) {
  return Default2(schema.not, path, Default2(schema, path, value));
}
function FromObject11(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit8(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord7(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit8(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromThis4(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromTuple9(schema, references, path, value) {
  const value1 = Default2(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit8(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit8(subschema, references, path, value);
    return Default2(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit8(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default2(schema, path, value1);
  }
  return Default2(schema, path, value);
}
function Visit8(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, path, value);
    case "Import":
      return FromImport4(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject11(schema_, references_, path, value);
    case "Record":
      return FromRecord7(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "This":
      return FromThis4(schema_, references_, path, value);
    case "Tuple":
      return FromTuple9(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default2(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit8(schema, references, "", value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray11(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromFunction6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit9(schema2, references));
}
function FromImport5(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit9(target, [...additional, ...references]);
}
function FromIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
  return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject12(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit9(schema2, references)) || IsSchema(schema.additionalProperties) && Visit9(schema.additionalProperties, references);
}
function FromPromise6(schema, references) {
  return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord8(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit9(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromThis5(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromTuple10(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit9(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit9(schema2, references));
}
function Visit9(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Not":
      return FromNot6(schema_, references_);
    case "Object":
      return FromObject12(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord8(schema_, references_);
    case "Ref":
      return FromRef9(schema_, references_);
    case "This":
      return FromThis5(schema_, references_);
    case "Tuple":
      return FromTuple10(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = /* @__PURE__ */ new Set();
function HasTransform(schema, references) {
  visited.clear();
  return Visit9(schema, references);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
var TypeCheck = class {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns the schema type used to validate */
  Schema() {
    return this.schema;
  }
  /** Returns reference types used to validate */
  References() {
    return this.references;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value) {
    return this.checkFunc(value);
  }
  /** Decodes a value or throws if error */
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  /** Encodes a value or throws if error */
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
};
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0; i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0; i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));
var TypeCompilerUnknownTypeError = class extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
};
var TypeCompilerTypeGuardError = class extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
};
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArgument5(schema, references, value) {
    yield "true";
  }
  function* FromArray18(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate8(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport11(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple16(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === void 0)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0; i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion21(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value);
      case "Array":
        return yield* FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value);
      case "Date":
        return yield* FromDate8(schema_, references_, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, value);
      case "Import":
        return yield* FromImport11(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject19(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!type_exports2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    // target language
    functions: /* @__PURE__ */ new Map(),
    // local functions
    variables: /* @__PURE__ */ new Map(),
    // local variables
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!type_exports2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = type_exports2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format2, value) {
      if (!format_exports.Has(format2))
        return false;
      const checkFunc = format_exports.Get(format2);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// ../packages/schema/typebox-utils.ts
SetErrorFunction((error) => {
  if (error.schema.errorMessage && typeof error.schema.errorMessage === "string")
    return error.schema.errorMessage;
  return DefaultErrorFunction(error);
});
function TBrandedString(options) {
  return Type.String(options);
}
function TBrandedNumber() {
  return Type.Number();
}
function TLiteralUnion(values) {
  const literals = values.map((value) => Type.Literal(value));
  return Type.Union(literals);
}

// ../packages/utils/verify-exists.ts
function verifyExists(val) {
  if (val === void 0 || val === null) {
    throw new Error("Value does not exist");
  }
  return val;
}

// ../packages/schema/errors/message.ts
var TStackEntry = Type.Object({
  fileName: Type.String(),
  line: Type.Number(),
  column: Type.Number(),
  name: Type.Optional(Type.String())
});
var TUserMessage = Type.Object({
  type: Type.String(),
  message: Type.String(),
  advice: Type.Optional(Type.String()),
  fileName: Type.Optional(Type.String()),
  line: Type.Optional(Type.Number()),
  column: Type.Optional(Type.Number()),
  stackTrace: Type.Optional(Type.Array(TStackEntry)),
  frame: Type.Optional(Type.String())
});
var UserError = class extends Error {
  type;
  messageWithoutFileLocation;
  advice;
  fileName;
  line;
  column;
  stackTrace;
  constructor({ type, message, advice, fileName, line, column, stackTrace, frame }) {
    super(messageWithFileLocation({ message, fileName, line, column, stackTrace, frame }));
    this.type = type;
    this.messageWithoutFileLocation = message;
    this.name = "UserError";
    this.advice = advice;
    this.stackTrace = stackTrace;
    this.fileName = fileName;
    this.line = line;
    this.column = column;
    if (this.stackTrace) {
      const lastStackEntry = verifyExists(this.stackTrace.findLast((e) => e));
      this.fileName = lastStackEntry.fileName;
      this.line = lastStackEntry.line;
      this.column = lastStackEntry.column;
    }
  }
  get messageWithAdvice() {
    return this.advice ? `${this.message}

${this.advice}` : this.message;
  }
  asMessage() {
    const userMessage = { type: this.type, message: this.messageWithoutFileLocation };
    if (this.advice)
      userMessage.advice = this.advice;
    if (this.fileName)
      userMessage.fileName = this.fileName;
    if (this.line)
      userMessage.line = this.line;
    if (this.column)
      userMessage.column = this.column;
    if (this.stackTrace)
      userMessage.stackTrace = this.stackTrace;
    return userMessage;
  }
};
function buildMessage({
  type,
  message,
  advice,
  docs,
  fileName,
  line,
  column,
  stackTrace,
  frame
}) {
  if (docs) {
    advice = advice ?? [];
    advice.push(docs);
  }
  const messageStr = message.join("\n");
  const adviceStr = advice?.join("\n");
  const userMessage = { type, message: messageStr };
  if (adviceStr)
    userMessage.advice = adviceStr;
  if (fileName)
    userMessage.fileName = fileName;
  if (line !== void 0)
    userMessage.line = line;
  if (column !== void 0)
    userMessage.column = column;
  if (stackTrace) {
    userMessage.stackTrace = stackTrace;
    const lastStackEntry = verifyExists(stackTrace.findLast((e) => e));
    userMessage.fileName = lastStackEntry.fileName;
    userMessage.line = lastStackEntry.line;
    userMessage.column = lastStackEntry.column;
  }
  if (frame)
    userMessage.frame = frame;
  return userMessage;
}
function codeQuote(message) {
  return `\`${message}\``;
}
function indent(message) {
  return message.split("\n").map((line) => `\u2002\u2002${line}`).join("\n");
}
function messageWithFileLocation({
  message,
  fileName,
  line,
  column,
  stackTrace,
  frame
}) {
  if (!stackTrace) {
    const location = [fileName, line, column].filter((l) => l).join(":");
    if (location !== "") {
      return message + `
  at ${location}`;
    } else {
      return message;
    }
  }
  const formattedStackTrace = [...stackTrace].reverse().map((se) => {
    const namePart = se.name ? `${se.name} (${se.fileName}:${se.line}:${se.column})` : `${se.fileName}:${se.line}:${se.column}`;
    return `  at ${namePart}`;
  }).join("\n");
  if (frame) {
    return message + "\n\n" + frame + "\n" + formattedStackTrace;
  } else {
    return message + "\n" + formattedStackTrace;
  }
}

// ../packages/schema/manifests/versioned/version.ts
var SchemaVersion = /* @__PURE__ */ ((SchemaVersion4) => {
  SchemaVersion4["V1"] = "v1";
  SchemaVersion4["V2"] = "v2";
  SchemaVersion4["V3"] = "v3";
  SchemaVersion4["V4"] = "v4";
  SchemaVersion4["V5"] = "v5";
  SchemaVersion4["V6"] = "v6";
  return SchemaVersion4;
})(SchemaVersion || {});

// ../packages/schema/task-cache/versioned/v15.ts
var TArtifactManifest = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact),
  description: Optional(String2())
});
var TTiming = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming)
    })
  )
});
var TTaskOrGroupId = TBrandedString();
var TDateString = TBrandedString();
var Severity = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity || {});
var TProblemMatcherPattern = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity = Enum(Severity);
var TProblemMatcher = Object2({
  owner: String2(),
  severity: Optional(TSeverity),
  pattern: Array2(TProblemMatcherPattern)
});
var TProblemPath = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus || {});
var BackgroundProcessResultFinishedSubStatus = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus || {});
var TBackgroundProcessResult = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus),
  startedAt: Optional(TDateString),
  completedAt: Optional(TDateString),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey || {});
var TEnvironmentVariables = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey)
  })
);
var TTip = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult = Object2({
  schemaVersion: Literal("v15" /* V15 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask),
  environmentVariables: TEnvironmentVariables,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest),
  whiteoutLayer: Optional(TLayerWithManifest),
  filesystemLayers: Array2(TLayerWithManifest),
  problems: Array2(TProblem),
  testResults: Array2(TTestResults),
  artifacts: Array2(TArtifact),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps,
  outputRetryActions: Array2(TRetryAction),
  dockerLayer: Optional(TLayerWithManifest),
  tips: Array2(TTip)
});

// ../packages/schema/task-cache/versioned/latest.ts
var LatestSchemaVersion = "v15" /* V15 */;

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;
var AssertError = class extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === void 0 ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, void 0);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  /** Returns an iterator for each error in this value. */
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
};
_AssertError_iterator = /* @__PURE__ */ new WeakMap(), _AssertError_instances = /* @__PURE__ */ new WeakSet(), _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject13(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray12(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray12(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject13(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
var ValueCreateError = class extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
};
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray13(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== void 0) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit10(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit10(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== void 0) {
    return new Date(schema.minimumTimestamp);
  } else {
    return /* @__PURE__ */ new Date();
  }
}
function FromFunction7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit10(schema.returns, references);
  }
}
function FromImport6(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit10(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit10(subschema, references);
    }
    return Acc;
  }
}
function FromPromise7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit10(schema.item, references));
  }
}
function FromRecord9(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit10(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef10(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== void 0) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== void 0) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== void 0) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis6(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromTuple11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === void 0) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit10(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromUnion16(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit10(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== void 0) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return void 0;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit10(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor7(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport6(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect14(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject14(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord9(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis6(schema_, references_);
    case "Tuple":
      return FromTuple11(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion16(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!type_exports2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit10(args[0], args[1]) : Visit10(args[0], []);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
var ValueCastError = class extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
};
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default3(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray14(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit11(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor8(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === void 0)
      continue;
    result.prototype[key] = Visit11(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport7(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit11(target, [...references, ...definitions], value);
}
function FromIntersect15(schema, references, value) {
  const created = Create2(schema, references);
  const mapped = IsObject2(created) && IsObject2(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped) ? mapped : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject15(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === void 0)
      continue;
    result[key] = Visit11(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit11(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord10(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit11(subschema, references, propValue);
  }
  return result;
}
function FromRef11(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple12(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === void 0)
    return [];
  return schema.items.map((schema2, index) => Visit11(schema2, references, value[index]));
}
function FromUnion17(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit11(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, value);
    case "Constructor":
      return FromConstructor8(schema_, references_, value);
    case "Import":
      return FromImport7(schema_, references_, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject15(schema_, references_, value);
    case "Record":
      return FromRecord10(schema_, references_, value);
    case "Ref":
      return FromRef11(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple12(schema_, references_, value);
    case "Union":
      return FromUnion17(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default3(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray15(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit12(schema.items, references, value2));
}
function FromImport8(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit12(target, [...references, ...definitions], value);
}
function FromIntersect16(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit12(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit12(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject16(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit12(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord11(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit12(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef12(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromThis8(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromTuple13(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0; i < length; i++) {
    value[i] = Visit12(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion18(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit12(inner, references, value);
    }
  }
  return value;
}
function Visit12(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, value);
    case "Import":
      return FromImport8(schema_, references_, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, value);
    case "Object":
      return FromObject16(schema_, references_, value);
    case "Record":
      return FromRecord11(schema_, references_, value);
    case "Ref":
      return FromRef12(schema_, references_, value);
    case "This":
      return FromThis8(schema_, references_, value);
    case "Tuple":
      return FromTuple13(schema_, references_, value);
    case "Union":
      return FromUnion18(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit12(args[0], args[1], args[2]) : Visit12(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== void 0 ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? void 0 : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
}
function Default4(value) {
  return value;
}
function FromArray16(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit13(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport9(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit13(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect17(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit13(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject17(schema, references, value) {
  if (!IsObject2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit13(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord12(schema, references, value) {
  const isConvertable = IsObject2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit13(property, references, propValue);
  }
  return value;
}
function FromRef13(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis9(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromTuple14(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit13(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion19(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit13(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit13(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport9(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect17(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject17(schema_, references_, value);
    case "Record":
      return FromRecord12(schema_, references_, value);
    case "Ref":
      return FromRef13(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis9(schema_, references_, value);
    case "Tuple":
      return FromTuple14(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion19(schema_, references_, value);
    default:
      return Default4(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit13(args[0], args[1], args[2]) : Visit13(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : void 0;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0; i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0; i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0; i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var pointer_exports = {};
__export(pointer_exports, {
  Delete: () => Delete3,
  Format: () => Format,
  Get: () => Get3,
  Has: () => Has3,
  Set: () => Set4,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  ValuePointerRootSetError: () => ValuePointerRootSetError
});
var ValuePointerRootSetError = class extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
};
var ValuePointerRootDeleteError = class extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
};
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0; i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0 || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === void 0)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === void 0)
      return void 0;
    current = current[component];
  }
  return current;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);
var ValueDiffError = class extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
};
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0; i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1; i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        pointer_exports.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}
var ValueMutateError = class extends TypeBoxError {
  constructor(message) {
    super(message);
  }
};
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    pointer_exports.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    pointer_exports.Set(root, path, Clone2(next));
  } else {
    for (let index = 0; index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0; i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    pointer_exports.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  pointer_exports.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
var ParseError = class extends TypeBoxError {
  constructor(message) {
    super(message);
  }
};
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = /* @__PURE__ */ new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}

// ../node_modules/.pnpm/@sinclair+typebox@0.34.33/node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var value_exports2 = {};
__export(value_exports2, {
  Assert: () => Assert,
  Cast: () => Cast,
  Check: () => Check,
  Clean: () => Clean,
  Clone: () => Clone2,
  Convert: () => Convert,
  Create: () => Create2,
  Decode: () => Decode,
  Default: () => Default5,
  Diff: () => Diff,
  Edit: () => Edit,
  Encode: () => Encode,
  Equal: () => Equal,
  Errors: () => Errors,
  Hash: () => Hash,
  Mutate: () => Mutate,
  Parse: () => Parse,
  Patch: () => Patch,
  ValueErrorIterator: () => ValueErrorIterator
});

// ../packages/schema/task-cache/versioned/v1.ts
var TTaskOrGroupId2 = TBrandedString();
var TDateString2 = TBrandedString();
var Severity2 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity2 || {});
var TProblemMatcherPattern2 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity2 = Enum(Severity2);
var TProblemMatcher2 = Object2({
  owner: String2(),
  severity: Optional(TSeverity2),
  pattern: Array2(TProblemMatcherPattern2)
});
var TProblemPath2 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem2 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity2,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest2 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId2)
});
var BackgroundProcessResultStatus2 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus2 || {});
var BackgroundProcessResultFinishedSubStatus2 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus2 || {});
var TOldBackgroundProcessResult = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  result: Object2({
    type: Enum(BackgroundProcessResultStatus2),
    startedAt: Optional(TDateString2),
    completedAt: Optional(TDateString2),
    exitCode: Optional(Number2()),
    signal: Optional(String2()),
    subStatus: Optional(Enum(BackgroundProcessResultFinishedSubStatus2)),
    readyCheckStdout: Optional(String2()),
    readyCheckStderr: Optional(String2())
  })
});
var TBackgroundProcessResult2 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus2),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus2),
  startedAt: Optional(TDateString2),
  completedAt: Optional(TDateString2),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact2 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath2 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults2 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask2 = Object2({ sourceFilePath: String2(), source: String2() });
var TCachedTaskResult2 = Object2({
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(Union([TBackgroundProcessResult2, TOldBackgroundProcessResult])),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask2),
  environmentVariables: Record(String2(), String2()),
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest2),
  whiteoutLayer: Optional(TLayerWithManifest2),
  problems: Array2(TProblem2),
  testResults: Array2(TTestResults2),
  artifacts: Optional(Array2(TArtifact2))
  // optional because we have stored cached results that don't have this new field
});

// ../packages/schema/task-cache/versioned/v2.ts
var TTaskOrGroupId3 = TBrandedString();
var TDateString3 = TBrandedString();
var Severity3 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity3 || {});
var TProblemMatcherPattern3 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity3 = Enum(Severity3);
var TProblemMatcher3 = Object2({
  owner: String2(),
  severity: Optional(TSeverity3),
  pattern: Array2(TProblemMatcherPattern3)
});
var TProblemPath3 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem3 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity3,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest3 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId3)
});
var BackgroundProcessResultStatus3 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus3 || {});
var BackgroundProcessResultFinishedSubStatus3 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus3 || {});
var TBackgroundProcessResult3 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus3),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus3),
  startedAt: Optional(TDateString3),
  completedAt: Optional(TDateString3),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact3 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath3 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults3 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask3 = Object2({ sourceFilePath: String2(), source: String2() });
var TCachedTaskResult3 = Object2({
  schemaVersion: Literal("v2" /* V2 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult3),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask3),
  environmentVariables: Record(String2(), String2()),
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest3),
  whiteoutLayer: Optional(TLayerWithManifest3),
  problems: Array2(TProblem3),
  testResults: Array2(TTestResults3),
  artifacts: Array2(TArtifact3)
});

// ../packages/schema/task-cache/versioned/v3.ts
var TTaskOrGroupId4 = TBrandedString();
var TDateString4 = TBrandedString();
var Severity4 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity4 || {});
var TProblemMatcherPattern4 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity4 = Enum(Severity4);
var TProblemMatcher4 = Object2({
  owner: String2(),
  severity: Optional(TSeverity4),
  pattern: Array2(TProblemMatcherPattern4)
});
var TProblemPath4 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem4 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity4,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest4 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId4)
});
var BackgroundProcessResultStatus4 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus4 || {});
var BackgroundProcessResultFinishedSubStatus4 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus4 || {});
var TBackgroundProcessResult4 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus4),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus4),
  startedAt: Optional(TDateString4),
  completedAt: Optional(TDateString4),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact4 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath4 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults4 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask4 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey2 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey2 || {});
var TEnvironmentVariables2 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey2)
  })
);
var TCachedTaskResult4 = Object2({
  schemaVersion: Literal("v3" /* V3 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult4),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask4),
  environmentVariables: TEnvironmentVariables2,
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest4),
  whiteoutLayer: Optional(TLayerWithManifest4),
  problems: Array2(TProblem4),
  testResults: Array2(TTestResults4),
  artifacts: Array2(TArtifact4)
});

// ../packages/schema/task-cache/versioned/v4.ts
var TTaskOrGroupId5 = TBrandedString();
var TDateString5 = TBrandedString();
var Severity5 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity5 || {});
var TProblemMatcherPattern5 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity5 = Enum(Severity5);
var TProblemMatcher5 = Object2({
  owner: String2(),
  severity: Optional(TSeverity5),
  pattern: Array2(TProblemMatcherPattern5)
});
var TProblemPath5 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem5 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity5,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest5 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId5)
});
var BackgroundProcessResultStatus5 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus5 || {});
var BackgroundProcessResultFinishedSubStatus5 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus5 || {});
var TBackgroundProcessResult5 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus5),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus5),
  startedAt: Optional(TDateString5),
  completedAt: Optional(TDateString5),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact5 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath5 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults5 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask5 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey3 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey3 || {});
var TEnvironmentVariables3 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey3)
  })
);
var TCachedTaskResult5 = Object2({
  schemaVersion: Literal("v4" /* V4 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult5),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask5),
  environmentVariables: TEnvironmentVariables3,
  values: Record(String2(), String2()),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest5),
  whiteoutLayer: Optional(TLayerWithManifest5),
  problems: Array2(TProblem5),
  testResults: Array2(TTestResults5),
  artifacts: Array2(TArtifact5),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/task-cache/versioned/v5.ts
var TTaskOrGroupId6 = TBrandedString();
var TDateString6 = TBrandedString();
var Severity6 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity6 || {});
var TProblemMatcherPattern6 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity6 = Enum(Severity6);
var TProblemMatcher6 = Object2({
  owner: String2(),
  severity: Optional(TSeverity6),
  pattern: Array2(TProblemMatcherPattern6)
});
var TProblemPath6 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem6 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity6,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest6 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestContentAddress: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId6)
});
var BackgroundProcessResultStatus6 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus6 || {});
var BackgroundProcessResultFinishedSubStatus6 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus6 || {});
var TBackgroundProcessResult6 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus6),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus6),
  startedAt: Optional(TDateString6),
  completedAt: Optional(TDateString6),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact6 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath6 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults6 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask6 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey4 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey4 || {});
var TEnvironmentVariables4 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey4)
  })
);
var TCachedTaskResult6 = Object2({
  schemaVersion: Literal("v5" /* V5 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult6),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask6),
  environmentVariables: TEnvironmentVariables4,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest6),
  whiteoutLayer: Optional(TLayerWithManifest6),
  problems: Array2(TProblem6),
  testResults: Array2(TTestResults6),
  artifacts: Array2(TArtifact6),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/task-cache/versioned/v6.ts
var TTaskOrGroupId7 = TBrandedString();
var TDateString7 = TBrandedString();
var Severity7 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity7 || {});
var TProblemMatcherPattern7 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity7 = Enum(Severity7);
var TProblemMatcher7 = Object2({
  owner: String2(),
  severity: Optional(TSeverity7),
  pattern: Array2(TProblemMatcherPattern7)
});
var TProblemPath7 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem7 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity7,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest7 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId7)
});
var BackgroundProcessResultStatus7 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus7 || {});
var BackgroundProcessResultFinishedSubStatus7 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus7 || {});
var TBackgroundProcessResult7 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus7),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus7),
  startedAt: Optional(TDateString7),
  completedAt: Optional(TDateString7),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact7 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath7 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults7 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask7 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey5 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey5 || {});
var TEnvironmentVariables5 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey5)
  })
);
var TCachedTaskResult7 = Object2({
  schemaVersion: Literal("v6" /* V6 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult7),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask7),
  environmentVariables: TEnvironmentVariables5,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest7),
  whiteoutLayer: Optional(TLayerWithManifest7),
  problems: Array2(TProblem7),
  testResults: Array2(TTestResults7),
  artifacts: Array2(TArtifact7),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/task-cache/versioned/v7.ts
var TTaskOrGroupId8 = TBrandedString();
var TDateString8 = TBrandedString();
var Severity8 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity8 || {});
var TProblemMatcherPattern8 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity8 = Enum(Severity8);
var TProblemMatcher8 = Object2({
  owner: String2(),
  severity: Optional(TSeverity8),
  pattern: Array2(TProblemMatcherPattern8)
});
var TProblemPath8 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem8 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity8,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest8 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  associatedWithTaskId: Optional(TTaskOrGroupId8)
});
var BackgroundProcessResultStatus8 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus8 || {});
var BackgroundProcessResultFinishedSubStatus8 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus8 || {});
var TBackgroundProcessResult8 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus8),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus8),
  startedAt: Optional(TDateString8),
  completedAt: Optional(TDateString8),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact8 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath8 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults8 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask8 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey6 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey6 || {});
var TEnvironmentVariables6 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey6)
  })
);
var TCachedTaskResult8 = Object2({
  schemaVersion: Literal("v7" /* V7 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult8),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask8),
  environmentVariables: TEnvironmentVariables6,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest8),
  whiteoutLayer: Optional(TLayerWithManifest8),
  filesystemLayers: Array2(TLayerWithManifest8),
  problems: Array2(TProblem8),
  testResults: Array2(TTestResults8),
  artifacts: Array2(TArtifact8),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/task-cache/versioned/v8.ts
var TTaskOrGroupId9 = TBrandedString();
var TDateString9 = TBrandedString();
var Severity9 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity9 || {});
var TProblemMatcherPattern9 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity9 = Enum(Severity9);
var TProblemMatcher9 = Object2({
  owner: String2(),
  severity: Optional(TSeverity9),
  pattern: Array2(TProblemMatcherPattern9)
});
var TProblemPath9 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem9 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity9,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest9 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId9,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus9 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus9 || {});
var BackgroundProcessResultFinishedSubStatus9 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus9 || {});
var TBackgroundProcessResult9 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus9),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus9),
  startedAt: Optional(TDateString9),
  completedAt: Optional(TDateString9),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact9 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath9 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults9 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask9 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey7 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey7 || {});
var TEnvironmentVariables7 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey7)
  })
);
var TCachedTaskResult9 = Object2({
  schemaVersion: Literal("v8" /* V8 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult9),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask9),
  environmentVariables: TEnvironmentVariables7,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest9),
  whiteoutLayer: Optional(TLayerWithManifest9),
  filesystemLayers: Array2(TLayerWithManifest9),
  problems: Array2(TProblem9),
  testResults: Array2(TTestResults9),
  artifacts: Array2(TArtifact9),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/task-cache/versioned/v9.ts
var TTiming2 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps2 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming2)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming2)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming2),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming2),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming2.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming2),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming2),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming2),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming2),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming2),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming2),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming2),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming2)
    })
  )
});
var TTaskOrGroupId10 = TBrandedString();
var TDateString10 = TBrandedString();
var Severity10 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity10 || {});
var TProblemMatcherPattern10 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity10 = Enum(Severity10);
var TProblemMatcher10 = Object2({
  owner: String2(),
  severity: Optional(TSeverity10),
  pattern: Array2(TProblemMatcherPattern10)
});
var TProblemPath10 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem10 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity10,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest10 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId10,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus10 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus10 || {});
var BackgroundProcessResultFinishedSubStatus10 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus10 || {});
var TBackgroundProcessResult10 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus10),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus10),
  startedAt: Optional(TDateString10),
  completedAt: Optional(TDateString10),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact10 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 })
});
var TTestResultsPath10 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults10 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask10 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey8 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey8 || {});
var TEnvironmentVariables8 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey8)
  })
);
var TCachedTaskResult10 = Object2({
  schemaVersion: Literal("v9" /* V9 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult10),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask10),
  environmentVariables: TEnvironmentVariables8,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest10),
  whiteoutLayer: Optional(TLayerWithManifest10),
  filesystemLayers: Array2(TLayerWithManifest10),
  problems: Array2(TProblem10),
  testResults: Array2(TTestResults10),
  artifacts: Array2(TArtifact10),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps2
});

// ../packages/schema/task-cache/versioned/v10.ts
var TTiming3 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps3 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming3)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming3)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming3),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming3),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming3.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming3),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming3),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming3),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming3),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming3),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming3),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming3),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming3)
    })
  )
});
var TTaskOrGroupId11 = TBrandedString();
var TDateString11 = TBrandedString();
var Severity11 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity11 || {});
var TProblemMatcherPattern11 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity11 = Enum(Severity11);
var TProblemMatcher11 = Object2({
  owner: String2(),
  severity: Optional(TSeverity11),
  pattern: Array2(TProblemMatcherPattern11)
});
var TProblemPath11 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem11 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity11,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest11 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId11,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus11 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus11 || {});
var BackgroundProcessResultFinishedSubStatus11 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus11 || {});
var TBackgroundProcessResult11 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus11),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus11),
  startedAt: Optional(TDateString11),
  completedAt: Optional(TDateString11),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact11 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifestContentAddress: Union([String2(), Null()]),
  manifestSizeInBytes: Number2({ minimum: 0 }),
  compression: Union([Literal("gzip"), Null()])
});
var TTestResultsPath11 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults11 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask11 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey9 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey9 || {});
var TEnvironmentVariables9 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey9)
  })
);
var TCachedTaskResult11 = Object2({
  schemaVersion: Literal("v10" /* V10 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult11),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask11),
  environmentVariables: TEnvironmentVariables9,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest11),
  whiteoutLayer: Optional(TLayerWithManifest11),
  filesystemLayers: Array2(TLayerWithManifest11),
  problems: Array2(TProblem11),
  testResults: Array2(TTestResults11),
  artifacts: Array2(TArtifact11),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps3
});

// ../packages/schema/task-cache/versioned/v11.ts
var TArtifactManifest2 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TTiming4 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps4 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming4)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming4)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming4),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming4),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming4.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming4),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming4),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming4),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming4),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming4),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming4),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming4),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming4)
    })
  )
});
var TTaskOrGroupId12 = TBrandedString();
var TDateString12 = TBrandedString();
var Severity12 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity12 || {});
var TProblemMatcherPattern12 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity12 = Enum(Severity12);
var TProblemMatcher12 = Object2({
  owner: String2(),
  severity: Optional(TSeverity12),
  pattern: Array2(TProblemMatcherPattern12)
});
var TProblemPath12 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem12 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity12,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest12 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId12,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus12 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus12 || {});
var BackgroundProcessResultFinishedSubStatus12 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus12 || {});
var TBackgroundProcessResult12 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus12),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus12),
  startedAt: Optional(TDateString12),
  completedAt: Optional(TDateString12),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2())
});
var TArtifact12 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest2, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TTestResultsPath12 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults12 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask12 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey10 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey10 || {});
var TEnvironmentVariables10 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey10)
  })
);
var TCachedTaskResult12 = Object2({
  schemaVersion: Literal("v11" /* V11 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult12),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask12),
  environmentVariables: TEnvironmentVariables10,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest12),
  whiteoutLayer: Optional(TLayerWithManifest12),
  filesystemLayers: Array2(TLayerWithManifest12),
  problems: Array2(TProblem12),
  testResults: Array2(TTestResults12),
  artifacts: Array2(TArtifact12),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps4
});

// ../packages/schema/task-cache/versioned/v12.ts
var TArtifactManifest3 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact13 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest3, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction2 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact13)
});
var TTiming5 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps5 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming5)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming5)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming5),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming5),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming5.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming5),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming5),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming5),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming5),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming5),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming5),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming5),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming5)
    })
  )
});
var TTaskOrGroupId13 = TBrandedString();
var TDateString13 = TBrandedString();
var Severity13 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity13 || {});
var TProblemMatcherPattern13 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity13 = Enum(Severity13);
var TProblemMatcher13 = Object2({
  owner: String2(),
  severity: Optional(TSeverity13),
  pattern: Array2(TProblemMatcherPattern13)
});
var TProblemPath13 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem13 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity13,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest13 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId13,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus13 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus13 || {});
var BackgroundProcessResultFinishedSubStatus13 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus13 || {});
var TBackgroundProcessResult13 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus13),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus13),
  startedAt: Optional(TDateString13),
  completedAt: Optional(TDateString13),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath13 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults13 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask13 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey11 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey11 || {});
var TEnvironmentVariables11 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey11)
  })
);
var TCachedTaskResult13 = Object2({
  schemaVersion: Literal("v12" /* V12 */),
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult13),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask13),
  environmentVariables: TEnvironmentVariables11,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest13),
  whiteoutLayer: Optional(TLayerWithManifest13),
  filesystemLayers: Array2(TLayerWithManifest13),
  problems: Array2(TProblem13),
  testResults: Array2(TTestResults13),
  artifacts: Array2(TArtifact13),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps5,
  outputRetryActions: Array2(TRetryAction2),
  dockerLayer: Optional(TLayerWithManifest13)
});

// ../packages/schema/task-cache/versioned/v13.ts
var TArtifactManifest4 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact14 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest4, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction3 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact14),
  description: Optional(String2())
});
var TTiming6 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps6 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming6)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming6)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming6),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming6),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming6.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming6),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming6),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming6),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming6),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming6),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming6),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming6),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming6)
    })
  )
});
var TTaskOrGroupId14 = TBrandedString();
var TDateString14 = TBrandedString();
var Severity14 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity14 || {});
var TProblemMatcherPattern14 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity14 = Enum(Severity14);
var TProblemMatcher14 = Object2({
  owner: String2(),
  severity: Optional(TSeverity14),
  pattern: Array2(TProblemMatcherPattern14)
});
var TProblemPath14 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem14 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity14,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest14 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId14,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus14 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus14 || {});
var BackgroundProcessResultFinishedSubStatus14 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus14 || {});
var TBackgroundProcessResult14 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus14),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus14),
  startedAt: Optional(TDateString14),
  completedAt: Optional(TDateString14),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath14 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults14 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask14 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey12 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey12 || {});
var TEnvironmentVariables12 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey12)
  })
);
var TCachedTaskResult14 = Object2({
  schemaVersion: Literal("v13" /* V13 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult14),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask14),
  environmentVariables: TEnvironmentVariables12,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest14),
  whiteoutLayer: Optional(TLayerWithManifest14),
  filesystemLayers: Array2(TLayerWithManifest14),
  problems: Array2(TProblem14),
  testResults: Array2(TTestResults14),
  artifacts: Array2(TArtifact14),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps6,
  outputRetryActions: Array2(TRetryAction3),
  dockerLayer: Optional(TLayerWithManifest14)
});

// ../packages/schema/task-cache/versioned/v14.ts
var TArtifactManifest5 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact15 = Object2({
  kind: Union([Literal("file"), Literal("directory"), Literal("does-not-exist")]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest5, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TRetryAction4 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact15),
  description: Optional(String2())
});
var TTiming7 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps7 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming7)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming7)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming7),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming7),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming7.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming7),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming7),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming7),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming7),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming7),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming7),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming7),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming7)
    })
  )
});
var TTaskOrGroupId15 = TBrandedString();
var TDateString15 = TBrandedString();
var Severity15 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity15 || {});
var TProblemMatcherPattern15 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var TSeverity15 = Enum(Severity15);
var TProblemMatcher15 = Object2({
  owner: String2(),
  severity: Optional(TSeverity15),
  pattern: Array2(TProblemMatcherPattern15)
});
var TProblemPath15 = Object2({
  path: String2(),
  format: Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
});
var TProblem15 = Object2({
  owner: String2(),
  message: String2(),
  severity: TSeverity15,
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TLayerWithManifest15 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId15,
  associatedWithTaskKey: String2()
});
var BackgroundProcessResultStatus15 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus15 || {});
var BackgroundProcessResultFinishedSubStatus15 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus15 || {});
var TBackgroundProcessResult15 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus15),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus15),
  startedAt: Optional(TDateString15),
  completedAt: Optional(TDateString15),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TTestResultsPath15 = Object2({
  path: String2(),
  options: Optional(Object2({ framework: String2(), language: String2() }))
});
var TTestResults15 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TTaskGeneratedDynamicTask15 = Object2({ sourceFilePath: String2(), source: String2() });
var EnvironmentVariableCacheKey13 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey13 || {});
var TEnvironmentVariables13 = Record(
  String2(),
  Object2({
    value: String2(),
    cacheKey: Enum(EnvironmentVariableCacheKey13)
  })
);
var TTip2 = Object2({
  key: String2(),
  details: TUserMessage
});
var TCachedTaskResult15 = Object2({
  schemaVersion: Literal("v14" /* V14 */),
  expiresAt: Optional(String2()),
  // ISO formatted
  taskId: String2(),
  agentId: String2(),
  exitCode: Number2(),
  startedAt: String2(),
  // ISO formatted
  completedAt: String2(),
  // ISO formatted
  logsId: String2(),
  backgroundProcessResults: Array2(TBackgroundProcessResult15),
  taskSucceeded: Boolean2(),
  exitCodeSuccess: Boolean2(),
  dynamicTasks: Array2(TTaskGeneratedDynamicTask15),
  environmentVariables: TEnvironmentVariables13,
  values: Record(String2(), String2()),
  links: Array2(Object2({ name: String2(), value: String2() })),
  errors: Array2(String2()),
  outputLayers: Array2(TLayerWithManifest15),
  whiteoutLayer: Optional(TLayerWithManifest15),
  filesystemLayers: Array2(TLayerWithManifest15),
  problems: Array2(TProblem15),
  testResults: Array2(TTestResults15),
  artifacts: Array2(TArtifact15),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps7,
  outputRetryActions: Array2(TRetryAction4),
  dockerLayer: Optional(TLayerWithManifest15),
  tips: Array2(TTip2)
});

// ../packages/schema/task-cache/index.ts
var TVersionedCachedTaskResult = Type.Union([
  TCachedTaskResult,
  TCachedTaskResult15,
  TCachedTaskResult14,
  TCachedTaskResult13,
  TCachedTaskResult12,
  TCachedTaskResult11,
  TCachedTaskResult10,
  TCachedTaskResult9,
  TCachedTaskResult8,
  TCachedTaskResult7,
  TCachedTaskResult6,
  TCachedTaskResult5,
  TCachedTaskResult4,
  TCachedTaskResult3,
  TCachedTaskResult2
]);
var TVersionedCachedTaskResultChecker = TypeCompiler.Compile(TVersionedCachedTaskResult);

// ../packages/utils/type-assertions.ts
function assertType(_) {
}
function assertExhaustive(_) {
  throw new Error("not exhaustive");
}
assertType(true);
assertType(true);
assertType(true);
assertType(false);
assertType(false);
assertType(true);
assertType(false);
assertType(true);
assertType(true);
assertType(true);
assertType(true);
assertType(true);
assertType(true);

// ../packages/schema/persisted/versioned/v55.ts
var ThisSchemaVersion = "v55" /* V55 */;
var TTaskOrGroupId16 = TBrandedString();
var TGraphNodeId = TBrandedString();
var TTemplateString = TBrandedString();
var TEvaluatedString = TBrandedString();
var TDateString16 = TBrandedString();
var TEpochSeconds = TBrandedNumber();
var TScopedTaskKey = TBrandedString();
var TaskType = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType || {});
var TaskResultStatus = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus || {});
var TaskExecutionStatus = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus || {});
var TaskExecutionWaitingSubStatus = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus || {});
var TaskExecutionAbortedSubStatus = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus || {});
var TaskExecutionFinishedSubStatus = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus || {});
var TaskAttemptReason = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason || {});
var BackgroundProcessResultStatus16 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus16 || {});
var BackgroundProcessResultFinishedSubStatus16 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus16 || {});
var RunResultStatus = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus || {});
var RunExecutionStatus = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus || {});
var RunExecutionWaitingSubStatus = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus || {});
var RunExecutionAbortedSubStatus = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus || {});
var RunExecutionFinishedSubStatus = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus || {});
var TSource = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey14 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey14 || {});
var TExpandedEnvDescriptor = Object2({ value: Optional(TTemplateString), cacheKey: Enum(EnvironmentVariableCacheKey14) });
var TEnvMergeStrategy = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath16 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern16 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity16 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity16 || {});
var TProblemMatcher16 = Object2({ owner: String2(), severity: Optional(Enum(Severity16)), pattern: Array2(TProblemMatcherPattern16) });
var TProblemPath16 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath = Object2({ key: String2(), path: TTemplateString });
var TResolvedArtifactPath = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck = Object2({ run: TTemplateString, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess = Object2({
  key: String2(),
  command: TTemplateString,
  readyCheck: Optional(TExpandedReadyCheck),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType || {});
var TParallelismValue = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification = Object2({
  cpus: Optional(TTemplateString),
  memory: Optional(TTemplateString),
  disk: Object2({ size: Optional(TTemplateString) }),
  staticIps: Optional(TTemplateString),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs = Object2({
  values: Optional(Record(String2(), TTemplateString)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor = Object2({ path: TTemplateString, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet = Union([TTemplateString, Array2(Union([TTemplateString, TFilterDescriptor]))]);
var TInputFilesystemFilter = Object2({
  workspace: Optional(TFilterSet),
  artifacts: Optional(Record(TTemplateString, TFilterSet))
});
var TOutputFilesystemFilter = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration = Object2({
  enabled: TTemplateString,
  ttl: Optional(TTemplateString)
});
var TTaskDefinitionWithoutParallel = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification),
  type: Optional(Enum(TaskType)),
  after: Optional(TTemplateString),
  if: Optional(TTemplateString),
  source: Optional(TSource),
  cacheConfiguration: TCacheConfiguration,
  docker: Optional(TTemplateString),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString),
  filter: Optional(TInputFilesystemFilter),
  backgroundProcesses: Optional(Array2(TBackgroundProcess)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor)),
  envMerge: Optional(Array2(TEnvMergeStrategy)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath16)),
  artifactPaths: Optional(Array2(TArtifactPath)),
  outputs: Optional(TTaskDefinitionOutputs),
  problemMatchers: Optional(Array2(TProblemMatcher16)),
  problemPaths: Optional(Array2(TProblemPath16)),
  parallelismType: Optional(Enum(ParallelismType)),
  parallelismValue: Optional(TParallelismValue),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter)
});
var TCrossRunSource = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource,
  relativeScopedKey: String2()
});
var TTaskDefinition = Composite([
  TTaskDefinitionWithoutParallel,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel),
    parallelKey: Optional(TTemplateString),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString), TTemplateString]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString)), TTemplateString])),
    parallelismTotal: Optional(TTemplateString)
  })
]);
var TLayerWithManifest16 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerSha256: String2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId16,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext = Union([String2(), Record(String2(), Any())]);
var TUsedSecret = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult16 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus16),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus16),
  startedAt: Optional(TDateString16),
  completedAt: Optional(TDateString16),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem16 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity16),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults16 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest6 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact16 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest6, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor))
      })
    )
  )
});
var TGithubStatusCheck = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow || {});
var TConcurrencyPool = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow) });
var LeaseState = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState || {});
var TTiming8 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps8 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming8)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming8),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming8),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming8.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming8),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming8),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming8),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming8),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming8),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming8),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming8),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming8)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming8.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction5 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact16)
});
var TBaseLayerSpecificationTriple = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId = Object2({
  layerId: String2()
});
var TBaseLayerSpecification = Union([TBaseLayerSpecificationTriple, TBaseLayerSpecificationLayerId]);
var TBaseLayerDescriptor = Composite([
  TBaseLayerSpecificationTriple,
  TBaseLayerSpecificationLayerId,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit || {});
var TTTL = Object2({
  value: Number2(),
  unit: Enum(TTLUnit)
});
var TResolvedCacheConfiguration = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip3 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask = Object2({
  schemaVersion: Literal(ThisSchemaVersion),
  taskId: TTaskOrGroupId16,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId),
  generatorTaskId: Optional(TTaskOrGroupId16),
  definition: TTaskDefinition,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus),
  resultStatus: Enum(TaskResultStatus),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason)),
  resolvedAt: Optional(TDateString16),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString16),
  debugReadyAt: Optional(TDateString16),
  debugStartedAt: Optional(TDateString16),
  debugEndedAt: Optional(TDateString16),
  cancellationRequestedAt: Optional(TDateString16),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString16),
  cancelledAt: Optional(TDateString16),
  concurrencyPool: Optional(TConcurrencyPool),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext),
  usedSecrets: Optional(Array2(TUsedSecret)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString, cacheKey: Enum(EnvironmentVariableCacheKey14) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest16)),
  previousLayers: Optional(Array2(TLayerWithManifest16)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest16)),
  filesystemLayers: Optional(Array2(TLayerWithManifest16)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration),
      baseLayer: TBaseLayerDescriptor,
      crossRunSource: Optional(TCrossRunSource)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult16)),
  whiteoutLayer: Optional(TLayerWithManifest16),
  outputLayers: Optional(Array2(TLayerWithManifest16)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey14) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem16)),
  testResults: Optional(Array2(TTestResults16)),
  artifacts: Optional(Array2(TArtifact16)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents),
  tips: Array2(TTip3),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps8,
  networkTraffic: TNetworkTraffic,
  outputRetryActions: Array2(TRetryAction5),
  retryAction: Optional(TRetryAction5),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest16)
});
var TRetryManifestEntry = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString16,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString16),
  mostRecentlyAttemptedAt: Optional(TDateString16),
  finishedAt: Optional(TDateString16),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots = Object2({ resolution: Array2(TGraphNodeId), runtime: Array2(TGraphNodeId) });
var TRunGraph = Object2({
  roots: TGraphRoots,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId, Array2(TGraphNodeId)),
    runtime: Record(TGraphNodeId, Array2(TGraphNodeId))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId, Array2(TGraphNodeId)),
    runtime: Record(TGraphNodeId, Array2(TGraphNodeId))
  }),
  subgraphs: Record(TGraphNodeId, Object2({ roots: TGraphRoots })),
  parents: Record(TGraphNodeId, TGraphNodeId),
  definitionOrders: Record(TGraphNodeId, Number2())
});
var TActor = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState)
});
var ApprovalRequestState = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState || {});
var TApprovalRequest = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState)
});
var TRun = Object2({
  schemaVersion: Literal(ThisSchemaVersion),
  persistenceExpiresAtSeconds: TEpochSeconds,
  runId: String2(),
  createdAt: TDateString16,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor),
  mintDirectoryArtifact: Optional(TArtifact16),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration),
  eventNumber: Number2(),
  retries: Array2(TRetry),
  approvalRequests: Array2(TApprovalRequest),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey, TConcurrencyPoolState),
  baseLayer: TBaseLayerDescriptor,
  crossRunSource: TCrossRunSource,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus),
  resultStatus: Enum(RunResultStatus),
  waitingForLeaseAt: Optional(TDateString16),
  startedAt: Optional(TDateString16),
  cancellationRequestedAt: Optional(TDateString16),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString16),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/persisted/versioned/latest.ts
var LatestSchemaVersion2 = "v55" /* V55 */;

// ../packages/schema/persisted/versioned/v39.ts
var ThisSchemaVersion2 = "v39" /* V39 */;
var TTaskOrGroupId17 = TBrandedString();
var TGraphNodeId2 = TBrandedString();
var TTemplateString2 = TBrandedString();
var TEvaluatedString2 = TBrandedString();
var TDateString17 = TBrandedString();
var TEpochSeconds2 = TBrandedNumber();
var TScopedTaskKey2 = TBrandedString();
var TaskType2 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType2 || {});
var TaskResultStatus2 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus2 || {});
var TaskExecutionStatus2 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus2 || {});
var TaskExecutionWaitingSubStatus2 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus2 || {});
var TaskExecutionAbortedSubStatus2 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus2 || {});
var TaskExecutionFinishedSubStatus2 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus2 || {});
var TaskAttemptReason2 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason2 || {});
var BackgroundProcessResultStatus17 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus17 || {});
var BackgroundProcessResultFinishedSubStatus17 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus17 || {});
var RunResultStatus2 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus2 || {});
var RunExecutionStatus2 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus2 || {});
var RunExecutionWaitingSubStatus2 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus2 || {});
var RunExecutionAbortedSubStatus2 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus2 || {});
var RunExecutionFinishedSubStatus2 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus2 || {});
var TSource2 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey15 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey15 || {});
var TExpandedEnvDescriptor2 = Object2({ value: Optional(TTemplateString2), cacheKey: Enum(EnvironmentVariableCacheKey15) });
var TEnvMergeStrategy2 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath17 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern17 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity17 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity17 || {});
var TProblemMatcher17 = Object2({ owner: String2(), severity: Optional(Enum(Severity17)), pattern: Array2(TProblemMatcherPattern17) });
var TProblemPath17 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath2 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck2 = Object2({ run: TTemplateString2, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess2 = Object2({
  key: String2(),
  command: TTemplateString2,
  readyCheck: Optional(TExpandedReadyCheck2),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType2 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType2 || {});
var TParallelismValue2 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification2 = Object2({
  cpus: Optional(TTemplateString2),
  memory: Optional(TTemplateString2),
  disk: Object2({ size: Optional(TTemplateString2) }),
  staticIps: Optional(TTemplateString2)
});
var TResolvedAgentSpecification2 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2()))
});
var TTaskDefinitionOutputs2 = Object2({
  values: Optional(Record(String2(), TTemplateString2)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter2 = Object2({
  workspace: Optional(Union([Array2(TTemplateString2), TTemplateString2])),
  artifacts: Optional(Record(TTemplateString2, Union([Array2(TTemplateString2), TTemplateString2])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter2 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel2 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification2),
  type: Optional(Enum(TaskType2)),
  after: Optional(TTemplateString2),
  if: Optional(TTemplateString2),
  source: Optional(TSource2),
  allowCacheHit: Optional(TTemplateString2),
  docker: Optional(TTemplateString2),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString2),
  filter: Optional(TInputFilesystemFilter2),
  backgroundProcesses: Optional(Array2(TBackgroundProcess2)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor2)),
  envMerge: Optional(Array2(TEnvMergeStrategy2)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath17)),
  artifactPaths: Optional(Array2(TArtifactPath2)),
  outputs: Optional(TTaskDefinitionOutputs2),
  problemMatchers: Optional(Array2(TProblemMatcher17)),
  problemPaths: Optional(Array2(TProblemPath17)),
  parallelismType: Optional(Enum(ParallelismType2)),
  parallelismValue: Optional(TParallelismValue2),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString2)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString2),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter2)
});
var TTaskDefinition2 = Composite([
  TTaskDefinitionWithoutParallel2,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel2),
    parallelKey: Optional(TTemplateString2),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString2), TTemplateString2]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString2)), TTemplateString2])),
    parallelismTotal: Optional(TTemplateString2)
  })
]);
var TLayerWithManifest17 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId17,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext2 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret2 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess2 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString2,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString2,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult17 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus17),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus17),
  startedAt: Optional(TDateString17),
  completedAt: Optional(TDateString17),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem17 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity17),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults17 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest7 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact17 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest7, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact2 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration2 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow2 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow2 || {});
var TConcurrencyPool2 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow2) });
var LeaseState2 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState2 || {});
var TTiming9 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps9 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming9)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming9)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming9),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming9),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming9.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming9),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming9),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming9),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming9),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming9),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming9),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming9),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming9)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming9.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic2 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction6 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact17)
});
var TTask2 = Object2({
  schemaVersion: Literal(ThisSchemaVersion2),
  taskId: TTaskOrGroupId17,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId2),
  generatorTaskId: Optional(TTaskOrGroupId17),
  definition: TTaskDefinition2,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus2),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus2),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus2),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus2),
  resultStatus: Enum(TaskResultStatus2),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason2)),
  resolvedAt: Optional(TDateString17),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString17),
  debugReadyAt: Optional(TDateString17),
  debugStartedAt: Optional(TDateString17),
  debugEndedAt: Optional(TDateString17),
  cancellationRequestedAt: Optional(TDateString17),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString17),
  cancelledAt: Optional(TDateString17),
  concurrencyPool: Optional(TConcurrencyPool2),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext2),
  usedSecrets: Optional(Array2(TUsedSecret2)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString2, cacheKey: Enum(EnvironmentVariableCacheKey15) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString2),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess2)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact2)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest17)),
  previousLayers: Optional(Array2(TLayerWithManifest17)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest17)),
  filesystemLayers: Optional(Array2(TLayerWithManifest17)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString2)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration2) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification2),
  accessedVaultIds: Optional(Array2(String2())),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult17)),
  whiteoutLayer: Optional(TLayerWithManifest17),
  outputLayers: Optional(Array2(TLayerWithManifest17)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey15) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem17)),
  testResults: Optional(Array2(TTestResults17)),
  artifacts: Optional(Array2(TArtifact17)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps9,
  networkTraffic: TNetworkTraffic2,
  outputRetryActions: Array2(TRetryAction6),
  retryAction: Optional(TRetryAction6),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  dockerLayer: Optional(TLayerWithManifest17)
});
var TRetryManifestEntry2 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetryTaskRequest = Object2({
  id: String2(),
  createdAt: TDateString17,
  taskId: String2(),
  retryManifest: Optional(Array2(TRetryManifestEntry2)),
  status: String2(),
  lastAttemptedAt: Optional(TDateString17),
  processedAt: Optional(TDateString17),
  message: Optional(String2()),
  newTaskId: Optional(String2()),
  retryActionKey: Optional(String2()),
  debug: Optional(Boolean2())
});
var TRetry2 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString17,
  startedAt: Optional(TDateString17),
  mostRecentlyAttemptedAt: Optional(TDateString17),
  finishedAt: Optional(TDateString17),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots2 = Object2({ resolution: Array2(TGraphNodeId2), runtime: Array2(TGraphNodeId2) });
var TRunGraph2 = Object2({
  roots: TGraphRoots2,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId2, Array2(TGraphNodeId2)),
    runtime: Record(TGraphNodeId2, Array2(TGraphNodeId2))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId2, Array2(TGraphNodeId2)),
    runtime: Record(TGraphNodeId2, Array2(TGraphNodeId2))
  }),
  subgraphs: Record(TGraphNodeId2, Object2({ roots: TGraphRoots2 })),
  parents: Record(TGraphNodeId2, TGraphNodeId2),
  definitionOrders: Record(TGraphNodeId2, Number2())
});
var TActor2 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState2 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState2)
});
var TRun2 = Object2({
  schemaVersion: Literal(ThisSchemaVersion2),
  persistenceExpiresAtSeconds: TEpochSeconds2,
  runId: String2(),
  createdAt: TDateString17,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor2),
  mintDirectoryArtifact: Optional(TArtifact17),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool2),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration2),
  eventNumber: Number2(),
  retryTaskRequests: Array2(TRetryTaskRequest),
  retries: Optional(Array2(TRetry2)),
  retryBatches: Optional(Array2(TRetry2)),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph2,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry2)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey2, TConcurrencyPoolState2),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus2),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus2),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus2),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus2),
  resultStatus: Enum(RunResultStatus2),
  waitingForLeaseAt: Optional(TDateString17),
  startedAt: Optional(TDateString17),
  cancellationRequestedAt: Optional(TDateString17),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString17)
});

// ../packages/schema/persisted/versioned/v40.ts
var ThisSchemaVersion3 = "v40" /* V40 */;
var TTaskOrGroupId18 = TBrandedString();
var TGraphNodeId3 = TBrandedString();
var TTemplateString3 = TBrandedString();
var TEvaluatedString3 = TBrandedString();
var TDateString18 = TBrandedString();
var TEpochSeconds3 = TBrandedNumber();
var TScopedTaskKey3 = TBrandedString();
var TaskType3 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType3 || {});
var TaskResultStatus3 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus3 || {});
var TaskExecutionStatus3 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus3 || {});
var TaskExecutionWaitingSubStatus3 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus3 || {});
var TaskExecutionAbortedSubStatus3 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus3 || {});
var TaskExecutionFinishedSubStatus3 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus3 || {});
var TaskAttemptReason3 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason3 || {});
var BackgroundProcessResultStatus18 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus18 || {});
var BackgroundProcessResultFinishedSubStatus18 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus18 || {});
var RunResultStatus3 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus3 || {});
var RunExecutionStatus3 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus3 || {});
var RunExecutionWaitingSubStatus3 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus3 || {});
var RunExecutionAbortedSubStatus3 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus3 || {});
var RunExecutionFinishedSubStatus3 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus3 || {});
var TSource3 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey16 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey16 || {});
var TExpandedEnvDescriptor3 = Object2({ value: Optional(TTemplateString3), cacheKey: Enum(EnvironmentVariableCacheKey16) });
var TEnvMergeStrategy3 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath18 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern18 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity18 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity18 || {});
var TProblemMatcher18 = Object2({ owner: String2(), severity: Optional(Enum(Severity18)), pattern: Array2(TProblemMatcherPattern18) });
var TProblemPath18 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath3 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck3 = Object2({ run: TTemplateString3, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess3 = Object2({
  key: String2(),
  command: TTemplateString3,
  readyCheck: Optional(TExpandedReadyCheck3),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType3 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType3 || {});
var TParallelismValue3 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification3 = Object2({
  cpus: Optional(TTemplateString3),
  memory: Optional(TTemplateString3),
  disk: Object2({ size: Optional(TTemplateString3) }),
  staticIps: Optional(TTemplateString3),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification3 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs3 = Object2({
  values: Optional(Record(String2(), TTemplateString3)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter3 = Object2({
  workspace: Optional(Union([Array2(TTemplateString3), TTemplateString3])),
  artifacts: Optional(Record(TTemplateString3, Union([Array2(TTemplateString3), TTemplateString3])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter3 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel3 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification3),
  type: Optional(Enum(TaskType3)),
  after: Optional(TTemplateString3),
  if: Optional(TTemplateString3),
  source: Optional(TSource3),
  allowCacheHit: Optional(TTemplateString3),
  docker: Optional(TTemplateString3),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString3),
  filter: Optional(TInputFilesystemFilter3),
  backgroundProcesses: Optional(Array2(TBackgroundProcess3)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor3)),
  envMerge: Optional(Array2(TEnvMergeStrategy3)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath18)),
  artifactPaths: Optional(Array2(TArtifactPath3)),
  outputs: Optional(TTaskDefinitionOutputs3),
  problemMatchers: Optional(Array2(TProblemMatcher18)),
  problemPaths: Optional(Array2(TProblemPath18)),
  parallelismType: Optional(Enum(ParallelismType3)),
  parallelismValue: Optional(TParallelismValue3),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString3)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString3),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter3)
});
var TTaskDefinition3 = Composite([
  TTaskDefinitionWithoutParallel3,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel3),
    parallelKey: Optional(TTemplateString3),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString3), TTemplateString3]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString3)), TTemplateString3])),
    parallelismTotal: Optional(TTemplateString3)
  })
]);
var TLayerWithManifest18 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId18,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext3 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret3 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess3 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString3,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString3,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer2 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult18 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus18),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus18),
  startedAt: Optional(TDateString18),
  completedAt: Optional(TDateString18),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem18 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity18),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults18 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest8 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact18 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest8, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact3 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration3 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow3 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow3 || {});
var TConcurrencyPool3 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow3) });
var LeaseState3 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState3 || {});
var TTiming10 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps10 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming10)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming10)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming10),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming10),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming10.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming10),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming10),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming10),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming10),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming10),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming10),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming10),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming10)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming10.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic3 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction7 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact18)
});
var TTask3 = Object2({
  schemaVersion: Literal(ThisSchemaVersion3),
  taskId: TTaskOrGroupId18,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId3),
  generatorTaskId: Optional(TTaskOrGroupId18),
  definition: TTaskDefinition3,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus3),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus3),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus3),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus3),
  resultStatus: Enum(TaskResultStatus3),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason3)),
  resolvedAt: Optional(TDateString18),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString18),
  debugReadyAt: Optional(TDateString18),
  debugStartedAt: Optional(TDateString18),
  debugEndedAt: Optional(TDateString18),
  cancellationRequestedAt: Optional(TDateString18),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString18),
  cancelledAt: Optional(TDateString18),
  concurrencyPool: Optional(TConcurrencyPool3),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext3),
  usedSecrets: Optional(Array2(TUsedSecret3)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString3, cacheKey: Enum(EnvironmentVariableCacheKey16) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString3),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess3)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact3)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest18)),
  previousLayers: Optional(Array2(TLayerWithManifest18)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest18)),
  filesystemLayers: Optional(Array2(TLayerWithManifest18)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString3)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration3) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification3),
  accessedVaultIds: Optional(Array2(String2())),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult18)),
  whiteoutLayer: Optional(TLayerWithManifest18),
  outputLayers: Optional(Array2(TLayerWithManifest18)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey16) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem18)),
  testResults: Optional(Array2(TTestResults18)),
  artifacts: Optional(Array2(TArtifact18)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps10,
  networkTraffic: TNetworkTraffic3,
  outputRetryActions: Array2(TRetryAction7),
  retryAction: Optional(TRetryAction7),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  dockerLayer: Optional(TLayerWithManifest18)
});
var TRetryManifestEntry3 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry3 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString18,
  startedAt: Optional(TDateString18),
  mostRecentlyAttemptedAt: Optional(TDateString18),
  finishedAt: Optional(TDateString18),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots3 = Object2({ resolution: Array2(TGraphNodeId3), runtime: Array2(TGraphNodeId3) });
var TRunGraph3 = Object2({
  roots: TGraphRoots3,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId3, Array2(TGraphNodeId3)),
    runtime: Record(TGraphNodeId3, Array2(TGraphNodeId3))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId3, Array2(TGraphNodeId3)),
    runtime: Record(TGraphNodeId3, Array2(TGraphNodeId3))
  }),
  subgraphs: Record(TGraphNodeId3, Object2({ roots: TGraphRoots3 })),
  parents: Record(TGraphNodeId3, TGraphNodeId3),
  definitionOrders: Record(TGraphNodeId3, Number2())
});
var TActor3 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState3 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState3)
});
var TRun3 = Object2({
  schemaVersion: Literal(ThisSchemaVersion3),
  persistenceExpiresAtSeconds: TEpochSeconds3,
  runId: String2(),
  createdAt: TDateString18,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor3),
  mintDirectoryArtifact: Optional(TArtifact18),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool3),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration3),
  eventNumber: Number2(),
  retries: Array2(TRetry3),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph3,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry3)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey3, TConcurrencyPoolState3),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus3),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus3),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus3),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus3),
  resultStatus: Enum(RunResultStatus3),
  waitingForLeaseAt: Optional(TDateString18),
  startedAt: Optional(TDateString18),
  cancellationRequestedAt: Optional(TDateString18),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString18)
});

// ../packages/schema/persisted/versioned/v41.ts
var ThisSchemaVersion4 = "v41" /* V41 */;
var TTaskOrGroupId19 = TBrandedString();
var TGraphNodeId4 = TBrandedString();
var TTemplateString4 = TBrandedString();
var TEvaluatedString4 = TBrandedString();
var TDateString19 = TBrandedString();
var TEpochSeconds4 = TBrandedNumber();
var TScopedTaskKey4 = TBrandedString();
var TaskType4 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType4 || {});
var TaskResultStatus4 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus4 || {});
var TaskExecutionStatus4 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus4 || {});
var TaskExecutionWaitingSubStatus4 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus4 || {});
var TaskExecutionAbortedSubStatus4 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus4 || {});
var TaskExecutionFinishedSubStatus4 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus4 || {});
var TaskAttemptReason4 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason4 || {});
var BackgroundProcessResultStatus19 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus19 || {});
var BackgroundProcessResultFinishedSubStatus19 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus19 || {});
var RunResultStatus4 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus4 || {});
var RunExecutionStatus4 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus4 || {});
var RunExecutionWaitingSubStatus4 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus4 || {});
var RunExecutionAbortedSubStatus4 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus4 || {});
var RunExecutionFinishedSubStatus4 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus4 || {});
var TSource4 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey17 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey17 || {});
var TExpandedEnvDescriptor4 = Object2({ value: Optional(TTemplateString4), cacheKey: Enum(EnvironmentVariableCacheKey17) });
var TEnvMergeStrategy4 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath19 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern19 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity19 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity19 || {});
var TProblemMatcher19 = Object2({ owner: String2(), severity: Optional(Enum(Severity19)), pattern: Array2(TProblemMatcherPattern19) });
var TProblemPath19 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath4 = Object2({ key: String2(), path: TTemplateString4 });
var TResolvedArtifactPath2 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck4 = Object2({ run: TTemplateString4, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess4 = Object2({
  key: String2(),
  command: TTemplateString4,
  readyCheck: Optional(TExpandedReadyCheck4),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType4 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType4 || {});
var TParallelismValue4 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification4 = Object2({
  cpus: Optional(TTemplateString4),
  memory: Optional(TTemplateString4),
  disk: Object2({ size: Optional(TTemplateString4) }),
  staticIps: Optional(TTemplateString4),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification4 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs4 = Object2({
  values: Optional(Record(String2(), TTemplateString4)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter4 = Object2({
  workspace: Optional(Union([Array2(TTemplateString4), TTemplateString4])),
  artifacts: Optional(Record(TTemplateString4, Union([Array2(TTemplateString4), TTemplateString4])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter4 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel4 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification4),
  type: Optional(Enum(TaskType4)),
  after: Optional(TTemplateString4),
  if: Optional(TTemplateString4),
  source: Optional(TSource4),
  allowCacheHit: Optional(TTemplateString4),
  docker: Optional(TTemplateString4),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString4),
  filter: Optional(TInputFilesystemFilter4),
  backgroundProcesses: Optional(Array2(TBackgroundProcess4)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor4)),
  envMerge: Optional(Array2(TEnvMergeStrategy4)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath19)),
  artifactPaths: Optional(Array2(TArtifactPath4)),
  outputs: Optional(TTaskDefinitionOutputs4),
  problemMatchers: Optional(Array2(TProblemMatcher19)),
  problemPaths: Optional(Array2(TProblemPath19)),
  parallelismType: Optional(Enum(ParallelismType4)),
  parallelismValue: Optional(TParallelismValue4),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString4)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString4),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter4)
});
var TTaskDefinition4 = Composite([
  TTaskDefinitionWithoutParallel4,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel4),
    parallelKey: Optional(TTemplateString4),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString4), TTemplateString4]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString4)), TTemplateString4])),
    parallelismTotal: Optional(TTemplateString4)
  })
]);
var TLayerWithManifest19 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId19,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext4 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret4 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess4 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString4,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString4,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer3 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult19 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus19),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus19),
  startedAt: Optional(TDateString19),
  completedAt: Optional(TDateString19),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem19 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity19),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults19 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest9 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact19 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest9, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact4 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration4 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow4 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow4 || {});
var TConcurrencyPool4 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow4) });
var LeaseState4 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState4 || {});
var TTiming11 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps11 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming11)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming11)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming11),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming11),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming11.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming11),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming11),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming11),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming11),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming11),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming11),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming11),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming11)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming11.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic4 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction8 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact19)
});
var TTask4 = Object2({
  schemaVersion: Literal(ThisSchemaVersion4),
  taskId: TTaskOrGroupId19,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId4),
  generatorTaskId: Optional(TTaskOrGroupId19),
  definition: TTaskDefinition4,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus4),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus4),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus4),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus4),
  resultStatus: Enum(TaskResultStatus4),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason4)),
  resolvedAt: Optional(TDateString19),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString19),
  debugReadyAt: Optional(TDateString19),
  debugStartedAt: Optional(TDateString19),
  debugEndedAt: Optional(TDateString19),
  cancellationRequestedAt: Optional(TDateString19),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString19),
  cancelledAt: Optional(TDateString19),
  concurrencyPool: Optional(TConcurrencyPool4),
  waitingForApprovalOnVaults: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext4),
  usedSecrets: Optional(Array2(TUsedSecret4)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString4, cacheKey: Enum(EnvironmentVariableCacheKey17) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString4),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess4)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact4)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest19)),
  previousLayers: Optional(Array2(TLayerWithManifest19)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest19)),
  filesystemLayers: Optional(Array2(TLayerWithManifest19)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString4)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration4) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification4),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath2)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult19)),
  whiteoutLayer: Optional(TLayerWithManifest19),
  outputLayers: Optional(Array2(TLayerWithManifest19)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey17) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem19)),
  testResults: Optional(Array2(TTestResults19)),
  artifacts: Optional(Array2(TArtifact19)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps11,
  networkTraffic: TNetworkTraffic4,
  outputRetryActions: Array2(TRetryAction8),
  retryAction: Optional(TRetryAction8),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest19)
});
var TRetryManifestEntry4 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry4 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString19,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString19),
  mostRecentlyAttemptedAt: Optional(TDateString19),
  finishedAt: Optional(TDateString19),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots4 = Object2({ resolution: Array2(TGraphNodeId4), runtime: Array2(TGraphNodeId4) });
var TRunGraph4 = Object2({
  roots: TGraphRoots4,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId4, Array2(TGraphNodeId4)),
    runtime: Record(TGraphNodeId4, Array2(TGraphNodeId4))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId4, Array2(TGraphNodeId4)),
    runtime: Record(TGraphNodeId4, Array2(TGraphNodeId4))
  }),
  subgraphs: Record(TGraphNodeId4, Object2({ roots: TGraphRoots4 })),
  parents: Record(TGraphNodeId4, TGraphNodeId4),
  definitionOrders: Record(TGraphNodeId4, Number2())
});
var TActor4 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState4 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState4)
});
var TRun4 = Object2({
  schemaVersion: Literal(ThisSchemaVersion4),
  persistenceExpiresAtSeconds: TEpochSeconds4,
  runId: String2(),
  createdAt: TDateString19,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor4),
  mintDirectoryArtifact: Optional(TArtifact19),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool4),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration4),
  eventNumber: Number2(),
  retries: Array2(TRetry4),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph4,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry4)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey4, TConcurrencyPoolState4),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus4),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus4),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus4),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus4),
  resultStatus: Enum(RunResultStatus4),
  waitingForLeaseAt: Optional(TDateString19),
  startedAt: Optional(TDateString19),
  cancellationRequestedAt: Optional(TDateString19),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString19)
});

// ../packages/schema/persisted/versioned/v42.ts
var ThisSchemaVersion5 = "v42" /* V42 */;
var TTaskOrGroupId20 = TBrandedString();
var TGraphNodeId5 = TBrandedString();
var TTemplateString5 = TBrandedString();
var TEvaluatedString5 = TBrandedString();
var TDateString20 = TBrandedString();
var TEpochSeconds5 = TBrandedNumber();
var TScopedTaskKey5 = TBrandedString();
var TaskType5 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType5 || {});
var TaskResultStatus5 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus5 || {});
var TaskExecutionStatus5 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus5 || {});
var TaskExecutionWaitingSubStatus5 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus5 || {});
var TaskExecutionAbortedSubStatus5 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus5 || {});
var TaskExecutionFinishedSubStatus5 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus5 || {});
var TaskAttemptReason5 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason5 || {});
var BackgroundProcessResultStatus20 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus20 || {});
var BackgroundProcessResultFinishedSubStatus20 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus20 || {});
var RunResultStatus5 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus5 || {});
var RunExecutionStatus5 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus5 || {});
var RunExecutionWaitingSubStatus5 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus5 || {});
var RunExecutionAbortedSubStatus5 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus5 || {});
var RunExecutionFinishedSubStatus5 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus5 || {});
var TSource5 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey18 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey18 || {});
var TExpandedEnvDescriptor5 = Object2({ value: Optional(TTemplateString5), cacheKey: Enum(EnvironmentVariableCacheKey18) });
var TEnvMergeStrategy5 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath20 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern20 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity20 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity20 || {});
var TProblemMatcher20 = Object2({ owner: String2(), severity: Optional(Enum(Severity20)), pattern: Array2(TProblemMatcherPattern20) });
var TProblemPath20 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath5 = Object2({ key: String2(), path: TTemplateString5 });
var TResolvedArtifactPath3 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck5 = Object2({ run: TTemplateString5, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess5 = Object2({
  key: String2(),
  command: TTemplateString5,
  readyCheck: Optional(TExpandedReadyCheck5),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType5 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType5 || {});
var TParallelismValue5 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification5 = Object2({
  cpus: Optional(TTemplateString5),
  memory: Optional(TTemplateString5),
  disk: Object2({ size: Optional(TTemplateString5) }),
  staticIps: Optional(TTemplateString5),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification5 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs5 = Object2({
  values: Optional(Record(String2(), TTemplateString5)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter5 = Object2({
  workspace: Optional(Union([Array2(TTemplateString5), TTemplateString5])),
  artifacts: Optional(Record(TTemplateString5, Union([Array2(TTemplateString5), TTemplateString5])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter5 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel5 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification5),
  type: Optional(Enum(TaskType5)),
  after: Optional(TTemplateString5),
  if: Optional(TTemplateString5),
  source: Optional(TSource5),
  allowCacheHit: Optional(TTemplateString5),
  docker: Optional(TTemplateString5),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString5),
  filter: Optional(TInputFilesystemFilter5),
  backgroundProcesses: Optional(Array2(TBackgroundProcess5)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor5)),
  envMerge: Optional(Array2(TEnvMergeStrategy5)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath20)),
  artifactPaths: Optional(Array2(TArtifactPath5)),
  outputs: Optional(TTaskDefinitionOutputs5),
  problemMatchers: Optional(Array2(TProblemMatcher20)),
  problemPaths: Optional(Array2(TProblemPath20)),
  parallelismType: Optional(Enum(ParallelismType5)),
  parallelismValue: Optional(TParallelismValue5),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString5)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString5),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter5)
});
var TTaskDefinition5 = Composite([
  TTaskDefinitionWithoutParallel5,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel5),
    parallelKey: Optional(TTemplateString5),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString5), TTemplateString5]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString5)), TTemplateString5])),
    parallelismTotal: Optional(TTemplateString5)
  })
]);
var TLayerWithManifest20 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId20,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext5 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret5 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess5 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString5,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString5,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer4 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult20 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus20),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus20),
  startedAt: Optional(TDateString20),
  completedAt: Optional(TDateString20),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem20 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity20),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults20 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest10 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact20 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest10, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact5 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration5 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow5 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow5 || {});
var TConcurrencyPool5 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow5) });
var LeaseState5 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState5 || {});
var TTiming12 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps12 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming12)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming12)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming12),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming12),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming12.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming12),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming12),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming12),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming12),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming12),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming12),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming12),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming12)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming12.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic5 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction9 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact20)
});
var TTask5 = Object2({
  schemaVersion: Literal(ThisSchemaVersion5),
  taskId: TTaskOrGroupId20,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId5),
  generatorTaskId: Optional(TTaskOrGroupId20),
  definition: TTaskDefinition5,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus5),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus5),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus5),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus5),
  resultStatus: Enum(TaskResultStatus5),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason5)),
  resolvedAt: Optional(TDateString20),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString20),
  debugReadyAt: Optional(TDateString20),
  debugStartedAt: Optional(TDateString20),
  debugEndedAt: Optional(TDateString20),
  cancellationRequestedAt: Optional(TDateString20),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString20),
  cancelledAt: Optional(TDateString20),
  concurrencyPool: Optional(TConcurrencyPool5),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext5),
  usedSecrets: Optional(Array2(TUsedSecret5)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString5, cacheKey: Enum(EnvironmentVariableCacheKey18) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString5),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess5)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact5)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest20)),
  previousLayers: Optional(Array2(TLayerWithManifest20)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest20)),
  filesystemLayers: Optional(Array2(TLayerWithManifest20)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString5)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration5) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification5),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath3)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult20)),
  whiteoutLayer: Optional(TLayerWithManifest20),
  outputLayers: Optional(Array2(TLayerWithManifest20)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey18) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem20)),
  testResults: Optional(Array2(TTestResults20)),
  artifacts: Optional(Array2(TArtifact20)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps12,
  networkTraffic: TNetworkTraffic5,
  outputRetryActions: Array2(TRetryAction9),
  retryAction: Optional(TRetryAction9),
  retryDebug: Optional(Boolean2()),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest20)
});
var TRetryManifestEntry5 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry5 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString20,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString20),
  mostRecentlyAttemptedAt: Optional(TDateString20),
  finishedAt: Optional(TDateString20),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Boolean2(),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots5 = Object2({ resolution: Array2(TGraphNodeId5), runtime: Array2(TGraphNodeId5) });
var TRunGraph5 = Object2({
  roots: TGraphRoots5,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId5, Array2(TGraphNodeId5)),
    runtime: Record(TGraphNodeId5, Array2(TGraphNodeId5))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId5, Array2(TGraphNodeId5)),
    runtime: Record(TGraphNodeId5, Array2(TGraphNodeId5))
  }),
  subgraphs: Record(TGraphNodeId5, Object2({ roots: TGraphRoots5 })),
  parents: Record(TGraphNodeId5, TGraphNodeId5),
  definitionOrders: Record(TGraphNodeId5, Number2())
});
var TActor5 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState5 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState5)
});
var ApprovalRequestState2 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState2 || {});
var TApprovalRequest2 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState2)
});
var TRun5 = Object2({
  schemaVersion: Literal(ThisSchemaVersion5),
  persistenceExpiresAtSeconds: TEpochSeconds5,
  runId: String2(),
  createdAt: TDateString20,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor5),
  mintDirectoryArtifact: Optional(TArtifact20),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool5),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration5),
  eventNumber: Number2(),
  retries: Array2(TRetry5),
  approvalRequests: Array2(TApprovalRequest2),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph5,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry5)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey5, TConcurrencyPoolState5),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus5),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus5),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus5),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus5),
  resultStatus: Enum(RunResultStatus5),
  waitingForLeaseAt: Optional(TDateString20),
  startedAt: Optional(TDateString20),
  cancellationRequestedAt: Optional(TDateString20),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString20)
});

// ../packages/schema/persisted/versioned/v43.ts
var ThisSchemaVersion6 = "v43" /* V43 */;
var TTaskOrGroupId21 = TBrandedString();
var TGraphNodeId6 = TBrandedString();
var TTemplateString6 = TBrandedString();
var TEvaluatedString6 = TBrandedString();
var TDateString21 = TBrandedString();
var TEpochSeconds6 = TBrandedNumber();
var TScopedTaskKey6 = TBrandedString();
var TaskType6 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType6 || {});
var TaskResultStatus6 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus6 || {});
var TaskExecutionStatus6 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus6 || {});
var TaskExecutionWaitingSubStatus6 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus6 || {});
var TaskExecutionAbortedSubStatus6 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus6 || {});
var TaskExecutionFinishedSubStatus6 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus6 || {});
var TaskAttemptReason6 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason6 || {});
var BackgroundProcessResultStatus21 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus21 || {});
var BackgroundProcessResultFinishedSubStatus21 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus21 || {});
var RunResultStatus6 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus6 || {});
var RunExecutionStatus6 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus6 || {});
var RunExecutionWaitingSubStatus6 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus6 || {});
var RunExecutionAbortedSubStatus6 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus6 || {});
var RunExecutionFinishedSubStatus6 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus6 || {});
var TSource6 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey19 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey19 || {});
var TExpandedEnvDescriptor6 = Object2({ value: Optional(TTemplateString6), cacheKey: Enum(EnvironmentVariableCacheKey19) });
var TEnvMergeStrategy6 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath21 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern21 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity21 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity21 || {});
var TProblemMatcher21 = Object2({ owner: String2(), severity: Optional(Enum(Severity21)), pattern: Array2(TProblemMatcherPattern21) });
var TProblemPath21 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath6 = Object2({ key: String2(), path: TTemplateString6 });
var TResolvedArtifactPath4 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck6 = Object2({ run: TTemplateString6, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess6 = Object2({
  key: String2(),
  command: TTemplateString6,
  readyCheck: Optional(TExpandedReadyCheck6),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType6 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType6 || {});
var TParallelismValue6 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification6 = Object2({
  cpus: Optional(TTemplateString6),
  memory: Optional(TTemplateString6),
  disk: Object2({ size: Optional(TTemplateString6) }),
  staticIps: Optional(TTemplateString6),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification6 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs6 = Object2({
  values: Optional(Record(String2(), TTemplateString6)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter6 = Object2({
  workspace: Optional(Union([Array2(TTemplateString6), TTemplateString6])),
  artifacts: Optional(Record(TTemplateString6, Union([Array2(TTemplateString6), TTemplateString6])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter6 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel6 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification6),
  type: Optional(Enum(TaskType6)),
  after: Optional(TTemplateString6),
  if: Optional(TTemplateString6),
  source: Optional(TSource6),
  allowCacheHit: Optional(TTemplateString6),
  docker: Optional(TTemplateString6),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString6),
  filter: Optional(TInputFilesystemFilter6),
  backgroundProcesses: Optional(Array2(TBackgroundProcess6)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor6)),
  envMerge: Optional(Array2(TEnvMergeStrategy6)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath21)),
  artifactPaths: Optional(Array2(TArtifactPath6)),
  outputs: Optional(TTaskDefinitionOutputs6),
  problemMatchers: Optional(Array2(TProblemMatcher21)),
  problemPaths: Optional(Array2(TProblemPath21)),
  parallelismType: Optional(Enum(ParallelismType6)),
  parallelismValue: Optional(TParallelismValue6),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString6)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString6),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter6)
});
var TTaskDefinition6 = Composite([
  TTaskDefinitionWithoutParallel6,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel6),
    parallelKey: Optional(TTemplateString6),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString6), TTemplateString6]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString6)), TTemplateString6])),
    parallelismTotal: Optional(TTemplateString6)
  })
]);
var TLayerWithManifest21 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId21,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext6 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret6 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess6 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString6,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString6,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer5 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult21 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus21),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus21),
  startedAt: Optional(TDateString21),
  completedAt: Optional(TDateString21),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem21 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity21),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults21 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest11 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact21 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest11, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact6 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration6 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow6 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow6 || {});
var TConcurrencyPool6 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow6) });
var LeaseState6 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState6 || {});
var TTiming13 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps13 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming13)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming13)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming13),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming13),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming13.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming13),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming13),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming13),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming13),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming13),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming13),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming13),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming13)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming13.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic6 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction10 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact21)
});
var TTask6 = Object2({
  schemaVersion: Literal(ThisSchemaVersion6),
  taskId: TTaskOrGroupId21,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId6),
  generatorTaskId: Optional(TTaskOrGroupId21),
  definition: TTaskDefinition6,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus6),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus6),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus6),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus6),
  resultStatus: Enum(TaskResultStatus6),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason6)),
  resolvedAt: Optional(TDateString21),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString21),
  debugReadyAt: Optional(TDateString21),
  debugStartedAt: Optional(TDateString21),
  debugEndedAt: Optional(TDateString21),
  cancellationRequestedAt: Optional(TDateString21),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString21),
  cancelledAt: Optional(TDateString21),
  concurrencyPool: Optional(TConcurrencyPool6),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext6),
  usedSecrets: Optional(Array2(TUsedSecret6)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString6, cacheKey: Enum(EnvironmentVariableCacheKey19) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString6),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess6)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact6)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest21)),
  previousLayers: Optional(Array2(TLayerWithManifest21)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest21)),
  filesystemLayers: Optional(Array2(TLayerWithManifest21)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString6)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration6) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification6),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath4)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult21)),
  whiteoutLayer: Optional(TLayerWithManifest21),
  outputLayers: Optional(Array2(TLayerWithManifest21)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey19) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem21)),
  testResults: Optional(Array2(TTestResults21)),
  artifacts: Optional(Array2(TArtifact21)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps13,
  networkTraffic: TNetworkTraffic6,
  outputRetryActions: Array2(TRetryAction10),
  retryAction: Optional(TRetryAction10),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest21)
});
var TRetryManifestEntry6 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry6 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString21,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString21),
  mostRecentlyAttemptedAt: Optional(TDateString21),
  finishedAt: Optional(TDateString21),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots6 = Object2({ resolution: Array2(TGraphNodeId6), runtime: Array2(TGraphNodeId6) });
var TRunGraph6 = Object2({
  roots: TGraphRoots6,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId6, Array2(TGraphNodeId6)),
    runtime: Record(TGraphNodeId6, Array2(TGraphNodeId6))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId6, Array2(TGraphNodeId6)),
    runtime: Record(TGraphNodeId6, Array2(TGraphNodeId6))
  }),
  subgraphs: Record(TGraphNodeId6, Object2({ roots: TGraphRoots6 })),
  parents: Record(TGraphNodeId6, TGraphNodeId6),
  definitionOrders: Record(TGraphNodeId6, Number2())
});
var TActor6 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState6 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState6)
});
var ApprovalRequestState3 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState3 || {});
var TApprovalRequest3 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState3)
});
var TRun6 = Object2({
  schemaVersion: Literal(ThisSchemaVersion6),
  persistenceExpiresAtSeconds: TEpochSeconds6,
  runId: String2(),
  createdAt: TDateString21,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor6),
  mintDirectoryArtifact: Optional(TArtifact21),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool6),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration6),
  eventNumber: Number2(),
  retries: Array2(TRetry6),
  approvalRequests: Array2(TApprovalRequest3),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph6,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry6)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey6, TConcurrencyPoolState6),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer5,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus6),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus6),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus6),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus6),
  resultStatus: Enum(RunResultStatus6),
  waitingForLeaseAt: Optional(TDateString21),
  startedAt: Optional(TDateString21),
  cancellationRequestedAt: Optional(TDateString21),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString21)
});

// ../packages/schema/persisted/versioned/v44.ts
var ThisSchemaVersion7 = "v44" /* V44 */;
var TTaskOrGroupId22 = TBrandedString();
var TGraphNodeId7 = TBrandedString();
var TTemplateString7 = TBrandedString();
var TEvaluatedString7 = TBrandedString();
var TDateString22 = TBrandedString();
var TEpochSeconds7 = TBrandedNumber();
var TScopedTaskKey7 = TBrandedString();
var TaskType7 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType7 || {});
var TaskResultStatus7 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus7 || {});
var TaskExecutionStatus7 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus7 || {});
var TaskExecutionWaitingSubStatus7 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus7 || {});
var TaskExecutionAbortedSubStatus7 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus7 || {});
var TaskExecutionFinishedSubStatus7 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus7 || {});
var TaskAttemptReason7 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason7 || {});
var BackgroundProcessResultStatus22 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus22 || {});
var BackgroundProcessResultFinishedSubStatus22 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus22 || {});
var RunResultStatus7 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus7 || {});
var RunExecutionStatus7 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus7 || {});
var RunExecutionWaitingSubStatus7 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus7 || {});
var RunExecutionAbortedSubStatus7 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus7 || {});
var RunExecutionFinishedSubStatus7 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus7 || {});
var TSource7 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey20 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey20 || {});
var TExpandedEnvDescriptor7 = Object2({ value: Optional(TTemplateString7), cacheKey: Enum(EnvironmentVariableCacheKey20) });
var TEnvMergeStrategy7 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath22 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern22 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity22 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity22 || {});
var TProblemMatcher22 = Object2({ owner: String2(), severity: Optional(Enum(Severity22)), pattern: Array2(TProblemMatcherPattern22) });
var TProblemPath22 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath7 = Object2({ key: String2(), path: TTemplateString7 });
var TResolvedArtifactPath5 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck7 = Object2({ run: TTemplateString7, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess7 = Object2({
  key: String2(),
  command: TTemplateString7,
  readyCheck: Optional(TExpandedReadyCheck7),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType7 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType7 || {});
var TParallelismValue7 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification7 = Object2({
  cpus: Optional(TTemplateString7),
  memory: Optional(TTemplateString7),
  disk: Object2({ size: Optional(TTemplateString7) }),
  staticIps: Optional(TTemplateString7),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification7 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs7 = Object2({
  values: Optional(Record(String2(), TTemplateString7)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter7 = Object2({
  workspace: Optional(Union([Array2(TTemplateString7), TTemplateString7])),
  artifacts: Optional(Record(TTemplateString7, Union([Array2(TTemplateString7), TTemplateString7])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter7 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel7 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification7),
  type: Optional(Enum(TaskType7)),
  after: Optional(TTemplateString7),
  if: Optional(TTemplateString7),
  source: Optional(TSource7),
  allowCacheHit: Optional(TTemplateString7),
  docker: Optional(TTemplateString7),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString7),
  filter: Optional(TInputFilesystemFilter7),
  backgroundProcesses: Optional(Array2(TBackgroundProcess7)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor7)),
  envMerge: Optional(Array2(TEnvMergeStrategy7)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath22)),
  artifactPaths: Optional(Array2(TArtifactPath7)),
  outputs: Optional(TTaskDefinitionOutputs7),
  problemMatchers: Optional(Array2(TProblemMatcher22)),
  problemPaths: Optional(Array2(TProblemPath22)),
  parallelismType: Optional(Enum(ParallelismType7)),
  parallelismValue: Optional(TParallelismValue7),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString7)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString7),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter7)
});
var TTaskDefinition7 = Composite([
  TTaskDefinitionWithoutParallel7,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel7),
    parallelKey: Optional(TTemplateString7),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString7), TTemplateString7]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString7)), TTemplateString7])),
    parallelismTotal: Optional(TTemplateString7)
  })
]);
var TLayerWithManifest22 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId22,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext7 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret7 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess7 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString7,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString7,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBaseLayer6 = Object2({ layerId: String2(), layerSizeBytes: Number2() });
var TBackgroundProcessResult22 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus22),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus22),
  startedAt: Optional(TDateString22),
  completedAt: Optional(TDateString22),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem22 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity22),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults22 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest12 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact22 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest12, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact7 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration7 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow7 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow7 || {});
var TConcurrencyPool7 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow7) });
var LeaseState7 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState7 || {});
var TTiming14 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps14 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming14)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming14)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming14),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming14),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming14.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming14),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming14),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming14),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming14),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming14),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming14),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming14),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming14)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming14.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic7 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction11 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact22)
});
var TTask7 = Object2({
  schemaVersion: Literal(ThisSchemaVersion7),
  taskId: TTaskOrGroupId22,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId7),
  generatorTaskId: Optional(TTaskOrGroupId22),
  definition: TTaskDefinition7,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus7),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus7),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus7),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus7),
  resultStatus: Enum(TaskResultStatus7),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason7)),
  resolvedAt: Optional(TDateString22),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString22),
  debugReadyAt: Optional(TDateString22),
  debugStartedAt: Optional(TDateString22),
  debugEndedAt: Optional(TDateString22),
  cancellationRequestedAt: Optional(TDateString22),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString22),
  cancelledAt: Optional(TDateString22),
  concurrencyPool: Optional(TConcurrencyPool7),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext7),
  usedSecrets: Optional(Array2(TUsedSecret7)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString7, cacheKey: Enum(EnvironmentVariableCacheKey20) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString7),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess7)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact7)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest22)),
  previousLayers: Optional(Array2(TLayerWithManifest22)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest22)),
  filesystemLayers: Optional(Array2(TLayerWithManifest22)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString7)),
  resolvedRun: Optional(Object2({ toolCacheConfiguration: Optional(TRunToolCacheConfiguration7) })),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification7),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath5)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult22)),
  whiteoutLayer: Optional(TLayerWithManifest22),
  outputLayers: Optional(Array2(TLayerWithManifest22)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey20) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem22)),
  testResults: Optional(Array2(TTestResults22)),
  artifacts: Optional(Array2(TArtifact22)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps14,
  networkTraffic: TNetworkTraffic7,
  outputRetryActions: Array2(TRetryAction11),
  retryAction: Optional(TRetryAction11),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest22)
});
var TRetryManifestEntry7 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry7 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString22,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString22),
  mostRecentlyAttemptedAt: Optional(TDateString22),
  finishedAt: Optional(TDateString22),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots7 = Object2({ resolution: Array2(TGraphNodeId7), runtime: Array2(TGraphNodeId7) });
var TRunGraph7 = Object2({
  roots: TGraphRoots7,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId7, Array2(TGraphNodeId7)),
    runtime: Record(TGraphNodeId7, Array2(TGraphNodeId7))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId7, Array2(TGraphNodeId7)),
    runtime: Record(TGraphNodeId7, Array2(TGraphNodeId7))
  }),
  subgraphs: Record(TGraphNodeId7, Object2({ roots: TGraphRoots7 })),
  parents: Record(TGraphNodeId7, TGraphNodeId7),
  definitionOrders: Record(TGraphNodeId7, Number2())
});
var TActor7 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState7 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState7)
});
var ApprovalRequestState4 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState4 || {});
var TApprovalRequest4 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState4)
});
var TRun7 = Object2({
  schemaVersion: Literal(ThisSchemaVersion7),
  persistenceExpiresAtSeconds: TEpochSeconds7,
  runId: String2(),
  createdAt: TDateString22,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor7),
  mintDirectoryArtifact: Optional(TArtifact22),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool7),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration7),
  eventNumber: Number2(),
  retries: Array2(TRetry7),
  approvalRequests: Array2(TApprovalRequest4),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph7,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry7)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey7, TConcurrencyPoolState7),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayer6,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus7),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus7),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus7),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus7),
  resultStatus: Enum(RunResultStatus7),
  waitingForLeaseAt: Optional(TDateString22),
  startedAt: Optional(TDateString22),
  cancellationRequestedAt: Optional(TDateString22),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString22)
});

// ../packages/schema/persisted/versioned/v45.ts
var ThisSchemaVersion8 = "v45" /* V45 */;
var TTaskOrGroupId23 = TBrandedString();
var TGraphNodeId8 = TBrandedString();
var TTemplateString8 = TBrandedString();
var TEvaluatedString8 = TBrandedString();
var TDateString23 = TBrandedString();
var TEpochSeconds8 = TBrandedNumber();
var TScopedTaskKey8 = TBrandedString();
var TaskType8 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType8 || {});
var TaskResultStatus8 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus8 || {});
var TaskExecutionStatus8 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus8 || {});
var TaskExecutionWaitingSubStatus8 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus8 || {});
var TaskExecutionAbortedSubStatus8 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus8 || {});
var TaskExecutionFinishedSubStatus8 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus8 || {});
var TaskAttemptReason8 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason8 || {});
var BackgroundProcessResultStatus23 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus23 || {});
var BackgroundProcessResultFinishedSubStatus23 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus23 || {});
var RunResultStatus8 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus8 || {});
var RunExecutionStatus8 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus8 || {});
var RunExecutionWaitingSubStatus8 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus8 || {});
var RunExecutionAbortedSubStatus8 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus8 || {});
var RunExecutionFinishedSubStatus8 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus8 || {});
var TSource8 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey21 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey21 || {});
var TExpandedEnvDescriptor8 = Object2({ value: Optional(TTemplateString8), cacheKey: Enum(EnvironmentVariableCacheKey21) });
var TEnvMergeStrategy8 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath23 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern23 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity23 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity23 || {});
var TProblemMatcher23 = Object2({ owner: String2(), severity: Optional(Enum(Severity23)), pattern: Array2(TProblemMatcherPattern23) });
var TProblemPath23 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath8 = Object2({ key: String2(), path: TTemplateString8 });
var TResolvedArtifactPath6 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck8 = Object2({ run: TTemplateString8, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess8 = Object2({
  key: String2(),
  command: TTemplateString8,
  readyCheck: Optional(TExpandedReadyCheck8),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType8 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType8 || {});
var TParallelismValue8 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification8 = Object2({
  cpus: Optional(TTemplateString8),
  memory: Optional(TTemplateString8),
  disk: Object2({ size: Optional(TTemplateString8) }),
  staticIps: Optional(TTemplateString8),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification8 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs8 = Object2({
  values: Optional(Record(String2(), TTemplateString8)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter8 = Object2({
  workspace: Optional(Union([Array2(TTemplateString8), TTemplateString8])),
  artifacts: Optional(Record(TTemplateString8, Union([Array2(TTemplateString8), TTemplateString8])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter8 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TTaskDefinitionWithoutParallel8 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification8),
  type: Optional(Enum(TaskType8)),
  after: Optional(TTemplateString8),
  if: Optional(TTemplateString8),
  source: Optional(TSource8),
  allowCacheHit: Optional(TTemplateString8),
  docker: Optional(TTemplateString8),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString8),
  filter: Optional(TInputFilesystemFilter8),
  backgroundProcesses: Optional(Array2(TBackgroundProcess8)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor8)),
  envMerge: Optional(Array2(TEnvMergeStrategy8)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath23)),
  artifactPaths: Optional(Array2(TArtifactPath8)),
  outputs: Optional(TTaskDefinitionOutputs8),
  problemMatchers: Optional(Array2(TProblemMatcher23)),
  problemPaths: Optional(Array2(TProblemPath23)),
  parallelismType: Optional(Enum(ParallelismType8)),
  parallelismValue: Optional(TParallelismValue8),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString8)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString8),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter8)
});
var TTaskDefinition8 = Composite([
  TTaskDefinitionWithoutParallel8,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel8),
    parallelKey: Optional(TTemplateString8),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString8), TTemplateString8]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString8)), TTemplateString8])),
    parallelismTotal: Optional(TTemplateString8)
  })
]);
var TLayerWithManifest23 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId23,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext8 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret8 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess8 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString8,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString8,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult23 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus23),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus23),
  startedAt: Optional(TDateString23),
  completedAt: Optional(TDateString23),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem23 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity23),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults23 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest13 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact23 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest13, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact8 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration8 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow8 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow8 || {});
var TConcurrencyPool8 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow8) });
var LeaseState8 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState8 || {});
var TTiming15 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps15 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming15)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming15)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming15),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming15),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming15.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming15),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming15),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming15),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming15),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming15),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming15),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming15),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming15)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming15.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic8 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction12 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact23)
});
var TBaseLayerSpecificationTriple2 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId2 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification2 = Union([TBaseLayerSpecificationTriple2, TBaseLayerSpecificationLayerId2]);
var TBaseLayerDescriptor2 = Composite([
  TBaseLayerSpecificationTriple2,
  TBaseLayerSpecificationLayerId2,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTask8 = Object2({
  schemaVersion: Literal(ThisSchemaVersion8),
  taskId: TTaskOrGroupId23,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId8),
  generatorTaskId: Optional(TTaskOrGroupId23),
  definition: TTaskDefinition8,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus8),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus8),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus8),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus8),
  resultStatus: Enum(TaskResultStatus8),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason8)),
  resolvedAt: Optional(TDateString23),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString23),
  debugReadyAt: Optional(TDateString23),
  debugStartedAt: Optional(TDateString23),
  debugEndedAt: Optional(TDateString23),
  cancellationRequestedAt: Optional(TDateString23),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString23),
  cancelledAt: Optional(TDateString23),
  concurrencyPool: Optional(TConcurrencyPool8),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext8),
  usedSecrets: Optional(Array2(TUsedSecret8)),
  resolvedAllowCacheHit: Optional(Boolean2()),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString8, cacheKey: Enum(EnvironmentVariableCacheKey21) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString8),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess8)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact8)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest23)),
  previousLayers: Optional(Array2(TLayerWithManifest23)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest23)),
  filesystemLayers: Optional(Array2(TLayerWithManifest23)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString8)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration8),
      baseLayer: TBaseLayerDescriptor2
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification8),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath6)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult23)),
  whiteoutLayer: Optional(TLayerWithManifest23),
  outputLayers: Optional(Array2(TLayerWithManifest23)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey21) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem23)),
  testResults: Optional(Array2(TTestResults23)),
  artifacts: Optional(Array2(TArtifact23)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps15,
  networkTraffic: TNetworkTraffic8,
  outputRetryActions: Array2(TRetryAction12),
  retryAction: Optional(TRetryAction12),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest23)
});
var TRetryManifestEntry8 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry8 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString23,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString23),
  mostRecentlyAttemptedAt: Optional(TDateString23),
  finishedAt: Optional(TDateString23),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots8 = Object2({ resolution: Array2(TGraphNodeId8), runtime: Array2(TGraphNodeId8) });
var TRunGraph8 = Object2({
  roots: TGraphRoots8,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId8, Array2(TGraphNodeId8)),
    runtime: Record(TGraphNodeId8, Array2(TGraphNodeId8))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId8, Array2(TGraphNodeId8)),
    runtime: Record(TGraphNodeId8, Array2(TGraphNodeId8))
  }),
  subgraphs: Record(TGraphNodeId8, Object2({ roots: TGraphRoots8 })),
  parents: Record(TGraphNodeId8, TGraphNodeId8),
  definitionOrders: Record(TGraphNodeId8, Number2())
});
var TActor8 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState8 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState8)
});
var ApprovalRequestState5 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState5 || {});
var TApprovalRequest5 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState5)
});
var TRun8 = Object2({
  schemaVersion: Literal(ThisSchemaVersion8),
  persistenceExpiresAtSeconds: TEpochSeconds8,
  runId: String2(),
  createdAt: TDateString23,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor8),
  mintDirectoryArtifact: Optional(TArtifact23),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool8),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration8),
  eventNumber: Number2(),
  retries: Array2(TRetry8),
  approvalRequests: Array2(TApprovalRequest5),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph8,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry8)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey8, TConcurrencyPoolState8),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayerDescriptor2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus8),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus8),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus8),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus8),
  resultStatus: Enum(RunResultStatus8),
  waitingForLeaseAt: Optional(TDateString23),
  startedAt: Optional(TDateString23),
  cancellationRequestedAt: Optional(TDateString23),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString23)
});

// ../packages/schema/persisted/versioned/v46.ts
var ThisSchemaVersion9 = "v46" /* V46 */;
var TTaskOrGroupId24 = TBrandedString();
var TGraphNodeId9 = TBrandedString();
var TTemplateString9 = TBrandedString();
var TEvaluatedString9 = TBrandedString();
var TDateString24 = TBrandedString();
var TEpochSeconds9 = TBrandedNumber();
var TScopedTaskKey9 = TBrandedString();
var TaskType9 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType9 || {});
var TaskResultStatus9 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus9 || {});
var TaskExecutionStatus9 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus9 || {});
var TaskExecutionWaitingSubStatus9 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus9 || {});
var TaskExecutionAbortedSubStatus9 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus9 || {});
var TaskExecutionFinishedSubStatus9 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus9 || {});
var TaskAttemptReason9 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason9 || {});
var BackgroundProcessResultStatus24 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus24 || {});
var BackgroundProcessResultFinishedSubStatus24 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus24 || {});
var RunResultStatus9 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus9 || {});
var RunExecutionStatus9 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus9 || {});
var RunExecutionWaitingSubStatus9 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus9 || {});
var RunExecutionAbortedSubStatus9 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus9 || {});
var RunExecutionFinishedSubStatus9 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus9 || {});
var TSource9 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey22 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey22 || {});
var TExpandedEnvDescriptor9 = Object2({ value: Optional(TTemplateString9), cacheKey: Enum(EnvironmentVariableCacheKey22) });
var TEnvMergeStrategy9 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath24 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern24 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity24 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity24 || {});
var TProblemMatcher24 = Object2({ owner: String2(), severity: Optional(Enum(Severity24)), pattern: Array2(TProblemMatcherPattern24) });
var TProblemPath24 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath9 = Object2({ key: String2(), path: TTemplateString9 });
var TResolvedArtifactPath7 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck9 = Object2({ run: TTemplateString9, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess9 = Object2({
  key: String2(),
  command: TTemplateString9,
  readyCheck: Optional(TExpandedReadyCheck9),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType9 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType9 || {});
var TParallelismValue9 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification9 = Object2({
  cpus: Optional(TTemplateString9),
  memory: Optional(TTemplateString9),
  disk: Object2({ size: Optional(TTemplateString9) }),
  staticIps: Optional(TTemplateString9),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification9 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs9 = Object2({
  values: Optional(Record(String2(), TTemplateString9)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter9 = Object2({
  workspace: Optional(Union([Array2(TTemplateString9), TTemplateString9])),
  artifacts: Optional(Record(TTemplateString9, Union([Array2(TTemplateString9), TTemplateString9])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter9 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration2 = Object2({
  enabled: TTemplateString9,
  ttl: Optional(TTemplateString9)
});
var TTaskDefinitionWithoutParallel9 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification9),
  type: Optional(Enum(TaskType9)),
  after: Optional(TTemplateString9),
  if: Optional(TTemplateString9),
  source: Optional(TSource9),
  cacheConfiguration: TCacheConfiguration2,
  docker: Optional(TTemplateString9),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString9),
  filter: Optional(TInputFilesystemFilter9),
  backgroundProcesses: Optional(Array2(TBackgroundProcess9)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor9)),
  envMerge: Optional(Array2(TEnvMergeStrategy9)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath24)),
  artifactPaths: Optional(Array2(TArtifactPath9)),
  outputs: Optional(TTaskDefinitionOutputs9),
  problemMatchers: Optional(Array2(TProblemMatcher24)),
  problemPaths: Optional(Array2(TProblemPath24)),
  parallelismType: Optional(Enum(ParallelismType9)),
  parallelismValue: Optional(TParallelismValue9),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString9)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString9),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter9)
});
var TTaskDefinition9 = Composite([
  TTaskDefinitionWithoutParallel9,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel9),
    parallelKey: Optional(TTemplateString9),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString9), TTemplateString9]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString9)), TTemplateString9])),
    parallelismTotal: Optional(TTemplateString9)
  })
]);
var TLayerWithManifest24 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId24,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext9 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret9 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess9 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString9,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString9,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult24 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus24),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus24),
  startedAt: Optional(TDateString24),
  completedAt: Optional(TDateString24),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem24 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity24),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults24 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest14 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact24 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest14, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact9 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration9 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow9 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow9 || {});
var TConcurrencyPool9 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow9) });
var LeaseState9 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState9 || {});
var TTiming16 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps16 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming16)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming16)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming16),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming16),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming16.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming16),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming16),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming16),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming16),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming16),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming16),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming16),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming16)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming16.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic9 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction13 = Object2({
  key: String2(),
  label: String2(),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact24)
});
var TBaseLayerSpecificationTriple3 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId3 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification3 = Union([TBaseLayerSpecificationTriple3, TBaseLayerSpecificationLayerId3]);
var TBaseLayerDescriptor3 = Composite([
  TBaseLayerSpecificationTriple3,
  TBaseLayerSpecificationLayerId3,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit2 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit2 || {});
var TTTL2 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit2)
});
var TResolvedCacheConfiguration2 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL2)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask9 = Object2({
  schemaVersion: Literal(ThisSchemaVersion9),
  taskId: TTaskOrGroupId24,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId9),
  generatorTaskId: Optional(TTaskOrGroupId24),
  definition: TTaskDefinition9,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus9),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus9),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus9),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus9),
  resultStatus: Enum(TaskResultStatus9),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason9)),
  resolvedAt: Optional(TDateString24),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString24),
  debugReadyAt: Optional(TDateString24),
  debugStartedAt: Optional(TDateString24),
  debugEndedAt: Optional(TDateString24),
  cancellationRequestedAt: Optional(TDateString24),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString24),
  cancelledAt: Optional(TDateString24),
  concurrencyPool: Optional(TConcurrencyPool9),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext9),
  usedSecrets: Optional(Array2(TUsedSecret9)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration2),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString9, cacheKey: Enum(EnvironmentVariableCacheKey22) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString9),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess9)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact9)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest24)),
  previousLayers: Optional(Array2(TLayerWithManifest24)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest24)),
  filesystemLayers: Optional(Array2(TLayerWithManifest24)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString9)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration9),
      baseLayer: TBaseLayerDescriptor3
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification9),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath7)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult24)),
  whiteoutLayer: Optional(TLayerWithManifest24),
  outputLayers: Optional(Array2(TLayerWithManifest24)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey22) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem24)),
  testResults: Optional(Array2(TTestResults24)),
  artifacts: Optional(Array2(TArtifact24)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps16,
  networkTraffic: TNetworkTraffic9,
  outputRetryActions: Array2(TRetryAction13),
  retryAction: Optional(TRetryAction13),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest24)
});
var TRetryManifestEntry9 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry9 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString24,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString24),
  mostRecentlyAttemptedAt: Optional(TDateString24),
  finishedAt: Optional(TDateString24),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots9 = Object2({ resolution: Array2(TGraphNodeId9), runtime: Array2(TGraphNodeId9) });
var TRunGraph9 = Object2({
  roots: TGraphRoots9,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId9, Array2(TGraphNodeId9)),
    runtime: Record(TGraphNodeId9, Array2(TGraphNodeId9))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId9, Array2(TGraphNodeId9)),
    runtime: Record(TGraphNodeId9, Array2(TGraphNodeId9))
  }),
  subgraphs: Record(TGraphNodeId9, Object2({ roots: TGraphRoots9 })),
  parents: Record(TGraphNodeId9, TGraphNodeId9),
  definitionOrders: Record(TGraphNodeId9, Number2())
});
var TActor9 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState9 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState9)
});
var ApprovalRequestState6 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState6 || {});
var TApprovalRequest6 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState6)
});
var TRun9 = Object2({
  schemaVersion: Literal(ThisSchemaVersion9),
  persistenceExpiresAtSeconds: TEpochSeconds9,
  runId: String2(),
  createdAt: TDateString24,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor9),
  mintDirectoryArtifact: Optional(TArtifact24),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool9),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration9),
  eventNumber: Number2(),
  retries: Array2(TRetry9),
  approvalRequests: Array2(TApprovalRequest6),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph9,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry9)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey9, TConcurrencyPoolState9),
  isMonitoringLeases: Boolean2(),
  baseLayer: TBaseLayerDescriptor3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus9),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus9),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus9),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus9),
  resultStatus: Enum(RunResultStatus9),
  waitingForLeaseAt: Optional(TDateString24),
  startedAt: Optional(TDateString24),
  cancellationRequestedAt: Optional(TDateString24),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString24)
});

// ../packages/schema/persisted/versioned/v47.ts
var ThisSchemaVersion10 = "v47" /* V47 */;
var TTaskOrGroupId25 = TBrandedString();
var TGraphNodeId10 = TBrandedString();
var TTemplateString10 = TBrandedString();
var TEvaluatedString10 = TBrandedString();
var TDateString25 = TBrandedString();
var TEpochSeconds10 = TBrandedNumber();
var TScopedTaskKey10 = TBrandedString();
var TaskType10 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType10 || {});
var TaskResultStatus10 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus10 || {});
var TaskExecutionStatus10 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus10 || {});
var TaskExecutionWaitingSubStatus10 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus10 || {});
var TaskExecutionAbortedSubStatus10 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus10 || {});
var TaskExecutionFinishedSubStatus10 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus10 || {});
var TaskAttemptReason10 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason10 || {});
var BackgroundProcessResultStatus25 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus25 || {});
var BackgroundProcessResultFinishedSubStatus25 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus25 || {});
var RunResultStatus10 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus10 || {});
var RunExecutionStatus10 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus10 || {});
var RunExecutionWaitingSubStatus10 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus10 || {});
var RunExecutionAbortedSubStatus10 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus10 || {});
var RunExecutionFinishedSubStatus10 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus10 || {});
var TSource10 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey23 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey23 || {});
var TExpandedEnvDescriptor10 = Object2({ value: Optional(TTemplateString10), cacheKey: Enum(EnvironmentVariableCacheKey23) });
var TEnvMergeStrategy10 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath25 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern25 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity25 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity25 || {});
var TProblemMatcher25 = Object2({ owner: String2(), severity: Optional(Enum(Severity25)), pattern: Array2(TProblemMatcherPattern25) });
var TProblemPath25 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath10 = Object2({ key: String2(), path: TTemplateString10 });
var TResolvedArtifactPath8 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck10 = Object2({ run: TTemplateString10, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess10 = Object2({
  key: String2(),
  command: TTemplateString10,
  readyCheck: Optional(TExpandedReadyCheck10),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType10 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType10 || {});
var TParallelismValue10 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification10 = Object2({
  cpus: Optional(TTemplateString10),
  memory: Optional(TTemplateString10),
  disk: Object2({ size: Optional(TTemplateString10) }),
  staticIps: Optional(TTemplateString10),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification10 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs10 = Object2({
  values: Optional(Record(String2(), TTemplateString10)),
  valuesFrom: Optional(Array2(String2()))
});
var TInputFilesystemFilter10 = Object2({
  workspace: Optional(Union([Array2(TTemplateString10), TTemplateString10])),
  artifacts: Optional(Record(TTemplateString10, Union([Array2(TTemplateString10), TTemplateString10])))
  // artifact reference -> template | template[]
});
var TOutputFilesystemFilter10 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration3 = Object2({
  enabled: TTemplateString10,
  ttl: Optional(TTemplateString10)
});
var TTaskDefinitionWithoutParallel10 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification10),
  type: Optional(Enum(TaskType10)),
  after: Optional(TTemplateString10),
  if: Optional(TTemplateString10),
  source: Optional(TSource10),
  cacheConfiguration: TCacheConfiguration3,
  docker: Optional(TTemplateString10),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString10),
  filter: Optional(TInputFilesystemFilter10),
  backgroundProcesses: Optional(Array2(TBackgroundProcess10)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor10)),
  envMerge: Optional(Array2(TEnvMergeStrategy10)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath25)),
  artifactPaths: Optional(Array2(TArtifactPath10)),
  outputs: Optional(TTaskDefinitionOutputs10),
  problemMatchers: Optional(Array2(TProblemMatcher25)),
  problemPaths: Optional(Array2(TProblemPath25)),
  parallelismType: Optional(Enum(ParallelismType10)),
  parallelismValue: Optional(TParallelismValue10),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString10)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString10),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter10)
});
var TTaskDefinition10 = Composite([
  TTaskDefinitionWithoutParallel10,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel10),
    parallelKey: Optional(TTemplateString10),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString10), TTemplateString10]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString10)), TTemplateString10])),
    parallelismTotal: Optional(TTemplateString10)
  })
]);
var TLayerWithManifest25 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId25,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext10 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret10 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess10 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString10,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString10,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult25 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus25),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus25),
  startedAt: Optional(TDateString25),
  completedAt: Optional(TDateString25),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem25 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity25),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults25 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest15 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact25 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest15, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact10 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(String2())),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(String2()))
      })
    )
  )
});
var TRunToolCacheConfiguration10 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow10 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow10 || {});
var TConcurrencyPool10 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow10) });
var LeaseState10 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState10 || {});
var TTiming17 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps17 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming17)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming17)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming17),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming17),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming17.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming17),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming17),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming17),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming17),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming17),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming17),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming17),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming17)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming17.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic10 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction14 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact25)
});
var TBaseLayerSpecificationTriple4 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId4 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification4 = Union([TBaseLayerSpecificationTriple4, TBaseLayerSpecificationLayerId4]);
var TBaseLayerDescriptor4 = Composite([
  TBaseLayerSpecificationTriple4,
  TBaseLayerSpecificationLayerId4,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit3 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit3 || {});
var TTTL3 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit3)
});
var TResolvedCacheConfiguration3 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL3)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask10 = Object2({
  schemaVersion: Literal(ThisSchemaVersion10),
  taskId: TTaskOrGroupId25,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId10),
  generatorTaskId: Optional(TTaskOrGroupId25),
  definition: TTaskDefinition10,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus10),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus10),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus10),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus10),
  resultStatus: Enum(TaskResultStatus10),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason10)),
  resolvedAt: Optional(TDateString25),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString25),
  debugReadyAt: Optional(TDateString25),
  debugStartedAt: Optional(TDateString25),
  debugEndedAt: Optional(TDateString25),
  cancellationRequestedAt: Optional(TDateString25),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString25),
  cancelledAt: Optional(TDateString25),
  concurrencyPool: Optional(TConcurrencyPool10),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext10),
  usedSecrets: Optional(Array2(TUsedSecret10)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration3),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString10, cacheKey: Enum(EnvironmentVariableCacheKey23) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString10),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess10)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact10)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest25)),
  previousLayers: Optional(Array2(TLayerWithManifest25)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest25)),
  filesystemLayers: Optional(Array2(TLayerWithManifest25)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString10)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration10),
      baseLayer: TBaseLayerDescriptor4
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification10),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath8)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult25)),
  whiteoutLayer: Optional(TLayerWithManifest25),
  outputLayers: Optional(Array2(TLayerWithManifest25)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey23) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem25)),
  testResults: Optional(Array2(TTestResults25)),
  artifacts: Optional(Array2(TArtifact25)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps17,
  networkTraffic: TNetworkTraffic10,
  outputRetryActions: Array2(TRetryAction14),
  retryAction: Optional(TRetryAction14),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest25)
});
var TRetryManifestEntry10 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry10 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString25,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString25),
  mostRecentlyAttemptedAt: Optional(TDateString25),
  finishedAt: Optional(TDateString25),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots10 = Object2({ resolution: Array2(TGraphNodeId10), runtime: Array2(TGraphNodeId10) });
var TRunGraph10 = Object2({
  roots: TGraphRoots10,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId10, Array2(TGraphNodeId10)),
    runtime: Record(TGraphNodeId10, Array2(TGraphNodeId10))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId10, Array2(TGraphNodeId10)),
    runtime: Record(TGraphNodeId10, Array2(TGraphNodeId10))
  }),
  subgraphs: Record(TGraphNodeId10, Object2({ roots: TGraphRoots10 })),
  parents: Record(TGraphNodeId10, TGraphNodeId10),
  definitionOrders: Record(TGraphNodeId10, Number2())
});
var TActor10 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState10 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState10)
});
var ApprovalRequestState7 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState7 || {});
var TApprovalRequest7 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState7)
});
var TRun10 = Object2({
  schemaVersion: Literal(ThisSchemaVersion10),
  persistenceExpiresAtSeconds: TEpochSeconds10,
  runId: String2(),
  createdAt: TDateString25,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor10),
  mintDirectoryArtifact: Optional(TArtifact25),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool10),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration10),
  eventNumber: Number2(),
  retries: Array2(TRetry10),
  approvalRequests: Array2(TApprovalRequest7),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph10,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry10)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey10, TConcurrencyPoolState10),
  baseLayer: TBaseLayerDescriptor4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus10),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus10),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus10),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus10),
  resultStatus: Enum(RunResultStatus10),
  waitingForLeaseAt: Optional(TDateString25),
  startedAt: Optional(TDateString25),
  cancellationRequestedAt: Optional(TDateString25),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString25)
});

// ../packages/schema/persisted/versioned/v48.ts
var ThisSchemaVersion11 = "v48" /* V48 */;
var TTaskOrGroupId26 = TBrandedString();
var TGraphNodeId11 = TBrandedString();
var TTemplateString11 = TBrandedString();
var TEvaluatedString11 = TBrandedString();
var TDateString26 = TBrandedString();
var TEpochSeconds11 = TBrandedNumber();
var TScopedTaskKey11 = TBrandedString();
var TaskType11 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType11 || {});
var TaskResultStatus11 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus11 || {});
var TaskExecutionStatus11 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus11 || {});
var TaskExecutionWaitingSubStatus11 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus11 || {});
var TaskExecutionAbortedSubStatus11 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus11 || {});
var TaskExecutionFinishedSubStatus11 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus11 || {});
var TaskAttemptReason11 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason11 || {});
var BackgroundProcessResultStatus26 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus26 || {});
var BackgroundProcessResultFinishedSubStatus26 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus26 || {});
var RunResultStatus11 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus11 || {});
var RunExecutionStatus11 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus11 || {});
var RunExecutionWaitingSubStatus11 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus11 || {});
var RunExecutionAbortedSubStatus11 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus11 || {});
var RunExecutionFinishedSubStatus11 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus11 || {});
var TSource11 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey24 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey24 || {});
var TExpandedEnvDescriptor11 = Object2({ value: Optional(TTemplateString11), cacheKey: Enum(EnvironmentVariableCacheKey24) });
var TEnvMergeStrategy11 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath26 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern26 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity26 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity26 || {});
var TProblemMatcher26 = Object2({ owner: String2(), severity: Optional(Enum(Severity26)), pattern: Array2(TProblemMatcherPattern26) });
var TProblemPath26 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath11 = Object2({ key: String2(), path: TTemplateString11 });
var TResolvedArtifactPath9 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck11 = Object2({ run: TTemplateString11, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess11 = Object2({
  key: String2(),
  command: TTemplateString11,
  readyCheck: Optional(TExpandedReadyCheck11),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType11 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType11 || {});
var TParallelismValue11 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification11 = Object2({
  cpus: Optional(TTemplateString11),
  memory: Optional(TTemplateString11),
  disk: Object2({ size: Optional(TTemplateString11) }),
  staticIps: Optional(TTemplateString11),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification11 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs11 = Object2({
  values: Optional(Record(String2(), TTemplateString11)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor2 = Object2({ path: TTemplateString11, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor2 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet2 = Union([TTemplateString11, Array2(Union([TTemplateString11, TFilterDescriptor2]))]);
var TInputFilesystemFilter11 = Object2({
  workspace: Optional(TFilterSet2),
  artifacts: Optional(Record(TTemplateString11, TFilterSet2))
});
var TOutputFilesystemFilter11 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration4 = Object2({
  enabled: TTemplateString11,
  ttl: Optional(TTemplateString11)
});
var TTaskDefinitionWithoutParallel11 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification11),
  type: Optional(Enum(TaskType11)),
  after: Optional(TTemplateString11),
  if: Optional(TTemplateString11),
  source: Optional(TSource11),
  cacheConfiguration: TCacheConfiguration4,
  docker: Optional(TTemplateString11),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString11),
  filter: Optional(TInputFilesystemFilter11),
  backgroundProcesses: Optional(Array2(TBackgroundProcess11)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor11)),
  envMerge: Optional(Array2(TEnvMergeStrategy11)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath26)),
  artifactPaths: Optional(Array2(TArtifactPath11)),
  outputs: Optional(TTaskDefinitionOutputs11),
  problemMatchers: Optional(Array2(TProblemMatcher26)),
  problemPaths: Optional(Array2(TProblemPath26)),
  parallelismType: Optional(Enum(ParallelismType11)),
  parallelismValue: Optional(TParallelismValue11),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString11)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString11),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter11)
});
var TTaskDefinition11 = Composite([
  TTaskDefinitionWithoutParallel11,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel11),
    parallelKey: Optional(TTemplateString11),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString11), TTemplateString11]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString11)), TTemplateString11])),
    parallelismTotal: Optional(TTemplateString11)
  })
]);
var TLayerWithManifest26 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId26,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext11 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret11 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess11 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString11,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString11,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult26 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus26),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus26),
  startedAt: Optional(TDateString26),
  completedAt: Optional(TDateString26),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem26 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity26),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults26 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest16 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact26 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest16, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact11 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor2)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor2))
      })
    )
  )
});
var TRunToolCacheConfiguration11 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow11 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow11 || {});
var TConcurrencyPool11 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow11) });
var LeaseState11 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState11 || {});
var TTiming18 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps18 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming18)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming18)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming18),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming18),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming18.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming18),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming18),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming18),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming18),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming18),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming18),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming18),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming18)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming18.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic11 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction15 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact26)
});
var TBaseLayerSpecificationTriple5 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId5 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification5 = Union([TBaseLayerSpecificationTriple5, TBaseLayerSpecificationLayerId5]);
var TBaseLayerDescriptor5 = Composite([
  TBaseLayerSpecificationTriple5,
  TBaseLayerSpecificationLayerId5,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit4 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit4 || {});
var TTTL4 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit4)
});
var TResolvedCacheConfiguration4 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL4)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTask11 = Object2({
  schemaVersion: Literal(ThisSchemaVersion11),
  taskId: TTaskOrGroupId26,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId11),
  generatorTaskId: Optional(TTaskOrGroupId26),
  definition: TTaskDefinition11,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus11),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus11),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus11),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus11),
  resultStatus: Enum(TaskResultStatus11),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason11)),
  resolvedAt: Optional(TDateString26),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString26),
  debugReadyAt: Optional(TDateString26),
  debugStartedAt: Optional(TDateString26),
  debugEndedAt: Optional(TDateString26),
  cancellationRequestedAt: Optional(TDateString26),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString26),
  cancelledAt: Optional(TDateString26),
  concurrencyPool: Optional(TConcurrencyPool11),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext11),
  usedSecrets: Optional(Array2(TUsedSecret11)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration4),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString11, cacheKey: Enum(EnvironmentVariableCacheKey24) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString11),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess11)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact11)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest26)),
  previousLayers: Optional(Array2(TLayerWithManifest26)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest26)),
  filesystemLayers: Optional(Array2(TLayerWithManifest26)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString11)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration11),
      baseLayer: TBaseLayerDescriptor5
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification11),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath9)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult26)),
  whiteoutLayer: Optional(TLayerWithManifest26),
  outputLayers: Optional(Array2(TLayerWithManifest26)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey24) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem26)),
  testResults: Optional(Array2(TTestResults26)),
  artifacts: Optional(Array2(TArtifact26)),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps18,
  networkTraffic: TNetworkTraffic11,
  outputRetryActions: Array2(TRetryAction15),
  retryAction: Optional(TRetryAction15),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest26)
});
var TRetryManifestEntry11 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry11 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString26,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString26),
  mostRecentlyAttemptedAt: Optional(TDateString26),
  finishedAt: Optional(TDateString26),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots11 = Object2({ resolution: Array2(TGraphNodeId11), runtime: Array2(TGraphNodeId11) });
var TRunGraph11 = Object2({
  roots: TGraphRoots11,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId11, Array2(TGraphNodeId11)),
    runtime: Record(TGraphNodeId11, Array2(TGraphNodeId11))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId11, Array2(TGraphNodeId11)),
    runtime: Record(TGraphNodeId11, Array2(TGraphNodeId11))
  }),
  subgraphs: Record(TGraphNodeId11, Object2({ roots: TGraphRoots11 })),
  parents: Record(TGraphNodeId11, TGraphNodeId11),
  definitionOrders: Record(TGraphNodeId11, Number2())
});
var TActor11 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState11 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState11)
});
var ApprovalRequestState8 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState8 || {});
var TApprovalRequest8 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState8)
});
var TRun11 = Object2({
  schemaVersion: Literal(ThisSchemaVersion11),
  persistenceExpiresAtSeconds: TEpochSeconds11,
  runId: String2(),
  createdAt: TDateString26,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor11),
  mintDirectoryArtifact: Optional(TArtifact26),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool11),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration11),
  eventNumber: Number2(),
  retries: Array2(TRetry11),
  approvalRequests: Array2(TApprovalRequest8),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph11,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry11)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey11, TConcurrencyPoolState11),
  baseLayer: TBaseLayerDescriptor5,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus11),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus11),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus11),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus11),
  resultStatus: Enum(RunResultStatus11),
  waitingForLeaseAt: Optional(TDateString26),
  startedAt: Optional(TDateString26),
  cancellationRequestedAt: Optional(TDateString26),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString26)
});

// ../packages/schema/persisted/versioned/v49.ts
var ThisSchemaVersion12 = "v49" /* V49 */;
var TTaskOrGroupId27 = TBrandedString();
var TGraphNodeId12 = TBrandedString();
var TTemplateString12 = TBrandedString();
var TEvaluatedString12 = TBrandedString();
var TDateString27 = TBrandedString();
var TEpochSeconds12 = TBrandedNumber();
var TScopedTaskKey12 = TBrandedString();
var TaskType12 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType12 || {});
var TaskResultStatus12 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus12 || {});
var TaskExecutionStatus12 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus12 || {});
var TaskExecutionWaitingSubStatus12 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus12 || {});
var TaskExecutionAbortedSubStatus12 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus12 || {});
var TaskExecutionFinishedSubStatus12 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus12 || {});
var TaskAttemptReason12 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason12 || {});
var BackgroundProcessResultStatus27 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus27 || {});
var BackgroundProcessResultFinishedSubStatus27 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus27 || {});
var RunResultStatus12 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus12 || {});
var RunExecutionStatus12 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus12 || {});
var RunExecutionWaitingSubStatus12 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus12 || {});
var RunExecutionAbortedSubStatus12 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus12 || {});
var RunExecutionFinishedSubStatus12 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus12 || {});
var TSource12 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey25 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey25 || {});
var TExpandedEnvDescriptor12 = Object2({ value: Optional(TTemplateString12), cacheKey: Enum(EnvironmentVariableCacheKey25) });
var TEnvMergeStrategy12 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath27 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern27 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity27 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity27 || {});
var TProblemMatcher27 = Object2({ owner: String2(), severity: Optional(Enum(Severity27)), pattern: Array2(TProblemMatcherPattern27) });
var TProblemPath27 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath12 = Object2({ key: String2(), path: TTemplateString12 });
var TResolvedArtifactPath10 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck12 = Object2({ run: TTemplateString12, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess12 = Object2({
  key: String2(),
  command: TTemplateString12,
  readyCheck: Optional(TExpandedReadyCheck12),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType12 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType12 || {});
var TParallelismValue12 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification12 = Object2({
  cpus: Optional(TTemplateString12),
  memory: Optional(TTemplateString12),
  disk: Object2({ size: Optional(TTemplateString12) }),
  staticIps: Optional(TTemplateString12),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification12 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs12 = Object2({
  values: Optional(Record(String2(), TTemplateString12)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor3 = Object2({ path: TTemplateString12, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor3 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet3 = Union([TTemplateString12, Array2(Union([TTemplateString12, TFilterDescriptor3]))]);
var TInputFilesystemFilter12 = Object2({
  workspace: Optional(TFilterSet3),
  artifacts: Optional(Record(TTemplateString12, TFilterSet3))
});
var TOutputFilesystemFilter12 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration5 = Object2({
  enabled: TTemplateString12,
  ttl: Optional(TTemplateString12)
});
var TTaskDefinitionWithoutParallel12 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification12),
  type: Optional(Enum(TaskType12)),
  after: Optional(TTemplateString12),
  if: Optional(TTemplateString12),
  source: Optional(TSource12),
  cacheConfiguration: TCacheConfiguration5,
  docker: Optional(TTemplateString12),
  dependencyExactFilesystem: Optional(String2()),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString12),
  filter: Optional(TInputFilesystemFilter12),
  backgroundProcesses: Optional(Array2(TBackgroundProcess12)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor12)),
  envMerge: Optional(Array2(TEnvMergeStrategy12)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath27)),
  artifactPaths: Optional(Array2(TArtifactPath12)),
  outputs: Optional(TTaskDefinitionOutputs12),
  problemMatchers: Optional(Array2(TProblemMatcher27)),
  problemPaths: Optional(Array2(TProblemPath27)),
  parallelismType: Optional(Enum(ParallelismType12)),
  parallelismValue: Optional(TParallelismValue12),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString12)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString12),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter12)
});
var TCrossRunSource2 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents2 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource2,
  relativeScopedKey: String2()
});
var TTaskDefinition12 = Composite([
  TTaskDefinitionWithoutParallel12,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel12),
    parallelKey: Optional(TTemplateString12),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString12), TTemplateString12]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString12)), TTemplateString12])),
    parallelismTotal: Optional(TTemplateString12)
  })
]);
var TLayerWithManifest27 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId27,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext12 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret12 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess12 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString12,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString12,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult27 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus27),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus27),
  startedAt: Optional(TDateString27),
  completedAt: Optional(TDateString27),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem27 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity27),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults27 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest17 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact27 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest17, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact12 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor3)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor3))
      })
    )
  )
});
var TRunToolCacheConfiguration12 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow12 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow12 || {});
var TConcurrencyPool12 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow12) });
var LeaseState12 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState12 || {});
var TTiming19 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps19 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming19)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming19)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming19),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming19),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming19.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming19),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming19),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming19),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming19),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming19),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming19),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming19),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming19)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming19.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic12 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction16 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact27)
});
var TBaseLayerSpecificationTriple6 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId6 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification6 = Union([TBaseLayerSpecificationTriple6, TBaseLayerSpecificationLayerId6]);
var TBaseLayerDescriptor6 = Composite([
  TBaseLayerSpecificationTriple6,
  TBaseLayerSpecificationLayerId6,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit5 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit5 || {});
var TTTL5 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit5)
});
var TResolvedCacheConfiguration5 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL5)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip4 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask12 = Object2({
  schemaVersion: Literal(ThisSchemaVersion12),
  taskId: TTaskOrGroupId27,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId12),
  generatorTaskId: Optional(TTaskOrGroupId27),
  definition: TTaskDefinition12,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus12),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus12),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus12),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus12),
  resultStatus: Enum(TaskResultStatus12),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason12)),
  resolvedAt: Optional(TDateString27),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString27),
  debugReadyAt: Optional(TDateString27),
  debugStartedAt: Optional(TDateString27),
  debugEndedAt: Optional(TDateString27),
  cancellationRequestedAt: Optional(TDateString27),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString27),
  cancelledAt: Optional(TDateString27),
  concurrencyPool: Optional(TConcurrencyPool12),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext12),
  usedSecrets: Optional(Array2(TUsedSecret12)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration5),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString12, cacheKey: Enum(EnvironmentVariableCacheKey25) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString12),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess12)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact12)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest27)),
  previousLayers: Optional(Array2(TLayerWithManifest27)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest27)),
  filesystemLayers: Optional(Array2(TLayerWithManifest27)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString12)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration12),
      baseLayer: TBaseLayerDescriptor6,
      crossRunSource: Optional(TCrossRunSource2)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification12),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath10)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult27)),
  whiteoutLayer: Optional(TLayerWithManifest27),
  outputLayers: Optional(Array2(TLayerWithManifest27)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey25) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem27)),
  testResults: Optional(Array2(TTestResults27)),
  artifacts: Optional(Array2(TArtifact27)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents2),
  tips: Array2(TTip4),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps19,
  networkTraffic: TNetworkTraffic12,
  outputRetryActions: Array2(TRetryAction16),
  retryAction: Optional(TRetryAction16),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest27)
});
var TRetryManifestEntry12 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry12 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString27,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString27),
  mostRecentlyAttemptedAt: Optional(TDateString27),
  finishedAt: Optional(TDateString27),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots12 = Object2({ resolution: Array2(TGraphNodeId12), runtime: Array2(TGraphNodeId12) });
var TRunGraph12 = Object2({
  roots: TGraphRoots12,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId12, Array2(TGraphNodeId12)),
    runtime: Record(TGraphNodeId12, Array2(TGraphNodeId12))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId12, Array2(TGraphNodeId12)),
    runtime: Record(TGraphNodeId12, Array2(TGraphNodeId12))
  }),
  subgraphs: Record(TGraphNodeId12, Object2({ roots: TGraphRoots12 })),
  parents: Record(TGraphNodeId12, TGraphNodeId12),
  definitionOrders: Record(TGraphNodeId12, Number2())
});
var TActor12 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState12 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState12)
});
var ApprovalRequestState9 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState9 || {});
var TApprovalRequest9 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState9)
});
var TRun12 = Object2({
  schemaVersion: Literal(ThisSchemaVersion12),
  persistenceExpiresAtSeconds: TEpochSeconds12,
  runId: String2(),
  createdAt: TDateString27,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor12),
  mintDirectoryArtifact: Optional(TArtifact27),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool12),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration12),
  eventNumber: Number2(),
  retries: Array2(TRetry12),
  approvalRequests: Array2(TApprovalRequest9),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph12,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry12)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey12, TConcurrencyPoolState12),
  baseLayer: TBaseLayerDescriptor6,
  crossRunSource: TCrossRunSource2,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus12),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus12),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus12),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus12),
  resultStatus: Enum(RunResultStatus12),
  waitingForLeaseAt: Optional(TDateString27),
  startedAt: Optional(TDateString27),
  cancellationRequestedAt: Optional(TDateString27),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString27)
});

// ../packages/schema/persisted/versioned/v50.ts
var ThisSchemaVersion13 = "v50" /* V50 */;
var TTaskOrGroupId28 = TBrandedString();
var TGraphNodeId13 = TBrandedString();
var TTemplateString13 = TBrandedString();
var TEvaluatedString13 = TBrandedString();
var TDateString28 = TBrandedString();
var TEpochSeconds13 = TBrandedNumber();
var TScopedTaskKey13 = TBrandedString();
var TaskType13 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType13 || {});
var TaskResultStatus13 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus13 || {});
var TaskExecutionStatus13 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus13 || {});
var TaskExecutionWaitingSubStatus13 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus13 || {});
var TaskExecutionAbortedSubStatus13 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus13 || {});
var TaskExecutionFinishedSubStatus13 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus13 || {});
var TaskAttemptReason13 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason13 || {});
var BackgroundProcessResultStatus28 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus28 || {});
var BackgroundProcessResultFinishedSubStatus28 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus28 || {});
var RunResultStatus13 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus13 || {});
var RunExecutionStatus13 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus13 || {});
var RunExecutionWaitingSubStatus13 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus13 || {});
var RunExecutionAbortedSubStatus13 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus13 || {});
var RunExecutionFinishedSubStatus13 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus13 || {});
var TSource13 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey26 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey26 || {});
var TExpandedEnvDescriptor13 = Object2({ value: Optional(TTemplateString13), cacheKey: Enum(EnvironmentVariableCacheKey26) });
var TEnvMergeStrategy13 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath28 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern28 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity28 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity28 || {});
var TProblemMatcher28 = Object2({ owner: String2(), severity: Optional(Enum(Severity28)), pattern: Array2(TProblemMatcherPattern28) });
var TProblemPath28 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath13 = Object2({ key: String2(), path: TTemplateString13 });
var TResolvedArtifactPath11 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck13 = Object2({ run: TTemplateString13, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess13 = Object2({
  key: String2(),
  command: TTemplateString13,
  readyCheck: Optional(TExpandedReadyCheck13),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType13 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType13 || {});
var TParallelismValue13 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification13 = Object2({
  cpus: Optional(TTemplateString13),
  memory: Optional(TTemplateString13),
  disk: Object2({ size: Optional(TTemplateString13) }),
  staticIps: Optional(TTemplateString13),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification13 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs13 = Object2({
  values: Optional(Record(String2(), TTemplateString13)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor4 = Object2({ path: TTemplateString13, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor4 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet4 = Union([TTemplateString13, Array2(Union([TTemplateString13, TFilterDescriptor4]))]);
var TInputFilesystemFilter13 = Object2({
  workspace: Optional(TFilterSet4),
  artifacts: Optional(Record(TTemplateString13, TFilterSet4))
});
var TOutputFilesystemFilter13 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration6 = Object2({
  enabled: TTemplateString13,
  ttl: Optional(TTemplateString13)
});
var TTaskDefinitionWithoutParallel13 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification13),
  type: Optional(Enum(TaskType13)),
  after: Optional(TTemplateString13),
  if: Optional(TTemplateString13),
  source: Optional(TSource13),
  cacheConfiguration: TCacheConfiguration6,
  docker: Optional(TTemplateString13),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString13),
  filter: Optional(TInputFilesystemFilter13),
  backgroundProcesses: Optional(Array2(TBackgroundProcess13)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor13)),
  envMerge: Optional(Array2(TEnvMergeStrategy13)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath28)),
  artifactPaths: Optional(Array2(TArtifactPath13)),
  outputs: Optional(TTaskDefinitionOutputs13),
  problemMatchers: Optional(Array2(TProblemMatcher28)),
  problemPaths: Optional(Array2(TProblemPath28)),
  parallelismType: Optional(Enum(ParallelismType13)),
  parallelismValue: Optional(TParallelismValue13),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString13)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString13),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter13)
});
var TCrossRunSource3 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents3 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource3,
  relativeScopedKey: String2()
});
var TTaskDefinition13 = Composite([
  TTaskDefinitionWithoutParallel13,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel13),
    parallelKey: Optional(TTemplateString13),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString13), TTemplateString13]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString13)), TTemplateString13])),
    parallelismTotal: Optional(TTemplateString13)
  })
]);
var TLayerWithManifest28 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId28,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext13 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret13 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess13 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString13,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString13,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult28 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus28),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus28),
  startedAt: Optional(TDateString28),
  completedAt: Optional(TDateString28),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem28 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity28),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults28 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest18 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact28 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest18, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact13 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor4)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor4))
      })
    )
  )
});
var TRunToolCacheConfiguration13 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow13 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow13 || {});
var TConcurrencyPool13 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow13) });
var LeaseState13 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState13 || {});
var TTiming20 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps20 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming20)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming20)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming20),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming20),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming20.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming20),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming20),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming20),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming20),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming20),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming20),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming20),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming20)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming20.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic13 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction17 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact28)
});
var TBaseLayerSpecificationTriple7 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId7 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification7 = Union([TBaseLayerSpecificationTriple7, TBaseLayerSpecificationLayerId7]);
var TBaseLayerDescriptor7 = Composite([
  TBaseLayerSpecificationTriple7,
  TBaseLayerSpecificationLayerId7,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit6 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit6 || {});
var TTTL6 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit6)
});
var TResolvedCacheConfiguration6 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL6)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip5 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask13 = Object2({
  schemaVersion: Literal(ThisSchemaVersion13),
  taskId: TTaskOrGroupId28,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId13),
  generatorTaskId: Optional(TTaskOrGroupId28),
  definition: TTaskDefinition13,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus13),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus13),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus13),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus13),
  resultStatus: Enum(TaskResultStatus13),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason13)),
  resolvedAt: Optional(TDateString28),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString28),
  debugReadyAt: Optional(TDateString28),
  debugStartedAt: Optional(TDateString28),
  debugEndedAt: Optional(TDateString28),
  cancellationRequestedAt: Optional(TDateString28),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString28),
  cancelledAt: Optional(TDateString28),
  concurrencyPool: Optional(TConcurrencyPool13),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext13),
  usedSecrets: Optional(Array2(TUsedSecret13)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration6),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString13, cacheKey: Enum(EnvironmentVariableCacheKey26) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString13),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess13)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact13)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest28)),
  previousLayers: Optional(Array2(TLayerWithManifest28)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest28)),
  filesystemLayers: Optional(Array2(TLayerWithManifest28)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString13)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration13),
      baseLayer: TBaseLayerDescriptor7,
      crossRunSource: Optional(TCrossRunSource3)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification13),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath11)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult28)),
  whiteoutLayer: Optional(TLayerWithManifest28),
  outputLayers: Optional(Array2(TLayerWithManifest28)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey26) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem28)),
  testResults: Optional(Array2(TTestResults28)),
  artifacts: Optional(Array2(TArtifact28)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents3),
  tips: Array2(TTip5),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps20,
  networkTraffic: TNetworkTraffic13,
  outputRetryActions: Array2(TRetryAction17),
  retryAction: Optional(TRetryAction17),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest28)
});
var TRetryManifestEntry13 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry13 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString28,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString28),
  mostRecentlyAttemptedAt: Optional(TDateString28),
  finishedAt: Optional(TDateString28),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots13 = Object2({ resolution: Array2(TGraphNodeId13), runtime: Array2(TGraphNodeId13) });
var TRunGraph13 = Object2({
  roots: TGraphRoots13,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId13, Array2(TGraphNodeId13)),
    runtime: Record(TGraphNodeId13, Array2(TGraphNodeId13))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId13, Array2(TGraphNodeId13)),
    runtime: Record(TGraphNodeId13, Array2(TGraphNodeId13))
  }),
  subgraphs: Record(TGraphNodeId13, Object2({ roots: TGraphRoots13 })),
  parents: Record(TGraphNodeId13, TGraphNodeId13),
  definitionOrders: Record(TGraphNodeId13, Number2())
});
var TActor13 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState13 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState13)
});
var ApprovalRequestState10 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState10 || {});
var TApprovalRequest10 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState10)
});
var TRun13 = Object2({
  schemaVersion: Literal(ThisSchemaVersion13),
  persistenceExpiresAtSeconds: TEpochSeconds13,
  runId: String2(),
  createdAt: TDateString28,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor13),
  mintDirectoryArtifact: Optional(TArtifact28),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool13),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration13),
  eventNumber: Number2(),
  retries: Array2(TRetry13),
  approvalRequests: Array2(TApprovalRequest10),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph13,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry13)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey13, TConcurrencyPoolState13),
  baseLayer: TBaseLayerDescriptor7,
  crossRunSource: TCrossRunSource3,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus13),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus13),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus13),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus13),
  resultStatus: Enum(RunResultStatus13),
  waitingForLeaseAt: Optional(TDateString28),
  startedAt: Optional(TDateString28),
  cancellationRequestedAt: Optional(TDateString28),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString28)
});

// ../packages/schema/persisted/versioned/v51.ts
var ThisSchemaVersion14 = "v51" /* V51 */;
var TTaskOrGroupId29 = TBrandedString();
var TGraphNodeId14 = TBrandedString();
var TTemplateString14 = TBrandedString();
var TEvaluatedString14 = TBrandedString();
var TDateString29 = TBrandedString();
var TEpochSeconds14 = TBrandedNumber();
var TScopedTaskKey14 = TBrandedString();
var TaskType14 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType14 || {});
var TaskResultStatus14 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus14 || {});
var TaskExecutionStatus14 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus14 || {});
var TaskExecutionWaitingSubStatus14 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus14 || {});
var TaskExecutionAbortedSubStatus14 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus14 || {});
var TaskExecutionFinishedSubStatus14 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus14 || {});
var TaskAttemptReason14 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason14 || {});
var BackgroundProcessResultStatus29 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus29 || {});
var BackgroundProcessResultFinishedSubStatus29 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus29 || {});
var RunResultStatus14 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus14 || {});
var RunExecutionStatus14 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus14 || {});
var RunExecutionWaitingSubStatus14 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus14 || {});
var RunExecutionAbortedSubStatus14 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus14 || {});
var RunExecutionFinishedSubStatus14 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus14 || {});
var TSource14 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey27 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey27 || {});
var TExpandedEnvDescriptor14 = Object2({ value: Optional(TTemplateString14), cacheKey: Enum(EnvironmentVariableCacheKey27) });
var TEnvMergeStrategy14 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath29 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern29 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity29 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity29 || {});
var TProblemMatcher29 = Object2({ owner: String2(), severity: Optional(Enum(Severity29)), pattern: Array2(TProblemMatcherPattern29) });
var TProblemPath29 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath14 = Object2({ key: String2(), path: TTemplateString14 });
var TResolvedArtifactPath12 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck14 = Object2({ run: TTemplateString14, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess14 = Object2({
  key: String2(),
  command: TTemplateString14,
  readyCheck: Optional(TExpandedReadyCheck14),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType14 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType14 || {});
var TParallelismValue14 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification14 = Object2({
  cpus: Optional(TTemplateString14),
  memory: Optional(TTemplateString14),
  disk: Object2({ size: Optional(TTemplateString14) }),
  staticIps: Optional(TTemplateString14),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification14 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs14 = Object2({
  values: Optional(Record(String2(), TTemplateString14)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor5 = Object2({ path: TTemplateString14, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor5 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet5 = Union([TTemplateString14, Array2(Union([TTemplateString14, TFilterDescriptor5]))]);
var TInputFilesystemFilter14 = Object2({
  workspace: Optional(TFilterSet5),
  artifacts: Optional(Record(TTemplateString14, TFilterSet5))
});
var TOutputFilesystemFilter14 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration7 = Object2({
  enabled: TTemplateString14,
  ttl: Optional(TTemplateString14)
});
var TTaskDefinitionWithoutParallel14 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification14),
  type: Optional(Enum(TaskType14)),
  after: Optional(TTemplateString14),
  if: Optional(TTemplateString14),
  source: Optional(TSource14),
  cacheConfiguration: TCacheConfiguration7,
  docker: Optional(TTemplateString14),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString14),
  filter: Optional(TInputFilesystemFilter14),
  backgroundProcesses: Optional(Array2(TBackgroundProcess14)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor14)),
  envMerge: Optional(Array2(TEnvMergeStrategy14)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath29)),
  artifactPaths: Optional(Array2(TArtifactPath14)),
  outputs: Optional(TTaskDefinitionOutputs14),
  problemMatchers: Optional(Array2(TProblemMatcher29)),
  problemPaths: Optional(Array2(TProblemPath29)),
  parallelismType: Optional(Enum(ParallelismType14)),
  parallelismValue: Optional(TParallelismValue14),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString14)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString14),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter14)
});
var TCrossRunSource4 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents4 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource4,
  relativeScopedKey: String2()
});
var TTaskDefinition14 = Composite([
  TTaskDefinitionWithoutParallel14,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel14),
    parallelKey: Optional(TTemplateString14),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString14), TTemplateString14]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString14)), TTemplateString14])),
    parallelismTotal: Optional(TTemplateString14)
  })
]);
var TLayerWithManifest29 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId29,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext14 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret14 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess14 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString14,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString14,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult29 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus29),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus29),
  startedAt: Optional(TDateString29),
  completedAt: Optional(TDateString29),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem29 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity29),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults29 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest19 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact29 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest19, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact14 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor5)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor5))
      })
    )
  )
});
var TRunToolCacheConfiguration14 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow14 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow14 || {});
var TConcurrencyPool14 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow14) });
var LeaseState14 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState14 || {});
var TTiming21 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps21 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming21)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming21)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming21),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming21),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming21.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming21),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming21),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming21),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming21),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming21),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming21),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming21),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming21)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming21.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic14 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction18 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact29)
});
var TBaseLayerSpecificationTriple8 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId8 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification8 = Union([TBaseLayerSpecificationTriple8, TBaseLayerSpecificationLayerId8]);
var TBaseLayerDescriptor8 = Composite([
  TBaseLayerSpecificationTriple8,
  TBaseLayerSpecificationLayerId8,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit7 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit7 || {});
var TTTL7 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit7)
});
var TResolvedCacheConfiguration7 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL7)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip6 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask14 = Object2({
  schemaVersion: Literal(ThisSchemaVersion14),
  taskId: TTaskOrGroupId29,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId14),
  generatorTaskId: Optional(TTaskOrGroupId29),
  definition: TTaskDefinition14,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus14),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus14),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus14),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus14),
  resultStatus: Enum(TaskResultStatus14),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason14)),
  resolvedAt: Optional(TDateString29),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString29),
  debugReadyAt: Optional(TDateString29),
  debugStartedAt: Optional(TDateString29),
  debugEndedAt: Optional(TDateString29),
  cancellationRequestedAt: Optional(TDateString29),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString29),
  cancelledAt: Optional(TDateString29),
  concurrencyPool: Optional(TConcurrencyPool14),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext14),
  usedSecrets: Optional(Array2(TUsedSecret14)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration7),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString14, cacheKey: Enum(EnvironmentVariableCacheKey27) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString14),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess14)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact14)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest29)),
  previousLayers: Optional(Array2(TLayerWithManifest29)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest29)),
  filesystemLayers: Optional(Array2(TLayerWithManifest29)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString14)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration14),
      baseLayer: TBaseLayerDescriptor8,
      crossRunSource: Optional(TCrossRunSource4)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification14),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath12)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult29)),
  whiteoutLayer: Optional(TLayerWithManifest29),
  outputLayers: Optional(Array2(TLayerWithManifest29)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey27) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem29)),
  testResults: Optional(Array2(TTestResults29)),
  artifacts: Optional(Array2(TArtifact29)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents4),
  tips: Array2(TTip6),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps21,
  networkTraffic: TNetworkTraffic14,
  outputRetryActions: Array2(TRetryAction18),
  retryAction: Optional(TRetryAction18),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest29)
});
var TRetryManifestEntry14 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry14 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString29,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString29),
  mostRecentlyAttemptedAt: Optional(TDateString29),
  finishedAt: Optional(TDateString29),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots14 = Object2({ resolution: Array2(TGraphNodeId14), runtime: Array2(TGraphNodeId14) });
var TRunGraph14 = Object2({
  roots: TGraphRoots14,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId14, Array2(TGraphNodeId14)),
    runtime: Record(TGraphNodeId14, Array2(TGraphNodeId14))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId14, Array2(TGraphNodeId14)),
    runtime: Record(TGraphNodeId14, Array2(TGraphNodeId14))
  }),
  subgraphs: Record(TGraphNodeId14, Object2({ roots: TGraphRoots14 })),
  parents: Record(TGraphNodeId14, TGraphNodeId14),
  definitionOrders: Record(TGraphNodeId14, Number2())
});
var TActor14 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState14 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState14)
});
var ApprovalRequestState11 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState11 || {});
var TApprovalRequest11 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState11)
});
var TRun14 = Object2({
  schemaVersion: Literal(ThisSchemaVersion14),
  persistenceExpiresAtSeconds: TEpochSeconds14,
  runId: String2(),
  createdAt: TDateString29,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor14),
  mintDirectoryArtifact: Optional(TArtifact29),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool14),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration14),
  eventNumber: Number2(),
  retries: Array2(TRetry14),
  approvalRequests: Array2(TApprovalRequest11),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph14,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry14)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey14, TConcurrencyPoolState14),
  baseLayer: TBaseLayerDescriptor8,
  crossRunSource: TCrossRunSource4,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus14),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus14),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus14),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus14),
  resultStatus: Enum(RunResultStatus14),
  waitingForLeaseAt: Optional(TDateString29),
  startedAt: Optional(TDateString29),
  cancellationRequestedAt: Optional(TDateString29),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString29)
});

// ../packages/schema/persisted/versioned/v52.ts
var ThisSchemaVersion15 = "v52" /* V52 */;
var TTaskOrGroupId30 = TBrandedString();
var TGraphNodeId15 = TBrandedString();
var TTemplateString15 = TBrandedString();
var TEvaluatedString15 = TBrandedString();
var TDateString30 = TBrandedString();
var TEpochSeconds15 = TBrandedNumber();
var TScopedTaskKey15 = TBrandedString();
var TaskType15 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType15 || {});
var TaskResultStatus15 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus15 || {});
var TaskExecutionStatus15 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus15 || {});
var TaskExecutionWaitingSubStatus15 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus15 || {});
var TaskExecutionAbortedSubStatus15 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus15 || {});
var TaskExecutionFinishedSubStatus15 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus15 || {});
var TaskAttemptReason15 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason15 || {});
var BackgroundProcessResultStatus30 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus30 || {});
var BackgroundProcessResultFinishedSubStatus30 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus30 || {});
var RunResultStatus15 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus15 || {});
var RunExecutionStatus15 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus15 || {});
var RunExecutionWaitingSubStatus15 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus15 || {});
var RunExecutionAbortedSubStatus15 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus15 || {});
var RunExecutionFinishedSubStatus15 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus15 || {});
var TSource15 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey28 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey28 || {});
var TExpandedEnvDescriptor15 = Object2({ value: Optional(TTemplateString15), cacheKey: Enum(EnvironmentVariableCacheKey28) });
var TEnvMergeStrategy15 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath30 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern30 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity30 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity30 || {});
var TProblemMatcher30 = Object2({ owner: String2(), severity: Optional(Enum(Severity30)), pattern: Array2(TProblemMatcherPattern30) });
var TProblemPath30 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath15 = Object2({ key: String2(), path: TTemplateString15 });
var TResolvedArtifactPath13 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck15 = Object2({ run: TTemplateString15, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess15 = Object2({
  key: String2(),
  command: TTemplateString15,
  readyCheck: Optional(TExpandedReadyCheck15),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType15 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType15 || {});
var TParallelismValue15 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification15 = Object2({
  cpus: Optional(TTemplateString15),
  memory: Optional(TTemplateString15),
  disk: Object2({ size: Optional(TTemplateString15) }),
  staticIps: Optional(TTemplateString15),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification15 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs15 = Object2({
  values: Optional(Record(String2(), TTemplateString15)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor6 = Object2({ path: TTemplateString15, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor6 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet6 = Union([TTemplateString15, Array2(Union([TTemplateString15, TFilterDescriptor6]))]);
var TInputFilesystemFilter15 = Object2({
  workspace: Optional(TFilterSet6),
  artifacts: Optional(Record(TTemplateString15, TFilterSet6))
});
var TOutputFilesystemFilter15 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration8 = Object2({
  enabled: TTemplateString15,
  ttl: Optional(TTemplateString15)
});
var TTaskDefinitionWithoutParallel15 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification15),
  type: Optional(Enum(TaskType15)),
  after: Optional(TTemplateString15),
  if: Optional(TTemplateString15),
  source: Optional(TSource15),
  cacheConfiguration: TCacheConfiguration8,
  docker: Optional(TTemplateString15),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString15),
  filter: Optional(TInputFilesystemFilter15),
  backgroundProcesses: Optional(Array2(TBackgroundProcess15)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor15)),
  envMerge: Optional(Array2(TEnvMergeStrategy15)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath30)),
  artifactPaths: Optional(Array2(TArtifactPath15)),
  outputs: Optional(TTaskDefinitionOutputs15),
  problemMatchers: Optional(Array2(TProblemMatcher30)),
  problemPaths: Optional(Array2(TProblemPath30)),
  parallelismType: Optional(Enum(ParallelismType15)),
  parallelismValue: Optional(TParallelismValue15),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString15)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString15),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter15)
});
var TCrossRunSource5 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents5 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource5,
  relativeScopedKey: String2()
});
var TTaskDefinition15 = Composite([
  TTaskDefinitionWithoutParallel15,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel15),
    parallelKey: Optional(TTemplateString15),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString15), TTemplateString15]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString15)), TTemplateString15])),
    parallelismTotal: Optional(TTemplateString15)
  })
]);
var TLayerWithManifest30 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId30,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext15 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret15 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess15 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString15,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString15,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult30 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus30),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus30),
  startedAt: Optional(TDateString30),
  completedAt: Optional(TDateString30),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem30 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity30),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults30 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest20 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact30 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest20, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact15 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor6)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor6))
      })
    )
  )
});
var TGithubStatusCheck2 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration15 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow15 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow15 || {});
var TConcurrencyPool15 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow15) });
var LeaseState15 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState15 || {});
var TTiming22 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps22 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming22)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming22)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming22),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming22),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming22.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming22),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming22),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming22),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming22),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming22),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming22),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming22),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming22)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming22.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic15 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction19 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact30)
});
var TBaseLayerSpecificationTriple9 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId9 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification9 = Union([TBaseLayerSpecificationTriple9, TBaseLayerSpecificationLayerId9]);
var TBaseLayerDescriptor9 = Composite([
  TBaseLayerSpecificationTriple9,
  TBaseLayerSpecificationLayerId9,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit8 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit8 || {});
var TTTL8 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit8)
});
var TResolvedCacheConfiguration8 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL8)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip7 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask15 = Object2({
  schemaVersion: Literal(ThisSchemaVersion15),
  taskId: TTaskOrGroupId30,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId15),
  generatorTaskId: Optional(TTaskOrGroupId30),
  definition: TTaskDefinition15,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus15),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus15),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus15),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus15),
  resultStatus: Enum(TaskResultStatus15),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason15)),
  resolvedAt: Optional(TDateString30),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString30),
  debugReadyAt: Optional(TDateString30),
  debugStartedAt: Optional(TDateString30),
  debugEndedAt: Optional(TDateString30),
  cancellationRequestedAt: Optional(TDateString30),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString30),
  cancelledAt: Optional(TDateString30),
  concurrencyPool: Optional(TConcurrencyPool15),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext15),
  usedSecrets: Optional(Array2(TUsedSecret15)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration8),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString15, cacheKey: Enum(EnvironmentVariableCacheKey28) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString15),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess15)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact15)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest30)),
  previousLayers: Optional(Array2(TLayerWithManifest30)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest30)),
  filesystemLayers: Optional(Array2(TLayerWithManifest30)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString15)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration15),
      baseLayer: TBaseLayerDescriptor9,
      crossRunSource: Optional(TCrossRunSource5)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification15),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath13)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult30)),
  whiteoutLayer: Optional(TLayerWithManifest30),
  outputLayers: Optional(Array2(TLayerWithManifest30)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey28) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem30)),
  testResults: Optional(Array2(TTestResults30)),
  artifacts: Optional(Array2(TArtifact30)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents5),
  tips: Array2(TTip7),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps22,
  networkTraffic: TNetworkTraffic15,
  outputRetryActions: Array2(TRetryAction19),
  retryAction: Optional(TRetryAction19),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest30)
});
var TRetryManifestEntry15 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry15 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString30,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString30),
  mostRecentlyAttemptedAt: Optional(TDateString30),
  finishedAt: Optional(TDateString30),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots15 = Object2({ resolution: Array2(TGraphNodeId15), runtime: Array2(TGraphNodeId15) });
var TRunGraph15 = Object2({
  roots: TGraphRoots15,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId15, Array2(TGraphNodeId15)),
    runtime: Record(TGraphNodeId15, Array2(TGraphNodeId15))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId15, Array2(TGraphNodeId15)),
    runtime: Record(TGraphNodeId15, Array2(TGraphNodeId15))
  }),
  subgraphs: Record(TGraphNodeId15, Object2({ roots: TGraphRoots15 })),
  parents: Record(TGraphNodeId15, TGraphNodeId15),
  definitionOrders: Record(TGraphNodeId15, Number2())
});
var TActor15 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState15 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState15)
});
var ApprovalRequestState12 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState12 || {});
var TApprovalRequest12 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState12)
});
var TRun15 = Object2({
  schemaVersion: Literal(ThisSchemaVersion15),
  persistenceExpiresAtSeconds: TEpochSeconds15,
  runId: String2(),
  createdAt: TDateString30,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor15),
  mintDirectoryArtifact: Optional(TArtifact30),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck2),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool15),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration15),
  eventNumber: Number2(),
  retries: Array2(TRetry15),
  approvalRequests: Array2(TApprovalRequest12),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph15,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry15)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey15, TConcurrencyPoolState15),
  baseLayer: TBaseLayerDescriptor9,
  crossRunSource: TCrossRunSource5,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus15),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus15),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus15),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus15),
  resultStatus: Enum(RunResultStatus15),
  waitingForLeaseAt: Optional(TDateString30),
  startedAt: Optional(TDateString30),
  cancellationRequestedAt: Optional(TDateString30),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString30)
});

// ../packages/schema/persisted/versioned/v53.ts
var ThisSchemaVersion16 = "v53" /* V53 */;
var TTaskOrGroupId31 = TBrandedString();
var TGraphNodeId16 = TBrandedString();
var TTemplateString16 = TBrandedString();
var TEvaluatedString16 = TBrandedString();
var TDateString31 = TBrandedString();
var TEpochSeconds16 = TBrandedNumber();
var TScopedTaskKey16 = TBrandedString();
var TaskType16 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType16 || {});
var TaskResultStatus16 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus16 || {});
var TaskExecutionStatus16 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus16 || {});
var TaskExecutionWaitingSubStatus16 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus16 || {});
var TaskExecutionAbortedSubStatus16 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus16 || {});
var TaskExecutionFinishedSubStatus16 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus16 || {});
var TaskAttemptReason16 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason16 || {});
var BackgroundProcessResultStatus31 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus31 || {});
var BackgroundProcessResultFinishedSubStatus31 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus31 || {});
var RunResultStatus16 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus16 || {});
var RunExecutionStatus16 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus16 || {});
var RunExecutionWaitingSubStatus16 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus16 || {});
var RunExecutionAbortedSubStatus16 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus16 || {});
var RunExecutionFinishedSubStatus16 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus16 || {});
var TSource16 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey29 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey29 || {});
var TExpandedEnvDescriptor16 = Object2({ value: Optional(TTemplateString16), cacheKey: Enum(EnvironmentVariableCacheKey29) });
var TEnvMergeStrategy16 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath31 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern31 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity31 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity31 || {});
var TProblemMatcher31 = Object2({ owner: String2(), severity: Optional(Enum(Severity31)), pattern: Array2(TProblemMatcherPattern31) });
var TProblemPath31 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath16 = Object2({ key: String2(), path: TTemplateString16 });
var TResolvedArtifactPath14 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck16 = Object2({ run: TTemplateString16, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess16 = Object2({
  key: String2(),
  command: TTemplateString16,
  readyCheck: Optional(TExpandedReadyCheck16),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType16 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType16 || {});
var TParallelismValue16 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification16 = Object2({
  cpus: Optional(TTemplateString16),
  memory: Optional(TTemplateString16),
  disk: Object2({ size: Optional(TTemplateString16) }),
  staticIps: Optional(TTemplateString16),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification16 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs16 = Object2({
  values: Optional(Record(String2(), TTemplateString16)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor7 = Object2({ path: TTemplateString16, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor7 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet7 = Union([TTemplateString16, Array2(Union([TTemplateString16, TFilterDescriptor7]))]);
var TInputFilesystemFilter16 = Object2({
  workspace: Optional(TFilterSet7),
  artifacts: Optional(Record(TTemplateString16, TFilterSet7))
});
var TOutputFilesystemFilter16 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration9 = Object2({
  enabled: TTemplateString16,
  ttl: Optional(TTemplateString16)
});
var TTaskDefinitionWithoutParallel16 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification16),
  type: Optional(Enum(TaskType16)),
  after: Optional(TTemplateString16),
  if: Optional(TTemplateString16),
  source: Optional(TSource16),
  cacheConfiguration: TCacheConfiguration9,
  docker: Optional(TTemplateString16),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString16),
  filter: Optional(TInputFilesystemFilter16),
  backgroundProcesses: Optional(Array2(TBackgroundProcess16)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor16)),
  envMerge: Optional(Array2(TEnvMergeStrategy16)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath31)),
  artifactPaths: Optional(Array2(TArtifactPath16)),
  outputs: Optional(TTaskDefinitionOutputs16),
  problemMatchers: Optional(Array2(TProblemMatcher31)),
  problemPaths: Optional(Array2(TProblemPath31)),
  parallelismType: Optional(Enum(ParallelismType16)),
  parallelismValue: Optional(TParallelismValue16),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString16)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString16),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter16)
});
var TCrossRunSource6 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents6 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource6,
  relativeScopedKey: String2()
});
var TTaskDefinition16 = Composite([
  TTaskDefinitionWithoutParallel16,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel16),
    parallelKey: Optional(TTemplateString16),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString16), TTemplateString16]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString16)), TTemplateString16])),
    parallelismTotal: Optional(TTemplateString16)
  })
]);
var TLayerWithManifest31 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId31,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext16 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret16 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess16 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString16,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString16,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult31 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus31),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus31),
  startedAt: Optional(TDateString31),
  completedAt: Optional(TDateString31),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem31 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity31),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults31 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest21 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact31 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest21, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact16 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor7)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor7))
      })
    )
  )
});
var TGithubStatusCheck3 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration16 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow16 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow16 || {});
var TConcurrencyPool16 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow16) });
var LeaseState16 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState16 || {});
var TTiming23 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps23 = Object2({
  // layers contains 1 entry for each layer used by a task. If a layer already exists on the agent, `download` will be undefined.
  layers: Optional(
    Array2(
      Object2({
        layerId: String2(),
        cached: Boolean2(),
        sizeInBytes: Number2(),
        download: Optional(TTiming23)
      })
    )
  ),
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming23)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming23),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming23),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming23.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming23),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming23),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming23),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming23),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming23),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming23),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming23),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming23)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming23.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic16 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction20 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact31)
});
var TBaseLayerSpecificationTriple10 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId10 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification10 = Union([TBaseLayerSpecificationTriple10, TBaseLayerSpecificationLayerId10]);
var TBaseLayerDescriptor10 = Composite([
  TBaseLayerSpecificationTriple10,
  TBaseLayerSpecificationLayerId10,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit9 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit9 || {});
var TTTL9 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit9)
});
var TResolvedCacheConfiguration9 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL9)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip8 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask16 = Object2({
  schemaVersion: Literal(ThisSchemaVersion16),
  taskId: TTaskOrGroupId31,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId16),
  generatorTaskId: Optional(TTaskOrGroupId31),
  definition: TTaskDefinition16,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus16),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus16),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus16),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus16),
  resultStatus: Enum(TaskResultStatus16),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason16)),
  resolvedAt: Optional(TDateString31),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString31),
  debugReadyAt: Optional(TDateString31),
  debugStartedAt: Optional(TDateString31),
  debugEndedAt: Optional(TDateString31),
  cancellationRequestedAt: Optional(TDateString31),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString31),
  cancelledAt: Optional(TDateString31),
  concurrencyPool: Optional(TConcurrencyPool16),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext16),
  usedSecrets: Optional(Array2(TUsedSecret16)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration9),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString16, cacheKey: Enum(EnvironmentVariableCacheKey29) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString16),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess16)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact16)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest31)),
  previousLayers: Optional(Array2(TLayerWithManifest31)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest31)),
  filesystemLayers: Optional(Array2(TLayerWithManifest31)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString16)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration16),
      baseLayer: TBaseLayerDescriptor10,
      crossRunSource: Optional(TCrossRunSource6)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification16),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath14)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult31)),
  whiteoutLayer: Optional(TLayerWithManifest31),
  outputLayers: Optional(Array2(TLayerWithManifest31)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey29) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem31)),
  testResults: Optional(Array2(TTestResults31)),
  artifacts: Optional(Array2(TArtifact31)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents6),
  tips: Array2(TTip8),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps23,
  networkTraffic: TNetworkTraffic16,
  outputRetryActions: Array2(TRetryAction20),
  retryAction: Optional(TRetryAction20),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest31)
});
var TRetryManifestEntry16 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry16 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString31,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString31),
  mostRecentlyAttemptedAt: Optional(TDateString31),
  finishedAt: Optional(TDateString31),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots16 = Object2({ resolution: Array2(TGraphNodeId16), runtime: Array2(TGraphNodeId16) });
var TRunGraph16 = Object2({
  roots: TGraphRoots16,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId16, Array2(TGraphNodeId16)),
    runtime: Record(TGraphNodeId16, Array2(TGraphNodeId16))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId16, Array2(TGraphNodeId16)),
    runtime: Record(TGraphNodeId16, Array2(TGraphNodeId16))
  }),
  subgraphs: Record(TGraphNodeId16, Object2({ roots: TGraphRoots16 })),
  parents: Record(TGraphNodeId16, TGraphNodeId16),
  definitionOrders: Record(TGraphNodeId16, Number2())
});
var TActor16 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState16 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState16)
});
var ApprovalRequestState13 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState13 || {});
var TApprovalRequest13 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState13)
});
var TRun16 = Object2({
  schemaVersion: Literal(ThisSchemaVersion16),
  persistenceExpiresAtSeconds: TEpochSeconds16,
  runId: String2(),
  createdAt: TDateString31,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor16),
  mintDirectoryArtifact: Optional(TArtifact31),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck3),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool16),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration16),
  eventNumber: Number2(),
  retries: Array2(TRetry16),
  approvalRequests: Array2(TApprovalRequest13),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph16,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry16)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey16, TConcurrencyPoolState16),
  baseLayer: TBaseLayerDescriptor10,
  crossRunSource: TCrossRunSource6,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus16),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus16),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus16),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus16),
  resultStatus: Enum(RunResultStatus16),
  waitingForLeaseAt: Optional(TDateString31),
  startedAt: Optional(TDateString31),
  cancellationRequestedAt: Optional(TDateString31),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString31),
  warningMessages: Array2(TUserMessage)
});

// ../packages/schema/persisted/versioned/v54.ts
var ThisSchemaVersion17 = "v54" /* V54 */;
var TTaskOrGroupId32 = TBrandedString();
var TGraphNodeId17 = TBrandedString();
var TTemplateString17 = TBrandedString();
var TEvaluatedString17 = TBrandedString();
var TDateString32 = TBrandedString();
var TEpochSeconds17 = TBrandedNumber();
var TScopedTaskKey17 = TBrandedString();
var TaskType17 = /* @__PURE__ */ ((TaskType18) => {
  TaskType18["Command"] = "command";
  TaskType18["Leaf"] = "leaf";
  TaskType18["EmbeddedRun"] = "embedded-run";
  TaskType18["Parallel"] = "parallel";
  return TaskType18;
})(TaskType17 || {});
var TaskResultStatus17 = /* @__PURE__ */ ((TaskResultStatus18) => {
  TaskResultStatus18["Succeeded"] = "succeeded";
  TaskResultStatus18["Failed"] = "failed";
  TaskResultStatus18["NoResult"] = "no_result";
  return TaskResultStatus18;
})(TaskResultStatus17 || {});
var TaskExecutionStatus17 = /* @__PURE__ */ ((TaskExecutionStatus18) => {
  TaskExecutionStatus18["NotGenerated"] = "not_generated";
  TaskExecutionStatus18["Waiting"] = "waiting";
  TaskExecutionStatus18["Ready"] = "ready";
  TaskExecutionStatus18["Running"] = "running";
  TaskExecutionStatus18["Finished"] = "finished";
  TaskExecutionStatus18["Aborted"] = "aborted";
  TaskExecutionStatus18["Skipped"] = "skipped";
  TaskExecutionStatus18["UserError"] = "user_error";
  return TaskExecutionStatus18;
})(TaskExecutionStatus17 || {});
var TaskExecutionWaitingSubStatus17 = /* @__PURE__ */ ((TaskExecutionWaitingSubStatus18) => {
  TaskExecutionWaitingSubStatus18["NotReady"] = "not_ready";
  TaskExecutionWaitingSubStatus18["WaitingForApproval"] = "waiting_for_approval";
  TaskExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  TaskExecutionWaitingSubStatus18["WaitingForDuplicateTask"] = "waiting_for_duplicate_task";
  TaskExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionWaitingSubStatus18;
})(TaskExecutionWaitingSubStatus17 || {});
var TaskExecutionAbortedSubStatus17 = /* @__PURE__ */ ((TaskExecutionAbortedSubStatus18) => {
  TaskExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  TaskExecutionAbortedSubStatus18["SubtasksRetried"] = "subtasks_retried";
  TaskExecutionAbortedSubStatus18["Terminated"] = "terminated";
  TaskExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  TaskExecutionAbortedSubStatus18["ApprovalRequestDenied"] = "approval_request_denied";
  TaskExecutionAbortedSubStatus18["BackgroundProcessFailure"] = "background_process_failure";
  TaskExecutionAbortedSubStatus18["BeforeHookFailure"] = "before_hook_failure";
  TaskExecutionAbortedSubStatus18["AfterHookFailure"] = "after_hook_failure";
  TaskExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  TaskExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionAbortedSubStatus18;
})(TaskExecutionAbortedSubStatus17 || {});
var TaskExecutionFinishedSubStatus17 = /* @__PURE__ */ ((TaskExecutionFinishedSubStatus18) => {
  TaskExecutionFinishedSubStatus18["CacheHit"] = "cache_hit";
  TaskExecutionFinishedSubStatus18["Executed"] = "executed";
  TaskExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return TaskExecutionFinishedSubStatus18;
})(TaskExecutionFinishedSubStatus17 || {});
var TaskAttemptReason17 = /* @__PURE__ */ ((TaskAttemptReason18) => {
  TaskAttemptReason18["Unknown"] = "unknown";
  TaskAttemptReason18["Initial"] = "initial";
  TaskAttemptReason18["Retried"] = "retried";
  TaskAttemptReason18["SubtaskRetried"] = "subtask_retried";
  TaskAttemptReason18["DependencyRetried"] = "dependency_retried";
  return TaskAttemptReason18;
})(TaskAttemptReason17 || {});
var BackgroundProcessResultStatus32 = /* @__PURE__ */ ((BackgroundProcessResultStatus33) => {
  BackgroundProcessResultStatus33["Skipped"] = "skipped";
  BackgroundProcessResultStatus33["Finished"] = "finished";
  BackgroundProcessResultStatus33["ReadyCheckTimedOut"] = "ready_check_timed_out";
  return BackgroundProcessResultStatus33;
})(BackgroundProcessResultStatus32 || {});
var BackgroundProcessResultFinishedSubStatus32 = /* @__PURE__ */ ((BackgroundProcessResultFinishedSubStatus33) => {
  BackgroundProcessResultFinishedSubStatus33["Stopped"] = "stopped";
  BackgroundProcessResultFinishedSubStatus33["Signaled"] = "signaled";
  BackgroundProcessResultFinishedSubStatus33["NotApplicable"] = "not_applicable";
  return BackgroundProcessResultFinishedSubStatus33;
})(BackgroundProcessResultFinishedSubStatus32 || {});
var RunResultStatus17 = /* @__PURE__ */ ((RunResultStatus18) => {
  RunResultStatus18["Succeeded"] = "succeeded";
  RunResultStatus18["Failed"] = "failed";
  RunResultStatus18["Debugged"] = "debugged";
  RunResultStatus18["NoResult"] = "no_result";
  return RunResultStatus18;
})(RunResultStatus17 || {});
var RunExecutionStatus17 = /* @__PURE__ */ ((RunExecutionStatus18) => {
  RunExecutionStatus18["Waiting"] = "waiting";
  RunExecutionStatus18["InProgress"] = "in_progress";
  RunExecutionStatus18["Finished"] = "finished";
  RunExecutionStatus18["Aborted"] = "aborted";
  return RunExecutionStatus18;
})(RunExecutionStatus17 || {});
var RunExecutionWaitingSubStatus17 = /* @__PURE__ */ ((RunExecutionWaitingSubStatus18) => {
  RunExecutionWaitingSubStatus18["WaitingForLease"] = "waiting_for_lease";
  RunExecutionWaitingSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionWaitingSubStatus18;
})(RunExecutionWaitingSubStatus17 || {});
var RunExecutionAbortedSubStatus17 = /* @__PURE__ */ ((RunExecutionAbortedSubStatus18) => {
  RunExecutionAbortedSubStatus18["Cancelled"] = "cancelled";
  RunExecutionAbortedSubStatus18["TimedOut"] = "timed_out";
  RunExecutionAbortedSubStatus18["InternalFailure"] = "internal_failure";
  RunExecutionAbortedSubStatus18["InitializationError"] = "initialization_error";
  RunExecutionAbortedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionAbortedSubStatus18;
})(RunExecutionAbortedSubStatus17 || {});
var RunExecutionFinishedSubStatus17 = /* @__PURE__ */ ((RunExecutionFinishedSubStatus18) => {
  RunExecutionFinishedSubStatus18["NotApplicable"] = "not_applicable";
  return RunExecutionFinishedSubStatus18;
})(RunExecutionFinishedSubStatus17 || {});
var TSource17 = Object2({ definition: String2(), start: Number2(), end: Number2() });
var EnvironmentVariableCacheKey30 = /* @__PURE__ */ ((EnvironmentVariableCacheKey31) => {
  EnvironmentVariableCacheKey31["Included"] = "included";
  EnvironmentVariableCacheKey31["Excluded"] = "excluded";
  return EnvironmentVariableCacheKey31;
})(EnvironmentVariableCacheKey30 || {});
var TExpandedEnvDescriptor17 = Object2({ value: Optional(TTemplateString17), cacheKey: Enum(EnvironmentVariableCacheKey30) });
var TEnvMergeStrategy17 = Object2({ name: String2(), override: Optional(Literal(true)), joinBy: Optional(String2()) });
var TTestResultsPath32 = Object2({ path: String2(), options: Optional(Object2({ framework: String2(), language: String2() })) });
var TProblemMatcherPattern32 = Object2({
  regexp: String2(),
  file: Optional(Integer()),
  fromPath: Optional(Integer()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  severity: Optional(Integer()),
  code: Optional(Integer()),
  message: Optional(Integer()),
  loop: Optional(Boolean2())
});
var Severity32 = /* @__PURE__ */ ((Severity33) => {
  Severity33["Error"] = "error";
  Severity33["Warning"] = "warning";
  Severity33["Info"] = "info";
  return Severity33;
})(Severity32 || {});
var TProblemMatcher32 = Object2({ owner: String2(), severity: Optional(Enum(Severity32)), pattern: Array2(TProblemMatcherPattern32) });
var TProblemPath32 = Object2({
  format: TLiteralUnion(["auto", "problem-json", "github-annotation-json", "github-annotations-action-json"]),
  path: String2()
});
var TArtifactPath17 = Object2({ key: String2(), path: TTemplateString17 });
var TResolvedArtifactPath15 = Object2({ key: String2(), path: String2() });
var TExpandedReadyCheck17 = Object2({ run: TTemplateString17, timeoutSeconds: Number2(), timeoutUserConfigured: Boolean2() });
var TBackgroundProcess17 = Object2({
  key: String2(),
  command: TTemplateString17,
  readyCheck: Optional(TExpandedReadyCheck17),
  after: Optional(Array2(String2())),
  terminateGracePeriodSeconds: Number2()
});
var ParallelismType17 = /* @__PURE__ */ ((ParallelismType18) => {
  ParallelismType18["Matrix"] = "matrix";
  ParallelismType18["Total"] = "total";
  ParallelismType18["Values"] = "values";
  return ParallelismType18;
})(ParallelismType17 || {});
var TParallelismValue17 = Record(String2(), Union([String2(), Number2(), Boolean2()]));
var TAgentSpecification17 = Object2({
  cpus: Optional(TTemplateString17),
  memory: Optional(TTemplateString17),
  disk: Object2({ size: Optional(TTemplateString17) }),
  staticIps: Optional(TTemplateString17),
  tmpfs: Optional(Boolean2())
});
var TResolvedAgentSpecification17 = Object2({
  cpus: Number2(),
  memoryBytes: Number2(),
  diskSizeGigabytes: Number2(),
  subnetDefaultRoutes: Optional(Record(String2(), String2())),
  tmpfs: Optional(Boolean2())
});
var TTaskDefinitionOutputs17 = Object2({
  values: Optional(Record(String2(), TTemplateString17)),
  valuesFrom: Optional(Array2(String2()))
});
var TFilterDescriptor8 = Object2({ path: TTemplateString17, cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TResolvedFilterDescriptor8 = Object2({ path: String2(), cacheKey: Union([Literal("included"), Literal("excluded")]) });
var TFilterSet8 = Union([TTemplateString17, Array2(Union([TTemplateString17, TFilterDescriptor8]))]);
var TInputFilesystemFilter17 = Object2({
  workspace: Optional(TFilterSet8),
  artifacts: Optional(Record(TTemplateString17, TFilterSet8))
});
var TOutputFilesystemFilter17 = Object2({
  workspace: Optional(Array2(String2())),
  system: Optional(Array2(String2()))
});
var TCacheConfiguration10 = Object2({
  enabled: TTemplateString17,
  ttl: Optional(TTemplateString17)
});
var TTaskDefinitionWithoutParallel17 = Object2({
  key: String2(),
  scope: Array2(String2()),
  agentSpecification: Optional(TAgentSpecification17),
  type: Optional(Enum(TaskType17)),
  after: Optional(TTemplateString17),
  if: Optional(TTemplateString17),
  source: Optional(TSource17),
  cacheConfiguration: TCacheConfiguration10,
  docker: Optional(TTemplateString17),
  dependencyStandardKeys: Optional(Array2(String2())),
  command: Optional(TTemplateString17),
  filter: Optional(TInputFilesystemFilter17),
  backgroundProcesses: Optional(Array2(TBackgroundProcess17)),
  toolCache: Optional(String2()),
  envInheritFromTasks: Optional(Array2(String2())),
  envVars: Optional(Record(String2(), TExpandedEnvDescriptor17)),
  envMerge: Optional(Array2(TEnvMergeStrategy17)),
  timeoutMinutes: Optional(Number2()),
  timeoutUserConfigured: Optional(Boolean2()),
  terminateGracePeriodSeconds: Optional(Number2()),
  successExitCodes: Optional(Array2(Number2())),
  testResultsPaths: Optional(Array2(TTestResultsPath32)),
  artifactPaths: Optional(Array2(TArtifactPath17)),
  outputs: Optional(TTaskDefinitionOutputs17),
  problemMatchers: Optional(Array2(TProblemMatcher32)),
  problemPaths: Optional(Array2(TProblemPath32)),
  parallelismType: Optional(Enum(ParallelismType17)),
  parallelismValue: Optional(TParallelismValue17),
  leafDigest: Optional(String2()),
  leafNameVersion: Optional(Object2({ name: String2(), version: String2() })),
  parameters: Optional(Record(String2(), TTemplateString17)),
  emebeddedRunDefinitionTemplate: Optional(TTemplateString17),
  emebeddedRunDefinitionMintDirPath: Optional(String2()),
  embeddedRunDefinitionTargets: Optional(Array2(String2())),
  warningMessages: Array2(TUserMessage),
  outputFilesystemFilter: Optional(TOutputFilesystemFilter17)
});
var TCrossRunSource7 = Union([String2(), Object2({ crossRunIdentifier: String2(), artifactKey: String2() })]);
var TCrossRunIdentityComponents7 = Object2({
  ownerScope: String2(),
  crossRunSource: TCrossRunSource7,
  relativeScopedKey: String2()
});
var TTaskDefinition17 = Composite([
  TTaskDefinitionWithoutParallel17,
  Object2({
    parallelTemplateDefinition: Optional(TTaskDefinitionWithoutParallel17),
    parallelKey: Optional(TTemplateString17),
    parallelTasksLimit: Optional(Union([Number2(), Null()])),
    parallelismMatrix: Optional(Record(String2(), Union([Array2(TTemplateString17), TTemplateString17]))),
    parallelismValues: Optional(Union([Array2(Record(String2(), TTemplateString17)), TTemplateString17])),
    parallelismTotal: Optional(TTemplateString17)
  })
]);
var TLayerWithManifest32 = Object2({
  layerId: String2(),
  layerSizeBytes: Number2(),
  layerKind: Union([Literal("output"), Literal("whiteout"), Literal("tool-cache"), Literal("base"), Literal("docker"), Literal("docker-tool-cache")]),
  groupingKey: String2(),
  manifestId: String2(),
  manifestVersion: Enum(SchemaVersion),
  manifestFileName: String2(),
  manifestSizeBytes: Number2(),
  associatedWithTaskId: TTaskOrGroupId32,
  associatedWithTaskKey: String2()
});
var TSanitizedResolutionContext17 = Union([String2(), Record(String2(), Any())]);
var TUsedSecret17 = Object2({
  vaultId: String2(),
  secretName: String2()
});
var TResolvedBackgroundProcess17 = Object2({
  id: String2(),
  logsId: String2(),
  key: String2(),
  command: TEvaluatedString17,
  readyCheck: Optional(
    Object2({
      run: TEvaluatedString17,
      timeoutSeconds: Number2(),
      timeoutUserConfigured: Boolean2(),
      logsId: Optional(String2())
    })
  ),
  after: Array2(String2()),
  terminateGracePeriodSeconds: Number2()
});
var TBackgroundProcessResult32 = Object2({
  key: String2(),
  id: String2(),
  logsId: String2(),
  resultStatus: Enum(BackgroundProcessResultStatus32),
  resultFinishedSubStatus: Enum(BackgroundProcessResultFinishedSubStatus32),
  startedAt: Optional(TDateString32),
  completedAt: Optional(TDateString32),
  exitCode: Optional(Number2()),
  signal: Optional(String2()),
  readyCheckStdout: Optional(String2()),
  readyCheckStderr: Optional(String2()),
  readyCheckLogsId: Optional(String2())
});
var TProblem32 = Object2({
  owner: String2(),
  message: String2(),
  severity: Enum(Severity32),
  code: Optional(String2()),
  file: Optional(String2()),
  fromPath: Optional(String2()),
  line: Optional(Integer()),
  column: Optional(Integer()),
  end_line: Optional(Integer()),
  end_column: Optional(Integer())
});
var TTestResults32 = Object2({
  type: TLiteralUnion(["rwx_v1_json", "opaque_blob", "error"]),
  originalPath: String2(),
  contentAddress: Optional(String2()),
  numberOfTests: Optional(Number2()),
  numberOfFailures: Optional(Number2()),
  numberOfQuarantinedTests: Optional(Number2()),
  numberOfRetriedTests: Optional(Number2()),
  numberOfOtherErrors: Optional(Number2()),
  artifactAddresses: Optional(Array2(String2())),
  errorMessage: Optional(String2())
});
var TArtifactManifest22 = Object2({
  id: String2(),
  version: Enum(SchemaVersion),
  fileName: String2(),
  sizeInBytes: Number2()
});
var TArtifact32 = Object2({
  kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
  key: String2(),
  originalPath: String2(),
  contentAddress: Union([String2(), Null()]),
  sizeInBytes: Number2({ minimum: 0 }),
  manifest: Union([TArtifactManifest22, Null()]),
  compression: Union([Literal("gzip"), Null()])
});
var TReferencedArtifact17 = Object2({
  kind: TLiteralUnion(["parallel", "file", "directory", "does-not-exist"]),
  contentAddress: Union([String2(), Null()]),
  path: String2(),
  compression: Union([Literal("gzip"), Null()]),
  scopedKey: String2(),
  filter: Optional(Array2(TResolvedFilterDescriptor8)),
  subtaskArtifacts: Optional(
    Array2(
      Object2({
        kind: TLiteralUnion(["file", "directory", "does-not-exist"]),
        contentAddress: Union([String2(), Null()]),
        path: String2(),
        compression: Union([Literal("gzip"), Null()]),
        scopedKey: String2(),
        filter: Optional(Array2(TResolvedFilterDescriptor8))
      })
    )
  )
});
var TGithubStatusCheck4 = Object2({
  tasks: Array2(String2()),
  name: Optional(String2()),
  status: Union([Literal("success"), Literal("failure"), Literal("pending")])
});
var TRunToolCacheConfiguration17 = Object2({ vaultId: String2(), shouldReset: Optional(Boolean2()) });
var OnOverflow17 = /* @__PURE__ */ ((OnOverflow18) => {
  OnOverflow18["CancelWaiting"] = "cancel-waiting";
  OnOverflow18["CancelRunning"] = "cancel-running";
  OnOverflow18["Queue"] = "queue";
  return OnOverflow18;
})(OnOverflow17 || {});
var TConcurrencyPool17 = Object2({ id: String2(), if: Boolean2(), capacity: Number2(), onOverflow: Enum(OnOverflow17) });
var LeaseState17 = /* @__PURE__ */ ((LeaseState18) => {
  LeaseState18["Requested"] = "requested";
  LeaseState18["Acquired"] = "acquired";
  LeaseState18["Revoked"] = "revoked";
  return LeaseState18;
})(LeaseState17 || {});
var TTiming24 = Object2({
  startTimestamp: Optional(Number2()),
  finishTimestamp: Optional(Number2())
});
var TTimestamps24 = Object2({
  // backgroundProcesses contains 1 entry for each background process in the task. If the background process does not have a ready check then `healthyTimestamp` will be undefined. If the background process exits early then `shutdown` will be undefined.
  backgroundProcesses: Optional(
    Array2(
      Object2({
        backgroundProcessId: String2(),
        initializationTimestamp: Optional(Number2()),
        healthyTimestamp: Optional(Number2()),
        shutdown: Optional(TTiming24)
      })
    )
  ),
  // taskSetup encompasses all of the time on an agent before a task begins executing background processes and commands in its container.
  taskSetup: Optional(TTiming24),
  // containerSetup encompasses just the time it takes to build and start the container.
  containerSetup: Optional(TTiming24),
  // layersSetup encompasses all the time it takes to ensure all the layers needed for the task (including the base layer) are on the agent.
  layersSetup: Optional(
    Object2({
      ...TTiming24.properties,
      pulledSizeBytes: Optional(Number2())
    })
  ),
  // taskExecution encompasses all the time running background processes and the command in the container.
  taskExecution: Optional(TTiming24),
  // backgroundProcessesInitialization encompasses just the time to start and verify the readiness of all background processes.
  backgroundProcessesInitialization: Optional(TTiming24),
  // commandExecution encompasses just the time to run the task's command in the container.
  commandExecution: Optional(TTiming24),
  // taskTeardown encompasses all of the time on an agent after a task finishes execution.
  taskTeardown: Optional(TTiming24),
  // backgroundProcessesTeardown encompasses just the time to stop all background processes.
  backgroundProcessesTeardown: Optional(TTiming24),
  // containerTeardown encompasses just the time to clean up the container and stop it.
  containerTeardown: Optional(TTiming24),
  // outputs encompasses the time to upload the layer and manifest produced by the task.
  outputs: Optional(
    Object2({
      layerSizeBytes: Optional(Number2()),
      layerUpload: Optional(TTiming24),
      manifestSizeBytes: Optional(Number2()),
      manifestUpload: Optional(TTiming24)
    })
  ),
  // dockerLayerUpload encompasses the time it takes to persist the docker layer to S3.
  dockerLayerUpload: Optional(
    Object2({
      ...TTiming24.properties,
      pushedSizeBytes: Optional(Number2())
    })
  )
});
var TNetworkTraffic17 = Object2({
  local: Object2({ ingress: Number2(), egress: Number2() }),
  regional: Object2({ ingress: Number2(), egress: Number2() }),
  aws: Object2({ ingress: Number2(), egress: Number2() }),
  public: Object2({ ingress: Number2(), egress: Number2() })
});
var TRetryAction21 = Object2({
  key: String2(),
  label: String2(),
  description: Optional(String2()),
  env: Array2(
    Object2({
      key: String2(),
      value: String2()
    })
  ),
  data: Optional(TArtifact32)
});
var TBaseLayerSpecificationTriple11 = Object2({
  os: String2(),
  tag: String2(),
  arch: TLiteralUnion(["x86_64"])
});
var TBaseLayerSpecificationLayerId11 = Object2({
  layerId: String2()
});
var TBaseLayerSpecification11 = Union([TBaseLayerSpecificationTriple11, TBaseLayerSpecificationLayerId11]);
var TBaseLayerDescriptor11 = Composite([
  TBaseLayerSpecificationTriple11,
  TBaseLayerSpecificationLayerId11,
  Object2({
    layerFile: String2(),
    layerSizeBytes: Number2(),
    user: Object2({
      name: String2(),
      uid: Number2(),
      gid: Number2()
    }),
    group: Object2({
      name: String2(),
      gid: Number2()
    })
  })
]);
var TTLUnit10 = /* @__PURE__ */ ((TTLUnit11) => {
  TTLUnit11["Minutes"] = "minutes";
  TTLUnit11["Hours"] = "hours";
  TTLUnit11["Days"] = "days";
  return TTLUnit11;
})(TTLUnit10 || {});
var TTTL10 = Object2({
  value: Number2(),
  unit: Enum(TTLUnit10)
});
var TResolvedCacheConfiguration10 = Union([
  Object2({
    enabled: Literal(true),
    ttl: Optional(TTTL10)
  }),
  Object2({
    enabled: Literal(false)
  })
]);
var TTip9 = Object2({
  key: String2(),
  details: TUserMessage
});
var TTask17 = Object2({
  schemaVersion: Literal(ThisSchemaVersion17),
  taskId: TTaskOrGroupId32,
  runId: String2(),
  graphNodeId: Optional(TGraphNodeId17),
  generatorTaskId: Optional(TTaskOrGroupId32),
  definition: TTaskDefinition17,
  eventNumber: Number2(),
  executionStatus: Enum(TaskExecutionStatus17),
  executionAbortedSubStatus: Enum(TaskExecutionAbortedSubStatus17),
  executionFinishedSubStatus: Enum(TaskExecutionFinishedSubStatus17),
  executionWaitingSubStatus: Enum(TaskExecutionWaitingSubStatus17),
  resultStatus: Enum(TaskResultStatus17),
  sortOrderInRun: Number2(),
  attemptNumber: Number2(),
  attemptReason: Optional(Enum(TaskAttemptReason17)),
  resolvedAt: Optional(TDateString32),
  agentId: Optional(String2()),
  startedAt: Optional(TDateString32),
  debugReadyAt: Optional(TDateString32),
  debugStartedAt: Optional(TDateString32),
  debugEndedAt: Optional(TDateString32),
  cancellationRequestedAt: Optional(TDateString32),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString32),
  cancelledAt: Optional(TDateString32),
  concurrencyPool: Optional(TConcurrencyPool17),
  waitingForApprovalOnVaultIds: Optional(Array2(String2())),
  // Data after resolving
  cacheKey: Optional(String2()),
  logsId: Optional(String2()),
  resolutionContext: Optional(TSanitizedResolutionContext17),
  usedSecrets: Optional(Array2(TUsedSecret17)),
  resolvedCacheConfiguration: Optional(TResolvedCacheConfiguration10),
  resolvedPreserveDockerData: Optional(Boolean2()),
  resolvedUseDocker: Optional(Boolean2()),
  resolvedEnv: Optional(Record(String2(), Object2({ value: TEvaluatedString17, cacheKey: Enum(EnvironmentVariableCacheKey30) }))),
  resolvedWorkspace: Optional(String2()),
  resolvedCommand: Optional(TEvaluatedString17),
  resolvedBackgroundProcesses: Optional(Array2(TResolvedBackgroundProcess17)),
  resolvedWithinLeaf: Optional(Object2({ digest: String2(), downloadUrl: String2() })),
  resolvedReferencedArtifacts: Optional(Array2(TReferencedArtifact17)),
  toolCacheLayers: Optional(Array2(TLayerWithManifest32)),
  previousLayers: Optional(Array2(TLayerWithManifest32)),
  previousDockerLayers: Optional(Array2(TLayerWithManifest32)),
  filesystemLayers: Optional(Array2(TLayerWithManifest32)),
  resolvedParameters: Optional(Record(String2(), TEvaluatedString17)),
  resolvedRun: Optional(
    Object2({
      toolCacheConfiguration: Optional(TRunToolCacheConfiguration17),
      baseLayer: TBaseLayerDescriptor11,
      crossRunSource: Optional(TCrossRunSource7)
    })
  ),
  resolvedAgentSpecification: Optional(TResolvedAgentSpecification17),
  accessedVaultIds: Optional(Array2(String2())),
  resolvedArtifactPaths: Optional(Array2(TResolvedArtifactPath15)),
  cacheHit: Optional(Boolean2()),
  terminated: Optional(Boolean2()),
  timedOut: Optional(Boolean2()),
  timedOutMessages: Optional(Array2(TUserMessage)),
  skipReasonMessages: Optional(Array2(TUserMessage)),
  userErrorMessages: Optional(Array2(TUserMessage)),
  approximateLogBytes: Optional(Number2()),
  timings: Optional(Record(String2(), Number2())),
  wroteToCache: Optional(Boolean2()),
  exitCode: Optional(Number2()),
  exitCodeSuccess: Optional(Boolean2()),
  signal: Optional(String2()),
  cacheHitFromTaskId: Optional(String2()),
  backgroundProcessResults: Optional(Array2(TBackgroundProcessResult32)),
  whiteoutLayer: Optional(TLayerWithManifest32),
  outputLayers: Optional(Array2(TLayerWithManifest32)),
  environmentVariables: Optional(Array2(Object2({ name: String2(), value: String2(), cacheKey: Enum(EnvironmentVariableCacheKey30) }))),
  values: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  links: Optional(Array2(Object2({ name: String2(), value: String2() }))),
  problems: Optional(Array2(TProblem32)),
  testResults: Optional(Array2(TTestResults32)),
  artifacts: Optional(Array2(TArtifact32)),
  crossRunIdentifier: Optional(String2()),
  crossRunIdentityComponents: Optional(TCrossRunIdentityComponents7),
  tips: Array2(TTip9),
  producedErrorMessages: Optional(Array2(TUserMessage)),
  invalidDynamicTasksMessages: Optional(Array2(TUserMessage)),
  warningMessages: Array2(TUserMessage),
  timestamps: TTimestamps24,
  networkTraffic: TNetworkTraffic17,
  outputRetryActions: Array2(TRetryAction21),
  retryAction: Optional(TRetryAction21),
  retryDebug: Optional(Union([Literal("end"), Literal("start"), Literal(false)])),
  retryCacheStrategy: Optional(TLiteralUnion(["default", "no-cache"])),
  retryRequestedByName: Optional(String2()),
  dockerLayer: Optional(TLayerWithManifest32)
});
var TRetryManifestEntry17 = Object2({
  type: String2(),
  originalTaskId: Optional(String2()),
  taskKey: String2(),
  taskScope: Array2(String2())
});
var TRetry17 = Object2({
  id: String2(),
  // state fields
  state: TLiteralUnion(["waiting", "in-progress", "failed", "succeeded"]),
  requestedAt: TDateString32,
  requestedByName: Optional(String2()),
  startedAt: Optional(TDateString32),
  mostRecentlyAttemptedAt: Optional(TDateString32),
  finishedAt: Optional(TDateString32),
  warningMessages: Array2(TUserMessage),
  failureMessages: Array2(TUserMessage),
  eventNumber: Number2(),
  // request data
  target: TLiteralUnion(["run", "group", "executable-task"]),
  targetedTaskId: Optional(String2()),
  kind: TLiteralUnion(["standard", "failures", "clean", "custom"]),
  debug: Union([Literal("end"), Literal("start"), Literal(false)]),
  // must be false unless target == executable-task
  action: Optional(String2())
  // must be undefined when kind != custom, must be defined when kind == custom
});
var TGraphRoots17 = Object2({ resolution: Array2(TGraphNodeId17), runtime: Array2(TGraphNodeId17) });
var TRunGraph17 = Object2({
  roots: TGraphRoots17,
  directDependencies: Object2({
    resolution: Record(TGraphNodeId17, Array2(TGraphNodeId17)),
    runtime: Record(TGraphNodeId17, Array2(TGraphNodeId17))
  }),
  directDependents: Object2({
    resolution: Record(TGraphNodeId17, Array2(TGraphNodeId17)),
    runtime: Record(TGraphNodeId17, Array2(TGraphNodeId17))
  }),
  subgraphs: Record(TGraphNodeId17, Object2({ roots: TGraphRoots17 })),
  parents: Record(TGraphNodeId17, TGraphNodeId17),
  definitionOrders: Record(TGraphNodeId17, Number2())
});
var TActor17 = Object2({ name: String2(), id: Optional(String2()) });
var TConcurrencyPoolState17 = Object2({
  concurrencyPoolId: String2(),
  leaseId: Optional(String2()),
  leaseState: Enum(LeaseState17)
});
var ApprovalRequestState14 = /* @__PURE__ */ ((ApprovalRequestState15) => {
  ApprovalRequestState15["Pending"] = "pending";
  ApprovalRequestState15["Rescinded"] = "rescinded";
  ApprovalRequestState15["Approved"] = "approved";
  ApprovalRequestState15["Denied"] = "denied";
  return ApprovalRequestState15;
})(ApprovalRequestState14 || {});
var TApprovalRequest14 = Object2({
  id: String2(),
  vaultId: String2(),
  state: Enum(ApprovalRequestState14)
});
var TRun17 = Object2({
  schemaVersion: Literal(ThisSchemaVersion17),
  persistenceExpiresAtSeconds: TEpochSeconds17,
  runId: String2(),
  createdAt: TDateString32,
  useCache: Boolean2(),
  initializationParameters: Record(String2(), String2()),
  actor: Optional(TActor17),
  mintDirectoryArtifact: Optional(TArtifact32),
  accessedVaultIds: Optional(Array2(String2())),
  gitRef: Optional(String2()),
  gitSha: Optional(String2()),
  gitBranch: Optional(String2()),
  gitTag: Optional(String2()),
  gitCommitMessage: Optional(String2()),
  gitCommitAuthorName: Optional(String2()),
  githubActor: Optional(String2()),
  githubActorId: Optional(String2()),
  githubRunAttempt: Optional(Number2()),
  githubRepositoryHtmlUrl: Optional(String2()),
  githubRepositoryOwner: Optional(String2()),
  githubRepositoryName: Optional(String2()),
  githubRepositorySlug: Optional(String2()),
  githubPullRequestUrl: Optional(String2()),
  githubPullRequestNumber: Optional(Number2()),
  githubPullRequestTitle: Optional(String2()),
  githubStatusChecks: Array2(TGithubStatusCheck4),
  gitlabActor: Optional(String2()),
  gitlabActorId: Optional(Number2()),
  gitlabProjectWebUrl: Optional(String2()),
  gitlabProjectPath: Optional(String2()),
  gitlabProjectPathWithNamespace: Optional(String2()),
  gitlabMergeRequestUrl: Optional(String2()),
  gitlabMergeRequestNumber: Optional(Number2()),
  gitlabMergeRequestTitle: Optional(String2()),
  trigger: String2(),
  workspace: String2(),
  concurrencyPool: Optional(TConcurrencyPool17),
  definitionPath: String2(),
  targetedTaskKeys: Optional(Array2(String2())),
  title: Optional(String2()),
  toolCacheConfiguration: Optional(TRunToolCacheConfiguration17),
  eventNumber: Number2(),
  retries: Array2(TRetry17),
  approvalRequests: Array2(TApprovalRequest14),
  sensitiveValues: Array2(String2()),
  graph: TRunGraph17,
  taskIds: Array2(String2()),
  retryManifest: Optional(Array2(TRetryManifestEntry17)),
  concurrencyPoolStateByScope: Record(TScopedTaskKey17, TConcurrencyPoolState17),
  baseLayer: TBaseLayerDescriptor11,
  crossRunSource: TCrossRunSource7,
  triggerContextId: String2(),
  executionStatus: Enum(RunExecutionStatus17),
  executionWaitingSubStatus: Enum(RunExecutionWaitingSubStatus17),
  executionAbortedSubStatus: Enum(RunExecutionAbortedSubStatus17),
  executionFinishedSubStatus: Enum(RunExecutionFinishedSubStatus17),
  resultStatus: Enum(RunResultStatus17),
  waitingForLeaseAt: Optional(TDateString32),
  startedAt: Optional(TDateString32),
  cancellationRequestedAt: Optional(TDateString32),
  cancellationReasonMessages: Optional(Array2(TUserMessage)),
  completedAt: Optional(TDateString32),
  warningMessages: Array2(TUserMessage)
});

// ../packages/containers/base-layer/index.ts
var import_node_assert = __toESM(require("node:assert"), 1);

// ../packages/containers/base-layer/data.json
var data_default = [
  {
    os: "ubuntu 24.04",
    tag: "1.1",
    user: {
      name: "ubuntu",
      uid: 1e3,
      gid: 1e3
    },
    group: {
      name: "hostgroup",
      gid: 950
    },
    arch: "x86_64",
    layerId: "558dd0267c1281b9df666ee7a6e0d5e15a042d90f7bf667fe3069d1feccf6783",
    layerFile: "558dd0267c1281b9df666ee7a6e0d5e15a042d90f7bf667fe3069d1feccf6783.tar",
    layerSizeBytes: 997495808,
    mintRunId: "4ca7dce46e954afc835efb5d65574a15",
    mintGitCommitSha: "070d1ea6d3a85fcfaff3123b3da7a4de5a73745a"
  },
  {
    os: "ubuntu 24.04",
    tag: "1.0",
    user: {
      name: "ubuntu",
      uid: 1e3,
      gid: 1e3
    },
    group: {
      name: "hostgroup",
      gid: 950
    },
    arch: "x86_64",
    layerId: "3736a44d7912a995a2c57758e3b1e43b2b8bc0350805535fcd9b8b90a0efe608",
    layerFile: "3736a44d7912a995a2c57758e3b1e43b2b8bc0350805535fcd9b8b90a0efe608.tar",
    layerSizeBytes: 997433856,
    mintRunId: "0c6d49a3d1654e08bbc3799e61ecdac4",
    mintGitCommitSha: "16e756a470e8ca77c5830289a77a89693c56fbab"
  },
  {
    os: "ubuntu 22.04",
    tag: "1.0",
    arch: "x86_64",
    layerId: "ee9b1c14b0f12fb29997cee03cd70544678097b6389d3182e8243688ca7fa315",
    layerFile: "ee9b1c14b0f12fb29997cee03cd70544678097b6389d3182e8243688ca7fa315.tar",
    layerSizeBytes: 921597952,
    user: {
      name: "ubuntu",
      uid: 999,
      gid: 998
    },
    group: {
      name: "hostgroup",
      gid: 950
    },
    mintRunId: "",
    mintGitCommitSha: ""
  }
];

// ../packages/utils/singleton.ts
var Singleton = class {
  constructor(instanceName, initially = void 0) {
    this.instanceName = instanceName;
    this.#instance = initially;
  }
  #instance = void 0;
  set(instance) {
    this.#instance = instance;
  }
  get() {
    if (!this.#instance)
      throw new Error(`${this.instanceName} is not set.`);
    return this.#instance;
  }
  reset() {
    this.#instance = void 0;
  }
};

// ../packages/containers/base-layer/index.ts
var architectures = ["x86_64"];
var defaultArchitecture = "x86_64";
var BaseLayers = new Singleton(
  "BaseLayers",
  data_default.map((base) => {
    (0, import_node_assert.default)(architectures.includes(base.arch), `Invalid architecture: ${base.arch}`);
    const { mintRunId: _mintRunId, mintGitCommitSha: _mintGitCommitSha, ...rest } = base;
    return {
      ...rest,
      arch: base.arch
    };
  })
);
var BaseLayerSpecifications = new Singleton(
  "BaseLayerSpecifications",
  BaseLayers.get().map(({ os, tag, arch }) => ({ os, tag, arch }))
);
function findBaseLayer(spec) {
  if ("layerId" in spec) {
    return BaseLayers.get().find((base) => base.layerId === spec.layerId) ?? null;
  } else if ("os" in spec && "tag" in spec) {
    const specWithArch = { ...spec, arch: spec.arch ?? defaultArchitecture };
    return BaseLayers.get().find((base) => base.os === specWithArch.os && base.tag === specWithArch.tag && base.arch === specWithArch.arch) ?? null;
  } else {
    return findBaseLayerForArch(spec.arch) ?? null;
  }
}
function mustFindBaseLayer(spec) {
  const baseLayer = findBaseLayer(spec);
  if (!baseLayer)
    throw new Error(`Base layer for '${JSON.stringify(spec)}' not found`);
  return baseLayer;
}
function findBaseLayerForArch(arch) {
  switch (arch) {
    case "x86_64":
      return findBaseLayer({ os: "ubuntu 22.04", tag: "1.0", arch: "x86_64" });
    default:
      assertExhaustive(arch);
  }
}
var defaultBaseLayerSpecification = { os: "ubuntu 22.04", tag: "1.0", arch: defaultArchitecture };
var defaultBaseLayer = (() => mustFindBaseLayer(defaultBaseLayerSpecification))();

// ../packages/schema/persisted/index.ts
var TVersionedRun = Type.Union([
  TRun,
  TRun17,
  TRun16,
  TRun15,
  TRun14,
  TRun13,
  TRun12,
  TRun11,
  TRun10,
  TRun9,
  TRun8,
  TRun7,
  TRun6,
  TRun5,
  TRun4,
  TRun3,
  TRun2
]);
var TVersionedRunChecker = TypeCompiler.Compile(TVersionedRun);
var TVersionedTask = Type.Union([
  TTask,
  TTask17,
  TTask16,
  TTask15,
  TTask14,
  TTask13,
  TTask12,
  TTask11,
  TTask10,
  TTask9,
  TTask8,
  TTask7,
  TTask6,
  TTask5,
  TTask4,
  TTask3,
  TTask2
]);
var TVersionedTaskChecker = TypeCompiler.Compile(TVersionedTask);

// ../packages/schema/task-definition/task.ts
var TSource18 = Type.Object({
  definition: Type.String(),
  start: Type.Number(),
  end: Type.Number()
});
var TStandardDependencies = Type.Object({ type: Type.Literal("standard" /* Standard */), keys: Type.Array(Type.String()) });
var TDependencies = Type.Union([TStandardDependencies]);
var TEnvJoinMergeStrategy = Type.Object({
  strategy: Type.Literal("join"),
  by: Type.String()
});
var TEnvOverrideMergeStrategy = Type.Object({
  strategy: Type.Literal("override")
});
var TEnvMergeStrategy18 = Type.Union([TEnvJoinMergeStrategy, TEnvOverrideMergeStrategy]);
var TEnvInherit = Type.Union([Type.Literal("all-used-tasks"), Type.Array(Type.String())]);
var TEnvDescriptor = Type.Object({
  value: Type.Optional(TTemplateString),
  cacheKey: Type.Enum(EnvironmentVariableCacheKey14)
});
var TTaskDefinitionEnv = Type.Object({
  inherit: Type.Optional(TEnvInherit),
  envVars: Type.Optional(Type.Record(Type.String(), TEnvDescriptor)),
  merge: Type.Optional(Type.Record(Type.String(), TEnvMergeStrategy18))
});
var TParallelismValue18 = Type.Record(Type.String(), Type.Union([Type.String(), Type.Number(), Type.Boolean()]));
var TAfterTask = Type.Object({ type: Type.Literal(0 /* Task */), task: Type.String() });
var TAfterTaskList = Type.Object({ type: Type.Literal(1 /* TaskList */), tasks: Type.Array(Type.String()) });
var TAfterTemplate = Type.Object({ type: Type.Literal(2 /* Template */), template: TTemplateString });
var TAfter = Type.Union([TAfterTask, TAfterTaskList, TAfterTemplate]);
var TCacheConfiguration11 = Type.Object({
  enabled: Type.Union([Type.Boolean(), TTemplateString]),
  ttl: Type.Optional(TTemplateString)
});
var TSharedTaskDefinition = Type.Object({
  key: Type.String(),
  filter: Type.Optional(TInputFilesystemFilter),
  dependencies: TDependencies,
  after: Type.Optional(TAfter),
  if: Type.Optional(TTemplateString),
  rawSource: Type.Optional(TSource18),
  cacheConfiguration: Type.Optional(TCacheConfiguration11),
  warningMessages: Type.Array(TUserMessage)
});
var MAXIMUM_PARALLEL_TASKS_LIMIT = 256;
var TTotalParallelism = Type.Object({ type: Type.Literal("total" /* Total */), total: TTemplateString });
var TMatrixParallelism = Type.Object({
  type: Type.Literal("matrix" /* Matrix */),
  matrix: Type.Record(Type.String(), Type.Union([Type.Array(TTemplateString), TTemplateString]))
});
var TValuesParallelism = Type.Object({
  type: Type.Literal("values" /* Values */),
  values: Type.Union([TTemplateString, Type.Array(Type.Record(Type.String(), TTemplateString))])
});
var TParallelism = Type.Union([TTotalParallelism, TMatrixParallelism, TValuesParallelism]);
var TPartialParallelConfiguration = Type.Object({
  key: Type.Union([TTemplateString, Type.Null()]),
  tasksLimit: Type.Optional(Type.Union([Type.Number(), Type.Null()])),
  parallelism: TParallelism
});
var TBackgroundProcessReadyCheck = Type.Object({ run: TTemplateString, timeoutSeconds: Type.Optional(Type.Number()) });
var TBackgroundProcess18 = Type.Object({
  key: Type.String(),
  run: TTemplateString,
  readyCheck: Type.Optional(TBackgroundProcessReadyCheck),
  terminateGracePeriodSeconds: Type.Optional(Type.Number()),
  after: Type.Optional(Type.Array(Type.String()))
});
var TToolCacheNameTaskKey = Type.Object({ type: Type.Literal("task-key" /* TaskKey */) });
var TToolCacheNameLiteralString = Type.Object({ type: Type.Literal("literal-string" /* LiteralString */), value: Type.String() });
var TToolCacheName = Type.Union([TToolCacheNameTaskKey, TToolCacheNameLiteralString]);
var TAgentSpecification18 = Type.Object({
  memory: Type.Optional(TTemplateString),
  cpus: Type.Optional(TTemplateString),
  disk: Type.Object({
    size: Type.Optional(TTemplateString)
  }),
  staticIps: Type.Optional(TTemplateString),
  tmpfs: Type.Optional(Type.Boolean())
});
var TCommandTaskDefinition = Type.Intersect([
  TSharedTaskDefinition,
  Type.Object({
    agent: TAgentSpecification18,
    type: Type.Literal("command" /* Command */),
    command: TTemplateString,
    backgroundProcesses: Type.Array(TBackgroundProcess18),
    successExitCodes: Type.Array(Type.Number()),
    testResultsPaths: Type.Array(TTestResultsPath),
    artifactPaths: Type.Array(TArtifactPath),
    problemMatchers: Type.Array(TProblemMatcher),
    problemPaths: Type.Array(TProblemPath),
    env: Type.Optional(TTaskDefinitionEnv),
    timeoutMinutes: Type.Optional(Type.Number()),
    terminateGracePeriodSeconds: Type.Optional(Type.Number()),
    toolCache: Type.Optional(TToolCacheName),
    parallel: Type.Optional(TPartialParallelConfiguration),
    docker: Type.Optional(Type.Union([Type.Boolean(), Type.Literal("preserve-data"), TTemplateString])),
    outputFilesystemFilter: TOutputFilesystemFilter
  })
]);
var TLeafName = Type.Object({
  type: Type.Literal("name-version" /* NameVersion */),
  name: Type.String(),
  version: Type.String()
});
var TLeafDigest = Type.Object({
  type: Type.Literal("digest" /* Digest */),
  digest: Type.String()
});
var TLeafIdentifier = Type.Union([TLeafName, TLeafDigest]);
var TLeafTaskDefinition = Type.Intersect([
  TSharedTaskDefinition,
  Type.Object({
    type: Type.Literal("leaf" /* Leaf */),
    leaf: TLeafIdentifier,
    parameters: Type.Optional(Type.Record(Type.String(), TTemplateString)),
    env: Type.Optional(TTaskDefinitionEnv),
    parallel: Type.Optional(TPartialParallelConfiguration)
  })
]);
var TInMemoryMintDirEmbeddedRunDefinitionSource = Type.Object({
  type: Type.Literal("in-memory-mint-dir" /* InMemoryMintDir */),
  runDefinitionPath: Type.String()
});
var TTaskArtifactEmbeddedRunDefinitionSource = Type.Object({
  type: Type.Literal("task-artifact" /* TaskArtifact */),
  expression: TTemplateString
});
var TEmbeddedRunDefinitionSource = Type.Union([TInMemoryMintDirEmbeddedRunDefinitionSource, TTaskArtifactEmbeddedRunDefinitionSource]);
var TEmbeddedRunTaskDefinition = Type.Intersect([
  Type.Omit(TSharedTaskDefinition, ["dependencies", "filter"]),
  Type.Object({
    type: Type.Literal("embedded-run" /* EmbeddedRun */),
    runDefinitionSource: TEmbeddedRunDefinitionSource,
    parameters: Type.Optional(Type.Record(Type.String(), TTemplateString)),
    parallel: Type.Optional(TPartialParallelConfiguration),
    targets: Type.Optional(Type.Array(Type.String(), { minItems: 1 }))
  })
]);
var TPartialTaskDefinition = Type.Union([TCommandTaskDefinition, TLeafTaskDefinition, TEmbeddedRunTaskDefinition]);
var TBaseTrigger = Type.Object({
  init: Type.Record(Type.String(), Type.String()),
  if: Type.Optional(Type.String()),
  target: Type.Optional(Type.Union([Type.String(), Type.Array(Type.String(), { minItems: 1 })])),
  title: Type.Optional(Type.String())
});
var TGithubPushTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    statusChecks: Type.Array(TGithubStatusCheck)
  })
]);
var TGitHubPullRequestTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    actions: Type.Optional(Type.Array(Type.String())),
    statusChecks: Type.Array(TGithubStatusCheck)
  })
]);
var TGitHubMergeGroupTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    actions: Type.Optional(Type.Array(Type.String())),
    statusChecks: Type.Array(TGithubStatusCheck)
  })
]);
var TGitHubTriggers = Type.Object({
  push: Type.Array(TGithubPushTrigger),
  pullRequest: Type.Array(TGitHubPullRequestTrigger),
  mergeGroup: Type.Array(TGitHubMergeGroupTrigger)
});
var TGitlabMergeRequestTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    actions: Type.Optional(Type.Array(Type.String()))
  })
]);
var TGitlabTriggers = Type.Object({
  push: Type.Array(TBaseTrigger),
  tagPush: Type.Array(TBaseTrigger),
  mergeRequest: Type.Array(TGitlabMergeRequestTrigger)
});
var TCronTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    key: Type.String(),
    schedule: Type.String(),
    branch: Type.Optional(Type.String()),
    resetToolCache: Type.Optional(Type.Boolean())
  })
]);
var TCliTrigger = Type.Omit(TBaseTrigger, ["if", "target"]);
var TDispatchParam = Type.Object({
  key: Type.String(),
  name: Type.Optional(Type.String()),
  description: Type.Optional(Type.String()),
  default: Type.Optional(Type.String()),
  required: Type.Boolean()
});
var TDispatchTrigger = Type.Intersect([
  TBaseTrigger,
  Type.Object({
    key: Type.String(),
    params: Type.Array(TDispatchParam)
  })
]);
var TTriggers = Type.Object({
  github: TGitHubTriggers,
  gitlab: TGitlabTriggers,
  cron: Type.Array(TCronTrigger),
  cli: TCliTrigger,
  dispatch: Type.Array(TDispatchTrigger)
});
var TPartialConcurrencyPool = Type.Object({
  id: TTemplateString,
  if: Type.Optional(TTemplateString),
  capacity: Type.Number({ minimum: 1 }),
  onOverflow: Type.Enum(OnOverflow)
});
var TPartialRunToolCache = Type.Object({
  vault: Type.String()
});
var TPartialBaseLayer = Type.Object({
  os: TTemplateString,
  tag: TTemplateString,
  arch: Type.Optional(TTemplateString)
});
var _TPartialRunDefinition = Type.Object({
  concurrencyPools: Type.Optional(Type.Array(TPartialConcurrencyPool)),
  triggers: Type.Optional(TTriggers),
  toolCache: Type.Optional(TPartialRunToolCache),
  tasks: Type.Array(TPartialTaskDefinition),
  baseLayer: Type.Optional(TPartialBaseLayer),
  warningMessages: Type.Array(TUserMessage)
});
var KEY_CHARSET = "[A-Za-z0-9_-]";
var KEY_INVALID_CHARSET = `[^A-Za-z0-9_-]`;
var KEY_PATTERN = `^${KEY_CHARSET}+$`;
var KEY_REGEXP = new RegExp(KEY_PATTERN);
var KEY_INVALID_CHARSET_REGEXP = new RegExp(KEY_INVALID_CHARSET);
var SAFE_TASK_KEY_DELIMITER = ".";
var RUN_SCOPE = getScopedKey({ scope: [], key: "" });
function getScopedKey({ key, scope }) {
  return scope.length > 0 ? `${scope.join(SAFE_TASK_KEY_DELIMITER)}${SAFE_TASK_KEY_DELIMITER}${key}` : key;
}

// ../packages/task-parser/yaml-dsl/parser2.ts
var YAML = __toESM(require_dist(), 1);

// ../packages/schema/non-empty-array.ts
var TNonEmptyArray = (schema) => Type.Array(schema, { minItems: 1 });
{
  const _BooleanArray = TNonEmptyArray(Type.Boolean());
  assertType(true);
}
function isNonEmptyArray(arr) {
  return arr.length > 0;
}

// ../packages/utils/set.ts
function setEqual(lhs, rhs) {
  if (lhs.size !== rhs.size) {
    return false;
  }
  for (const elem of lhs) {
    if (!rhs.has(elem)) {
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/lines-and-columns@2.0.4/node_modules/lines-and-columns/build/index.mjs
var LF = "\n";
var CR = "\r";
var LinesAndColumns = (
  /** @class */
  function() {
    function LinesAndColumns2(string) {
      this.length = string.length;
      var offsets = [0];
      for (var offset = 0; offset < string.length; ) {
        switch (string[offset]) {
          case LF:
            offset += LF.length;
            offsets.push(offset);
            break;
          case CR:
            offset += CR.length;
            if (string[offset] === LF) {
              offset += LF.length;
            }
            offsets.push(offset);
            break;
          default:
            offset++;
            break;
        }
      }
      this.offsets = offsets;
    }
    LinesAndColumns2.prototype.locationForIndex = function(index) {
      if (index < 0 || index > this.length) {
        return null;
      }
      var line = 0;
      var offsets = this.offsets;
      while (offsets[line + 1] <= index) {
        line++;
      }
      var column = index - offsets[line];
      return { line, column };
    };
    LinesAndColumns2.prototype.indexForLocation = function(location) {
      var line = location.line, column = location.column;
      if (line < 0 || line >= this.offsets.length) {
        return null;
      }
      if (column < 0 || column > this.lengthOfLine(line)) {
        return null;
      }
      return this.offsets[line] + column;
    };
    LinesAndColumns2.prototype.lengthOfLine = function(line) {
      var offset = this.offsets[line];
      var nextOffset = line === this.offsets.length - 1 ? this.length : this.offsets[line + 1];
      return nextOffset - offset;
    };
    return LinesAndColumns2;
  }()
);

// ../packages/task-parser/matchers/schema.ts
var TNonValidatedMatcherPattern = Type.Object({
  /** the regex pattern that provides the groups to match against */
  regexp: Type.String(),
  /** a group number containing the file name */
  file: Type.Optional(Type.Integer()),
  /** a group number containing a filepath used to root the file (e.g. a project file) */
  fromPath: Type.Optional(Type.Integer()),
  /** a group number containing the line number */
  line: Type.Optional(Type.Integer()),
  /** a group number containing the column information */
  column: Type.Optional(Type.Integer()),
  /** a group number containing either the severity, case-insensitive. Defaults to `error` */
  severity: Type.Optional(Type.Integer()),
  /** a group number containing the error code */
  code: Type.Optional(Type.Integer()),
  /** a group number containing the error message. **required** at least one pattern must set the message */
  message: Type.Optional(Type.Integer()),
  /** whether to loop until a match is not found, only valid on the last pattern of a multipattern matcher */
  loop: Type.Optional(Type.Boolean())
});
var TNonValidatedProblemMatcher = Type.Object({
  owner: Type.String(),
  severity: Type.Optional(Type.String()),
  pattern: Type.Array(TNonValidatedMatcherPattern)
});
var TNonValidatedMatcherConfig = Type.Object({
  problemMatcher: Type.Array(TNonValidatedProblemMatcher)
});

// ../packages/schema/run-results.ts
assertType(false);

// ../packages/task-parser/matchers/validate.ts
var import_node_assert2 = __toESM(require("node:assert"), 1);
function invalid(errors) {
  return {
    valid: false,
    errors
  };
}
function valid(value) {
  return {
    valid: true,
    value
  };
}
function validateMatcherConfig(matcherConfig) {
  const { problemMatcher } = matcherConfig;
  const validatedMatchers = [];
  const errors = [];
  const distinctOwners = /* @__PURE__ */ new Set();
  if (problemMatcher.length > 0) {
    for (const matcher of problemMatcher) {
      const validated = validateProblemMatcher(matcher);
      if (validated.valid) {
        validatedMatchers.push(validated.value);
      } else {
        errors.push(...validated.errors);
      }
      const { owner } = matcher;
      if (distinctOwners.has(owner)) {
        errors.push(
          buildMessage({
            type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
            message: [`Found a duplicate problem matcher owner name ${owner}`],
            docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
          })
        );
      }
      distinctOwners.add(owner);
    }
  }
  if (errors.length) {
    return invalid(errors);
  }
  return valid({
    problemMatcher: validatedMatchers
  });
}
function validateProblemMatcher(matcher) {
  const { owner, pattern: patterns, severity } = matcher;
  const errors = [];
  if (!owner) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`Found a problem matcher without an owner`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  let validatedSeverity;
  switch (severity?.toLowerCase()) {
    case void 0:
      break;
    case "error":
      validatedSeverity = "error" /* Error */;
      break;
    case "warning":
      validatedSeverity = "warning" /* Warning */;
      break;
    case "info":
      validatedSeverity = "info" /* Info */;
      break;
    default: {
      errors.push(
        buildMessage({
          type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
          message: [`The problem matcher "${owner}" contains unexpected default severity "${severity}"`],
          docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
        })
      );
      break;
    }
  }
  if (patterns.length === 0) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher "${owner}" does not contain any patterns`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  const validatedPatterns = [];
  const crossPatternsRegexpFields = {
    file: null,
    line: null,
    column: null,
    severity: null,
    code: null,
    message: null,
    fromPath: null
  };
  for (let i = 0; i < patterns.length; ++i) {
    const isFirst = i === 0;
    const isLast = i === patterns.length - 1;
    const pattern = verifyExists(patterns[i]);
    const validated = validateMatcherPattern(pattern, isFirst, isLast, crossPatternsRegexpFields);
    if (validated.valid) {
      validatedPatterns.push(validated.value);
    } else {
      errors.push(...validated.errors);
    }
  }
  if (crossPatternsRegexpFields.message === null) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher "${owner}" does not contain a pattern that sets a message`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (errors.length) {
    return invalid(errors);
  }
  (0, import_node_assert2.default)(isNonEmptyArray(validatedPatterns));
  return valid({
    owner,
    pattern: validatedPatterns,
    severity: validatedSeverity
  });
}
var RE_CAPTURING_GROUPS = /\((?!\?)/g;
function validateMatcherPattern(pattern, isFirst, isLast, crossPatternsRegexpFields) {
  const errors = [];
  if (pattern.loop && (isFirst || !isLast)) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets 'loop' but is not the last pattern.`],
        advice: [`Only the last pattern in a multiline matcher may set 'loop'.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (pattern.loop && pattern.message === void 0) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets 'loop' but does not set 'message'.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  let regex;
  try {
    regex = new RegExp(pattern.regexp);
  } catch (e) {
    if (e instanceof SyntaxError) {
      errors.push(
        buildMessage({
          type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
          message: [`The problem matcher pattern '${pattern.regexp}' is not a valid regular expression.`],
          docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
        })
      );
      return invalid(errors);
    }
    throw e;
  }
  const groupCount = regex.source.match(RE_CAPTURING_GROUPS)?.length ?? 0;
  for (const key of Object.keys(crossPatternsRegexpFields)) {
    validateCrossPatternField(
      //
      crossPatternsRegexpFields,
      groupCount,
      pattern,
      key,
      errors
    );
  }
  if (errors.length) {
    return invalid(errors);
  }
  return valid(pattern);
}
function validateCrossPatternField(crossPatternsRegexpFields, groupCount, pattern, field, errors) {
  const newValue = pattern[field];
  if (newValue === void 0) {
    return;
  }
  if (crossPatternsRegexpFields[field] !== null) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [`The problem matcher pattern '${pattern.regexp}' sets '${field}', but it is already set in another pattern.`],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  if (newValue < 0 || newValue > groupCount) {
    errors.push(
      buildMessage({
        type: "invalid-problem-matcher" /* InvalidProblemMatcher */,
        message: [
          `The problem matcher pattern '${pattern.regexp}' sets '${field}' to ${newValue}, but the pattern only has ${groupCount} capturing groups.`
        ],
        docs: `See ${"https://www.rwx.com/docs/mint/problems" /* ProblemMatchers */} to learn about problem matchers.`
      })
    );
  }
  crossPatternsRegexpFields[field] = newValue;
}

// ../packages/task-parser/yaml-dsl/built-in-problem-matchers.ts
var BUILT_IN_PROBLEM_MATCHERS = {
  rubocop: {
    problemMatcher: [
      {
        owner: "rubocop-error",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): C: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      },
      {
        owner: "rubocop-warning",
        severity: "warning",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): W: ((.+): .+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4,
            code: 5
          }
        ]
      }
    ]
  },
  eslint: {
    problemMatcher: [
      {
        owner: "eslint",
        pattern: [
          {
            regexp: "^([^\\s].*)$",
            file: 1
          },
          {
            regexp: "^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.*)\\s\\s+(.*)$",
            line: 1,
            column: 2,
            severity: 3,
            message: 4,
            code: 5,
            loop: true
          }
        ]
      }
    ]
  },
  tsc: {
    problemMatcher: [
      {
        owner: "tsc",
        pattern: [
          {
            regexp: "^([^\\s].*)[\\(:](\\d+)[,:](\\d+)(?:\\):\\s+|\\s+-\\s+)(error|warning|info)\\s+TS(\\d+)\\s*:\\s*(.*)$",
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            code: 5,
            message: 6
          }
        ]
      }
    ]
  },
  "erb-lint": {
    problemMatcher: [
      {
        owner: "erb-lint",
        severity: "error",
        pattern: [
          {
            regexp: "^(.+):(\\d+):(\\d+): (.+)$",
            file: 1,
            line: 2,
            column: 3,
            message: 4
          }
        ]
      }
    ]
  },
  shellcheck: {
    problemMatcher: [
      {
        owner: "shellcheck-tty",
        pattern: [
          {
            regexp: "^In\\s(.+)\\sline\\s(\\d+):$",
            file: 1,
            line: 2
          },
          {
            regexp: ".*"
          },
          {
            regexp: "SC(\\d+)(\\s\\((info|warning|error)\\))?:\\s(.+)$",
            code: 1,
            severity: 3,
            message: 4,
            loop: true
          }
        ]
      }
    ]
  }
};
function isBuiltinProblemMatcher(key) {
  return key in BUILT_IN_PROBLEM_MATCHERS;
}

// ../packages/utils/debug-assert.ts
var import_node_assert3 = __toESM(require("node:assert"), 1);
function debugAssert(value, message) {
  if (process.env.NODE_ENV === "production") {
    return;
  }
  (0, import_node_assert3.default)(value(), message);
}

// ../node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib_esm/api_esm.mjs
var import_api = __toESM(require_api4(), 1);
var Alternation = import_api.default.Alternation;
var Alternative = import_api.default.Alternative;
var CstParser = import_api.default.CstParser;
var EMPTY_ALT = import_api.default.EMPTY_ALT;
var EOF = import_api.default.EOF;
var EarlyExitException = import_api.default.EarlyExitException;
var EmbeddedActionsParser = import_api.default.EmbeddedActionsParser;
var GAstVisitor = import_api.default.GAstVisitor;
var LLkLookaheadStrategy = import_api.default.LLkLookaheadStrategy;
var Lexer = import_api.default.Lexer;
var LexerDefinitionErrorType = import_api.default.LexerDefinitionErrorType;
var MismatchedTokenException = import_api.default.MismatchedTokenException;
var NoViableAltException = import_api.default.NoViableAltException;
var NonTerminal = import_api.default.NonTerminal;
var NotAllInputParsedException = import_api.default.NotAllInputParsedException;
var Option = import_api.default.Option;
var Parser = import_api.default.Parser;
var ParserDefinitionErrorType = import_api.default.ParserDefinitionErrorType;
var Repetition = import_api.default.Repetition;
var RepetitionMandatory = import_api.default.RepetitionMandatory;
var RepetitionMandatoryWithSeparator = import_api.default.RepetitionMandatoryWithSeparator;
var RepetitionWithSeparator = import_api.default.RepetitionWithSeparator;
var Rule = import_api.default.Rule;
var Terminal = import_api.default.Terminal;
var VERSION = import_api.default.VERSION;
var clearCache = import_api.default.clearCache;
var createSyntaxDiagramsCode = import_api.default.createSyntaxDiagramsCode;
var createToken = import_api.default.createToken;
var createTokenInstance = import_api.default.createTokenInstance;
var defaultLexerErrorProvider = import_api.default.defaultLexerErrorProvider;
var defaultParserErrorProvider = import_api.default.defaultParserErrorProvider;
var generateCstDts = import_api.default.generateCstDts;
var getLookaheadPaths = import_api.default.getLookaheadPaths;
var isRecognitionException = import_api.default.isRecognitionException;
var serializeGrammar = import_api.default.serializeGrammar;
var serializeProduction = import_api.default.serializeProduction;
var tokenLabel = import_api.default.tokenLabel;
var tokenMatcher = import_api.default.tokenMatcher;
var tokenName = import_api.default.tokenName;

// ../packages/task-parser/tokens.ts
var EXPR_START = "${{";
var EXPR_START_RE = /(\\{2})*\${{/;
var EXPR_END = "}}";
var EXPR_END_RE = /}}/;

// ../packages/task-parser/template-parser.ts
var AnyBeforeExpr = createToken({
  name: "AnyBeforeExpr",
  pattern: /(.|\n|\r)+?(?=\\*\${{)/
});
var AnyBeforeExprEnd = createToken({
  name: "AnyBeforeExprEnd",
  pattern: /(.|\n|\r)+?(?=}})/
});
var Any2 = createToken({
  name: "Any",
  pattern: /(.|\n|\r)+/
});
var WhiteSpace = createToken({
  name: "WhiteSpace",
  pattern: /\s+/,
  group: Lexer.SKIPPED
});
var EscapedExprStart = createToken({
  name: "EscapedExprStart",
  pattern: /(\\{2})*\\\${{/,
  label: `'\\+\${{'`,
  push_mode: "escapedExpression"
});
var ExprStart = createToken({
  name: "ExprStart",
  pattern: EXPR_START_RE,
  label: `'${EXPR_START}'`,
  push_mode: "expression"
});
var ExprEnd = createToken({
  name: "ExprEnd",
  pattern: EXPR_END_RE,
  label: `'${EXPR_END}'`,
  pop_mode: true
});
var IdentRegex = /[a-zA-Z_-][\w-]*/;
var Ident = createToken({
  name: "Ident",
  pattern: IdentRegex,
  label: `Identifier matching pattern '${IdentRegex.source}'`
});
var Dot = createToken({
  name: "Dot",
  pattern: /\./,
  label: `'.'`
});
var Comma = createToken({
  name: "Comma",
  pattern: /,/,
  label: `','`
});
var OpOr = createToken({
  name: "OrOp",
  pattern: /\|\|/,
  label: "||"
});
var OpAnd = createToken({
  name: "AndOp",
  pattern: /&&/,
  label: "&&"
});
var OpEq = createToken({
  name: "EqOp",
  pattern: /==/,
  label: "=="
});
var OpNotEq = createToken({
  name: "NotEqOp",
  pattern: /!=/,
  label: "!="
});
var OpMatch = createToken({
  name: "MatchOp",
  pattern: /=~/,
  label: "=~"
});
var OpNotMatch = createToken({
  name: "NotMatchOp",
  pattern: /!~/,
  label: "!~"
});
var RE_SINGLE_QUOTE_STRING_LITERAL = /'[^']*'/y;
var RE_DOUBLE_QUOTE_STRING_LITERAL = /"[^"]*"/y;
var matchStringLiteralRe = (re) => (text, startOffset) => {
  re.lastIndex = startOffset;
  const execResult = re.exec(text);
  if (execResult !== null) {
    const fullMatch = execResult[0];
    const matchWithOutQuotes = fullMatch.substr(1, fullMatch.length - 2);
    execResult.payload = matchWithOutQuotes;
  }
  return execResult;
};
var SingleQuoteStringLiteral = createToken({
  name: "SingleQuoteStringLiteral",
  pattern: matchStringLiteralRe(RE_SINGLE_QUOTE_STRING_LITERAL),
  line_breaks: false,
  label: "single-quote string literal"
});
var DoubleQuoteStringLiteral = createToken({
  name: "DoubleQuoteStringLiteral",
  pattern: matchStringLiteralRe(RE_DOUBLE_QUOTE_STRING_LITERAL),
  line_breaks: false,
  label: "double-quote string literal"
});
var BooleanLiteral = createToken({
  name: "BooleanLiteral",
  pattern: /true|false/,
  label: `Boolean 'true' or 'false'`
});
var LParen = createToken({ name: "LParen", pattern: /\(/, label: "(" });
var RParen = createToken({ name: "RParen", pattern: /\)/, label: ")" });
var LBracket = createToken({ name: "LBracket", pattern: /\[/, label: "[" });
var RBracket = createToken({ name: "RBracket", pattern: /\]/, label: "]" });
var modes = {
  templateString: [
    // The ordering here is important since the lexer is backtracking.
    ExprStart,
    EscapedExprStart,
    AnyBeforeExpr,
    Any2
  ],
  expression: [
    WhiteSpace,
    BooleanLiteral,
    Ident,
    Dot,
    Comma,
    ExprEnd,
    OpAnd,
    OpOr,
    OpEq,
    OpNotEq,
    OpMatch,
    OpNotMatch,
    SingleQuoteStringLiteral,
    DoubleQuoteStringLiteral,
    LParen,
    RParen,
    LBracket,
    RBracket
  ],
  escapedExpression: [ExprEnd, AnyBeforeExprEnd]
};
var multiModeLexer = {
  modes,
  defaultMode: "templateString" /* TemplateString */
};
var TemplateLexer = new Lexer(multiModeLexer, { positionTracking: "onlyStart", recoveryEnabled: false });
var TemplateParser = class extends CstParser {
  parse = this.RULE("parse", () => {
    this.MANY(() => {
      this.SUBRULE(this.embeddedExpr);
    });
    this.OPTION(() => {
      this.CONSUME(Any2, { LABEL: "litAfter" });
    });
  });
  embeddedExpr = this.RULE("embeddedExpr", () => {
    this.OPTION(() => {
      this.CONSUME(AnyBeforeExpr, { LABEL: "litBefore" });
    });
    this.OR([
      {
        ALT: () => {
          this.CONSUME(EscapedExprStart, { LABEL: "escapedExprStart" });
          this.CONSUME(AnyBeforeExprEnd, { LABEL: "escapedExpr" });
        }
      },
      {
        ALT: () => {
          this.CONSUME(ExprStart, { LABEL: "exprStart" });
          this.SUBRULE(this.expr);
        }
      }
    ]);
    this.CONSUME(ExprEnd);
  });
  expr = this.RULE("expr", () => {
    this.SUBRULE(this.orExpr);
  });
  /** <expr> (|| <expr>)* */
  orExpr = this.RULE("orExpr", () => {
    this.SUBRULE(this.andExpr);
    this.MANY(() => {
      this.CONSUME(OpOr);
      this.SUBRULE2(this.andExpr);
    });
  });
  /** <expr> (&& <expr>)* */
  andExpr = this.RULE("andExpr", () => {
    this.SUBRULE(this.compareExpr);
    this.MANY(() => {
      this.CONSUME(OpAnd);
      this.SUBRULE2(this.compareExpr);
    });
  });
  /** <expr> ((==|!=|=~|!~) <expr>)? */
  compareExpr = this.RULE("compareExpr", () => {
    this.SUBRULE(this.atomicExpr);
    this.OPTION(() => {
      this.OR([
        { ALT: () => this.CONSUME(OpEq) },
        { ALT: () => this.CONSUME(OpNotEq) },
        { ALT: () => this.CONSUME(OpMatch) },
        { ALT: () => this.CONSUME(OpNotMatch) }
      ]);
      this.SUBRULE2(this.atomicExpr);
    });
  });
  atomicExpr = this.RULE("atomicExpr", () => {
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.paranthesizedExpr, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.stringLiteral, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.booleanLiteral, { LABEL: "expr" }) },
      { ALT: () => this.SUBRULE(this.access, { LABEL: "expr" }) }
    ]);
  });
  paranthesizedExpr = this.RULE("paranthesizedExpr", () => {
    this.CONSUME(LParen);
    this.SUBRULE(this.expr);
    this.CONSUME(RParen);
  });
  stringLiteral = this.RULE("stringLiteral", () => {
    this.OR([
      //
      { ALT: () => this.CONSUME(SingleQuoteStringLiteral, { LABEL: "str" }) },
      { ALT: () => this.CONSUME(DoubleQuoteStringLiteral, { LABEL: "str" }) }
    ]);
  });
  booleanLiteral = this.RULE("booleanLiteral", () => {
    this.CONSUME(BooleanLiteral, { LABEL: "bool" });
  });
  access = this.RULE("access", () => {
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.functionCall, { LABEL: "functionCall" }) },
      { ALT: () => this.CONSUME(Ident, { LABEL: "ident" }) }
    ]);
    this.MANY(() => {
      this.SUBRULE(this.chainedAccess);
    });
  });
  chainedAccess = this.RULE("chainedAccess", () => {
    this.OR([
      //
      { ALT: () => this.SUBRULE(this.dynamicAccess) },
      { ALT: () => this.SUBRULE(this.functionAccess) },
      { ALT: () => this.SUBRULE(this.staticAccess) }
    ]);
  });
  dynamicAccess = this.RULE("dynamicAccess", () => {
    this.CONSUME(LBracket);
    this.SUBRULE(this.expr);
    this.CONSUME(RBracket);
  });
  functionAccess = this.RULE("functionAccess", () => {
    this.CONSUME(Dot);
    this.SUBRULE(this.functionCall);
  });
  staticAccess = this.RULE("staticAccess", () => {
    this.CONSUME(Dot);
    this.OR([
      //
      { ALT: () => this.CONSUME(Ident, { LABEL: "ident" }) },
      { ALT: () => this.CONSUME(BooleanLiteral, { LABEL: "ident" }) }
    ]);
  });
  functionCall = this.RULE("functionCall", () => {
    this.CONSUME(Ident, { LABEL: "functionName" });
    this.CONSUME(LParen);
    this.OPTION(() => {
      this.SUBRULE(this.expr, { LABEL: "firstArg" });
      this.MANY(() => {
        this.SUBRULE(this.commaArg);
      });
    });
    this.CONSUME(RParen);
  });
  commaArg = this.RULE("commaArg", () => {
    this.CONSUME(Comma);
    this.SUBRULE(this.expr, { LABEL: "arg" });
  });
  constructor() {
    super(multiModeLexer, {
      recoveryEnabled: false
    });
    this.performSelfAnalysis();
  }
};
var templateParser = new TemplateParser();
function getTemplateParser(input) {
  templateParser.input = input;
  return templateParser;
}

// ../packages/task-parser/template.ts
var import_node_assert5 = __toESM(require("node:assert"), 1);

// ../packages/task-parser/errors.ts
var import_node_assert4 = __toESM(require("node:assert"), 1);
var ParsingError = class _ParsingError extends UserError {
  messages;
  constructor(messages) {
    (0, import_node_assert4.default)(messages.length);
    const { fileName: _fileName, line: _line, column: _column, stackTrace: _stackTrace, ...rest } = verifyExists(messages[0]);
    const combinedMessage = messages.map((um) => messageWithFileLocation(um)).join("\n\n");
    super({ ...rest, message: combinedMessage });
    this.messages = messages;
    Object.setPrototypeOf(this, _ParsingError.prototype);
  }
  static fromString(message) {
    return new this([{ type: "parse-error" /* ParseError */, message }]);
  }
  asMessages() {
    return this.messages;
  }
};

// ../packages/task-parser/template.ts
function parseTemplate(template) {
  const lexer = TemplateLexer.tokenize(template);
  const parser = getTemplateParser(lexer.tokens);
  const ast = parser.parse();
  if (parser.errors.length > 0) {
    throw ParsingError.fromString(`Failed to parse template "${template}"
${parser.errors.map((e) => e.message).join("\n")}`);
  }
  return normalizeAst(ast);
}
function normalizeAst({ children }) {
  const literalParts = [];
  const expressions = [];
  const { embeddedExpr, litAfter } = { embeddedExpr: [], ...children };
  for (const {
    children: { escapedExpr, escapedExprStart, expr, exprStart, litBefore }
  } of embeddedExpr) {
    const literalBefore = litBefore ? extractStringImage(litBefore) : "";
    literalParts.push(literalBefore);
    if (escapedExpr) {
      (0, import_node_assert5.default)(escapedExprStart, "escapedExprStart must be present to have an escaped expr");
      (0, import_node_assert5.default)(escapedExpr.length === 1, "escapedExpr must have exactly one node");
      const escapeCharacters = extractStringImage(escapedExprStart).replaceAll("\\${{", "").replaceAll("\\\\", "\\");
      if (escapeCharacters !== "") {
        literalParts.push(escapeCharacters);
      }
      literalParts.push(EXPR_START);
      literalParts.push(extractStringImage(escapedExpr));
      literalParts.push(EXPR_END);
    } else if (expr) {
      (0, import_node_assert5.default)(exprStart, "exprStart must be present to have an expr");
      (0, import_node_assert5.default)(expr.length === 1, "expr must have exactly one node");
      const escapeCharacters = extractStringImage(exprStart).replaceAll("${{", "").replaceAll("\\\\", "\\");
      if (escapeCharacters !== "") {
        literalParts.push(escapeCharacters);
      }
      expressions.push({ insertAfter: literalParts.length - 1, expression: normalizeExpression(verifyExists(expr[0])) });
    } else {
      throw new Error("must have either an expr or escaped expr");
    }
  }
  literalParts.push(litAfter ? extractStringImage(litAfter) : "");
  const template = { literalParts, expressions };
  return template;
}
function normalizeExpression(expr) {
  const {
    children: { orExpr }
  } = expr;
  (0, import_node_assert5.default)(orExpr.length === 1, "orExpr must have exactly one node");
  return normalizeOrExpr(verifyExists(orExpr[0]));
}
function normalizeOrExpr(orExpr) {
  const {
    children: { andExpr: andExprs }
  } = verifyExists(orExpr);
  (0, import_node_assert5.default)(andExprs.length > 0, "orExprs must have at least one node");
  const normalized = andExprs.map((andExpr) => normalizeAndExpr(andExpr));
  const last = verifyExists(normalized[normalized.length - 1]);
  const rest = normalized.slice(0, normalized.length - 1);
  return rest.reverse().reduce((acc, curr) => {
    return { type: "Or" /* Or */, left: curr, right: acc };
  }, verifyExists(last));
}
function normalizeAndExpr(andExpr) {
  const {
    children: { compareExpr: compareExprs }
  } = verifyExists(andExpr);
  (0, import_node_assert5.default)(compareExprs.length > 0, "orExprs must have at least one node");
  const normalized = compareExprs.map((compareExpr) => normalizeCompareOrSingleExpr(compareExpr));
  const last = verifyExists(normalized[normalized.length - 1]);
  const rest = normalized.slice(0, normalized.length - 1);
  return rest.reverse().reduce((acc, curr) => {
    return { type: "And" /* And */, left: curr, right: acc };
  }, verifyExists(last));
}
function normalizeCompareOrSingleExpr(compareExpr) {
  const {
    children: { atomicExpr: atomicExprs, EqOp: eqOp, NotEqOp: notEqOp, MatchOp: matchOp, NotMatchOp: notMatchOp }
  } = compareExpr;
  (0, import_node_assert5.default)(atomicExprs.length > 0, "atomicExprs must have at least one node");
  (0, import_node_assert5.default)(atomicExprs.length <= 2, "atomicExprs must have at most two nodes");
  const [left, maybeRight] = atomicExprs.map((atomicExpr) => normalizeAtomicExpr(atomicExpr));
  (0, import_node_assert5.default)(left, "left must be defined");
  if (!maybeRight) {
    return left;
  }
  (0, import_node_assert5.default)(eqOp || notEqOp || matchOp || notMatchOp, "Must have eq, not eq, match, or not match op if there is a right atomic expr");
  if (eqOp) {
    return { type: "Eq" /* Eq */, left, right: maybeRight };
  }
  if (notEqOp) {
    return { type: "NotEq" /* NotEq */, left, right: maybeRight };
  }
  if (matchOp) {
    return { type: "Match" /* Match */, left, right: maybeRight };
  }
  if (notMatchOp) {
    return { type: "NotMatch" /* NotMatch */, left, right: maybeRight };
  }
  throw new Error("Unhandled operation");
}
function normalizeAtomicExpr(atomicExpr) {
  const {
    children: { expr }
  } = atomicExpr;
  (0, import_node_assert5.default)(expr && expr.length === 1, "expr must have exactly one node");
  const innerExpr = verifyExists(expr[0]);
  switch (innerExpr.name) {
    case "paranthesizedExpr":
      return normalizeParanthesizedExpr(innerExpr);
    case "access":
      return normalizeAccess(innerExpr);
    case "stringLiteral":
      return normalizeString(innerExpr);
    case "booleanLiteral":
      return normalizeBoolean(innerExpr);
  }
}
function normalizeParanthesizedExpr(paranthesizedExpr) {
  const {
    children: { expr }
  } = paranthesizedExpr;
  (0, import_node_assert5.default)(expr.length === 1, "expr must have exactly one node");
  return normalizeExpression(verifyExists(expr[0]));
}
function normalizeAccess(access) {
  const {
    children: { functionCall: headFunctionCall, ident: headIdent, chainedAccess }
  } = access;
  let head;
  if (headFunctionCall) {
    (0, import_node_assert5.default)(headFunctionCall.length === 1, "functionCall must have exactly one node");
    head = normalizeFunctionCall(verifyExists(headFunctionCall[0]));
  } else if (headIdent) {
    (0, import_node_assert5.default)(headIdent.length === 1, "ident must have exactly one node");
    head = { type: "StaticAccess" /* StaticAccess */, name: verifyExists(headIdent[0]).image };
  } else {
    throw new Error("access must be either an identifier or a function call");
  }
  const accesses = (chainedAccess ?? []).map(({ children: { staticAccess, dynamicAccess, functionAccess } }) => {
    return normalizeChainedAccess({ staticAccess, dynamicAccess, functionAccess });
  });
  return {
    type: "Access" /* Access */,
    path: [head, ...accesses]
  };
}
function normalizeChainedAccess({
  staticAccess: maybeStaticAccess,
  dynamicAccess: maybeDynamicAccess,
  functionAccess: maybeFunctionAccess
}) {
  if (maybeStaticAccess) {
    (0, import_node_assert5.default)(maybeStaticAccess.length === 1, "chained access must have only one static access");
    const {
      children: { ident: maybeIdent }
    } = verifyExists(maybeStaticAccess[0]);
    (0, import_node_assert5.default)(maybeIdent && maybeIdent.length === 1, "static access must have exactly one ident");
    return { type: "StaticAccess" /* StaticAccess */, name: verifyExists(maybeIdent[0]).image };
  } else if (maybeDynamicAccess) {
    (0, import_node_assert5.default)(maybeDynamicAccess.length === 1, "chained access must have only one dynamic access");
    const {
      children: { expr: maybeExpr }
    } = verifyExists(maybeDynamicAccess[0]);
    (0, import_node_assert5.default)(maybeExpr.length === 1, "dynamic access must have exactly one expr");
    return { type: "DynamicAccess" /* DynamicAccess */, arg: normalizeExpression(verifyExists(maybeExpr[0])) };
  } else if (maybeFunctionAccess) {
    (0, import_node_assert5.default)(maybeFunctionAccess.length === 1, "chained access must have only one function access");
    const {
      children: { functionCall: maybeFunctionCall }
    } = verifyExists(maybeFunctionAccess[0]);
    (0, import_node_assert5.default)(maybeFunctionCall.length === 1, "function access must have exactly one function call");
    return normalizeFunctionCall(verifyExists(maybeFunctionCall[0]));
  } else {
    throw new Error("access must be either an identifier or a function call");
  }
}
function normalizeFunctionCall(functionCall) {
  (0, import_node_assert5.default)(functionCall.children.functionName.length === 1, "function calls must have exactly one ");
  const functionName = verifyExists(functionCall.children.functionName[0]);
  const args = normalizeFunctionArgs(functionCall.children.firstArg, functionCall.children.commaArg);
  return { type: "FunctionCall" /* FunctionCall */, name: functionName.image, args };
}
function normalizeFunctionArgs(maybeFirstArg, maybeCommaArg) {
  if (!maybeFirstArg)
    return [];
  (0, import_node_assert5.default)(maybeFirstArg.length === 1, "Function calls can only have 1 first arg");
  const firstArg = verifyExists(maybeFirstArg[0]);
  const additionalArgs = (maybeCommaArg ?? []).map(({ children: { arg } }) => {
    (0, import_node_assert5.default)(arg.length === 1, "Comma arg can only have one argument");
    return normalizeExpression(verifyExists(arg[0]));
  });
  return [normalizeExpression(firstArg), ...additionalArgs];
}
function normalizeString(stringLiteral) {
  const {
    children: { str }
  } = stringLiteral;
  (0, import_node_assert5.default)(str?.length === 1, "str must have exactly one node");
  return { type: "String" /* String */, value: extractInnerString(str) };
}
function extractStringImage(token) {
  debugAssert(() => token.length === 1);
  return verifyExists(token[0]).image;
}
function extractInnerString(token) {
  const tok = token[0];
  (0, import_node_assert5.default)(tok && typeof tok.payload === "string", "token must be a string");
  return tok.payload;
}
function normalizeBoolean(booleanLiteral) {
  const {
    children: { bool }
  } = booleanLiteral;
  (0, import_node_assert5.default)(bool.length === 1, "bool must have exactly one node");
  return { type: "Boolean" /* Boolean */, value: extractInnerBoolean(bool) };
}
function extractInnerBoolean(token) {
  const tok = token[0];
  (0, import_node_assert5.default)(tok && (tok.image === "true" || tok.image === "false"), "token must be a boolean");
  return tok.image === "true";
}

// ../packages/task-parser/yaml-dsl/parser2.ts
var import_node_assert6 = __toESM(require("node:assert"), 1);

// ../packages/task-parser/yaml-dsl/common.ts
var import_path = require("path");
var TStringable = Type.Union([Type.String(), Type.Number(), Type.Boolean()], {
  errorMessage: `Expected a string, number, or boolean.`
});
function formatTypeErrors(schema, value, syntaxDescription) {
  const errors = Array.from(value_exports2.Errors(schema, value));
  return formatTypeErrorsHelp(errors, syntaxDescription);
}
function formatError(err) {
  switch (err.type) {
    case ValueErrorType.ObjectAdditionalProperties:
      return indent(`Unexpected property "${(0, import_path.basename)(err.path)}"`);
    case ValueErrorType.ObjectRequiredProperty:
      return indent(`The property "${(0, import_path.basename)(err.path)}" is required`);
    default:
      if (!err.path.length) {
        return indent(err.message);
      }
      return indent(`At "${err.path}":
` + indent(err.message));
  }
}
function formatTypeErrorsHelp(errors, context) {
  const formattedErrors = errors.map(formatError);
  return `Syntax error ${context}:
${formattedErrors.join("\n")}`;
}

// ../packages/logger/index.ts
var import_winston = __toESM(require_winston(), 1);

// ../packages/logger/test.ts
var import_winston_transport = __toESM(require_winston_transport(), 1);

// ../packages/logger/tags.ts
var Tags = new Singleton("log tags", {});

// ../packages/logger/test.ts
var logs = [];
var TestTransport = class extends import_winston_transport.default {
  constructor(opts = {}) {
    super(opts);
  }
  log(info, callback) {
    const taggedInfo = { ...info, ...Tags.get() };
    setImmediate(() => {
      this.emit("logged", taggedInfo);
    });
    logs.push(taggedInfo);
    if (callback) {
      callback();
    }
  }
  logv(info, next) {
    this.log(info, next);
  }
  cleanup() {
    logs.splice(0);
  }
};

// ../packages/logger/index.ts
var MintLoggerTransport = /* @__PURE__ */ ((MintLoggerTransport2) => {
  MintLoggerTransport2["ConsoleJson"] = "console-json";
  MintLoggerTransport2["ConsoleText"] = "console-text";
  MintLoggerTransport2["Test"] = "test";
  return MintLoggerTransport2;
})(MintLoggerTransport || {});
var logger;
function createLogger(context = {}) {
  if (!logger) {
    logger = makeLogger();
  }
  return logger.child(context);
}
function makeLogger() {
  const logLevel = process.env.MINT_LOGGER_LEVEL ?? "info";
  const enabledTransports = determineTransports();
  const transports = enabledTransports.map((t) => makeTransport(t, logLevel));
  return (0, import_winston.createLogger)({
    format: import_winston.format.timestamp(),
    transports
  });
}
function determineTransports() {
  const specifiedStrings = (process.env.MINT_LOGGER_TRANSPORTS ?? "").split(new RegExp("\\s*,\\s*"));
  const specifiedTransports = [];
  for (const string of specifiedStrings) {
    if (Object.values(MintLoggerTransport).includes(string)) {
      specifiedTransports.push(string);
    }
  }
  let enabledTransports = [];
  if (specifiedTransports.length > 0) {
    enabledTransports = specifiedTransports;
  } else if (process.env.NODE_ENV === "production") {
    enabledTransports.push("console-json" /* ConsoleJson */);
  } else if (process.env.NODE_ENV === "test") {
    enabledTransports.push("test" /* Test */);
  } else {
    enabledTransports.push("console-text" /* ConsoleText */);
  }
  return enabledTransports;
}
function jsonFriendlyErrorReplacer(_, value) {
  if (value instanceof Error) {
    return Object.assign({}, value, {
      name: value.name,
      message: value.message,
      stack: value.stack
    });
  }
  return value;
}
function makeTransport(mintTransport, logLevel) {
  switch (mintTransport) {
    case "console-json" /* ConsoleJson */:
      return new import_winston.transports.Console({
        level: logLevel,
        format: import_winston.format.combine(includeGlobalTags(), import_winston.format.errors(), import_winston.format.json({ replacer: jsonFriendlyErrorReplacer }))
      });
    case "console-text" /* ConsoleText */: {
      const formats = [import_winston.format.errors()];
      if (!process.env.MINT_LOGGER_SUPPRESS_COLORS) {
        formats.push(import_winston.format.colorize({ level: true }));
      }
      formats.push(
        import_winston.format.printf(({ level, message, timestamp, package: label, ...rest }) => {
          let timestampPart = "";
          if (timestamp) {
            timestampPart = `[${timestamp}] `;
          }
          const labelPart = label ? `(${label}) ` : "";
          const levelPart = level ? `[${level}]: ` : "";
          const messagePart = message ? message : "";
          let restPart = ` ${JSON.stringify(rest, jsonFriendlyErrorReplacer)}`;
          if (restPart === " {}") {
            restPart = "";
          }
          return timestampPart + labelPart + levelPart + messagePart + restPart;
        })
      );
      return new import_winston.transports.Console({
        level: logLevel,
        format: import_winston.format.combine(includeGlobalTags(), ...formats)
      });
    }
    case "test" /* Test */:
      return new TestTransport({ level: logLevel });
    default:
      assertExhaustive(mintTransport);
  }
}
var includeGlobalTags = (0, import_winston.format)((info) => {
  for (const [key, value] of Object.entries(Tags.get())) {
    info[key] = value;
  }
  return info;
});

// ../packages/task-parser/logger.ts
var logger2 = createLogger({ package: "bigtest" });
var logger_default = logger2;

// ../packages/utils/did-you-mean.ts
var import_damerau_levenshtein = __toESM(require_damerau_levenshtein(), 1);
function didYouMean(str, candidates) {
  const bestMatch = candidates.map((candidate) => ({
    candidate,
    ...(0, import_damerau_levenshtein.default)(str, candidate)
  })).filter((match) => match.similarity > 0.6).sort((a, b) => b.similarity - a.similarity)[0];
  if (!bestMatch) {
    return void 0;
  }
  return bestMatch.candidate;
}

// ../packages/task-parser/yaml-dsl/parser2.ts
var YamlParser = class _YamlParser {
  constructor(fileName, fileSource, doc, snippets) {
    this.doc = doc;
    this.snippets = snippets;
    this.stack = [];
    this.currentFileName = fileName;
    this.linesMap = { [fileName]: new LinesAndColumns(fileSource) };
    this.sourceMap = { [fileName]: fileSource };
    for (const snippet of snippets.values()) {
      this.linesMap[snippet.filePath] = new LinesAndColumns(snippet.fileContents);
      this.sourceMap[snippet.filePath] = snippet.fileContents;
    }
    for (const error of doc.errors) {
      let message = error.message;
      if (error.code === "DUPLICATE_KEY") {
        message = "You cannot declare the same key twice.";
      }
      const { line, column } = this.locationOfIndex(error.pos[0], fileName);
      this.messages.push({ message, severity: "error", stackTrace: [{ fileName, line, column }] });
    }
    for (const warning of doc.warnings) {
      const { line, column } = this.locationOfIndex(warning.pos[0], fileName);
      if (warning.code === "TAG_RESOLVE_FAILED") {
        const tagName = warning.message.match(/Unresolved tag: (.*)/)?.[1];
        if (tagName) {
          this.messages.push({
            message: `You started a value with a \`!\`, but in YAML \`!\` indicates a tag, not a value. Try wrapping your value in quotes instead: \`"${tagName}"\``,
            severity: "error",
            stackTrace: [{ fileName, line, column }]
          });
        } else {
          logger_default.warn(`Tag resolve failure did not match expected regex`, {
            codeFrame: this.generateCodeFrame({ fileName, line, column }),
            message: warning.message
          });
          this.messages.push({ message: warning.message, severity: "error", stackTrace: [{ fileName, line, column }] });
        }
      } else {
        logger_default.warn(`Detected unhandled YAML parsing warning code: ${warning.code}`, {
          codeFrame: this.generateCodeFrame({ fileName, line, column })
        });
      }
    }
    if (doc.contents === null) {
      this.rootNode = null;
    } else {
      for (const [source, startIndex] of this.detectCircularAliases(doc.contents).entries()) {
        const { line, column } = this.locationOfIndex(startIndex, fileName);
        this.messages.push({
          message: `Circular alias detected ${codeQuote(source.toString())}`,
          severity: "error",
          stackTrace: [{ fileName, line, column }]
        });
      }
      this.rootNode = this.synchronousDealias(doc.contents)[0];
    }
  }
  messages = [];
  linesMap;
  sourceMap;
  rootNode;
  warnedAboutUsingCacheInsteadOfCacheKey = false;
  currentFileName;
  stack;
  detectCircularAliases(document) {
    const circularAliases = /* @__PURE__ */ new Map();
    YAML.visit(document, {
      Alias(_key, aliasNode, path) {
        const anchor = path.find((node) => YAML.isNode(node) && node.anchor && node.anchor === aliasNode.source);
        if (YAML.isNode(anchor)) {
          (0, import_node_assert6.default)(anchor.range);
          circularAliases.set(aliasNode.source, anchor.range[0]);
        }
      }
    });
    return circularAliases;
  }
  static async parseRun(fileName, source, snippets) {
    const parser = _YamlParser.createParser(fileName, source, snippets);
    const partialRunDefinition = await parser.parseRun();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return partialRunDefinition;
  }
  static async safelyParseRun(fileName, source, snippets) {
    const parser = _YamlParser.createParser(fileName, source, snippets);
    const partialRunDefinition = await parser.parseRun();
    const { errors } = parser.formatMessages();
    return { partialRunDefinition, errors };
  }
  static async parseTaskOrTaskList(fileName, source, snippets) {
    const parser = _YamlParser.createParser(fileName, source, snippets);
    const partialTaskDefinitions = await parser.parseTaskOrTaskList();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return partialTaskDefinitions;
  }
  static async parseLeafSpec(fileName, source) {
    const parser = _YamlParser.createParser(fileName, source, /* @__PURE__ */ new Map());
    const leafSpec = await parser.parseLeafSpec();
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return leafSpec;
  }
  static createParser(fileName, source, snippets) {
    const schemaOptions = { merge: true, prettyErrors: false, stringKeys: true };
    const doc = YAML.parseDocument(source, schemaOptions);
    const parser = new _YamlParser(fileName, source, doc, snippets);
    const { errors } = parser.formatMessages();
    if (errors.length) {
      throw new ParsingError(errors);
    }
    return parser;
  }
  dealias = async (node, callback) => {
    const [dealiasedNode, didDealias, aliasName] = this.synchronousDealias(node);
    if (didDealias) {
      (0, import_node_assert6.default)(YAML.isAlias(node));
      const { line, column } = this.locationOfIndex(node.range[0], this.currentFileName);
      this.stack.push({ fileName: this.currentFileName, line, column, name: aliasName });
    }
    const result = await callback(dealiasedNode);
    if (didDealias) {
      this.stack.pop();
    }
    return result;
  };
  synchronousDealias = (node) => {
    let didDealias = false;
    let aliasName;
    if (YAML.isAlias(node)) {
      didDealias = true;
      aliasName = `*${node.source}`;
      const newNode = node.resolve(this.doc);
      const { line, column } = this.locationOfIndex(node.range[0], this.currentFileName);
      if (newNode === void 0) {
        throw new ParsingError([
          this.formatMessage({
            message: `Unresolved alias (the anchor must be set before the alias)`,
            severity: "error",
            stackTrace: [...this.stack, { fileName: this.currentFileName, line, column }]
          })
        ]);
      }
      node = newNode;
    }
    return [node, didDealias, aliasName];
  };
  parseRun = async () => {
    const warningCollector = [];
    if (this.rootNode === null) {
      this.error([`A run definition must include at least a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [] };
    }
    const { fields } = await this.parseObject(
      this.rootNode,
      {
        "concurrency-pools": this.parseRunConcurrenyPools,
        on: this.parseRunOn,
        "tool-cache": this.parseRunToolCache,
        tasks: this.parseTasksList,
        base: this.parseBaseLayer,
        aliases: () => {
        }
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A run definition must contain a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [] };
    }
    if (fields.base === void 0) {
      warningCollector.push(
        buildMessage({
          type: "warning" /* Warning */,
          message: [
            `Run definitions without a ${codeQuote("base")} configuration will start failing on June 27, 2025. This run has been defaulted to ${codeQuote(
              defaultBaseLayer.os
            )}.`
          ],
          docs: `See ${"https://www.rwx.com/docs/mint/base" /* Base */} to learn about configuring the ${codeQuote("base")} layer.`
        })
      );
    }
    return {
      concurrencyPools: fields["concurrency-pools"],
      toolCache: fields["tool-cache"],
      triggers: fields.on,
      tasks: fields.tasks,
      baseLayer: fields.base,
      warningMessages: warningCollector
    };
  };
  parseTaskOrTaskList = async () => {
    if (this.rootNode === null) {
      this.error([`Expected a task, or a list of tasks`], this.doc);
      return [];
    }
    if (YAML.isSeq(this.rootNode)) {
      return this.parseTasksList(this.rootNode, [], this.doc.range[0]);
    }
    if (YAML.isMap(this.rootNode)) {
      const task = await this.parseTask(this.rootNode, [], this.doc.range[0]);
      return [task];
    }
    this.error([`Expected a task, or a list of tasks`], this.rootNode);
    return [];
  };
  parseLeafSpec = async () => {
    const warningCollector = [];
    if (this.rootNode === null) {
      this.error([`A leaf spec must include at least a ${codeQuote("tasks")} key`], this.doc);
      return { tasks: [], warningMessages: [] };
    }
    const { fields } = await this.parseObject(
      this.rootNode,
      {
        name: this.parseLeafName,
        version: this.parseLeafVersion,
        description: this.parseString,
        source_code_url: this.parseString,
        issue_tracker_url: this.parseString,
        parameters: this.parseLeafSpecParameters,
        outputs: this.parseLeafSpecOutputs,
        tasks: this.parseTasksList
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A leaf spec must contain a ${codeQuote("tasks")} key`], this.doc);
      fields.tasks = [];
    }
    const start = 0;
    const end = this.rootNode.range[1];
    return {
      tasks: fields.tasks,
      description: fields.description,
      sourceCodeUrl: fields.source_code_url,
      issueTrackerUrl: fields.issue_tracker_url,
      name: fields.name,
      parameters: fields.parameters,
      outputs: fields.outputs,
      version: fields.version,
      rawSource: { definition: verifyExists(this.sourceMap[this.currentFileName]).slice(start, end), start, end },
      warningMessages: warningCollector
    };
  };
  parseRunConcurrenyPools = async (node, warningCollector) => {
    return this.parseList(node, this.parseRunConcurrenyPool, warningCollector);
  };
  parseRunConcurrenyPool = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        id: this.parseStringTemplate,
        if: this.parseExactExpression,
        capacity: (node2) => this.parseNumber(node2, { minimum: 1 }),
        "on-overflow": (node2) => this.parseTypeBox(node2, Type.Enum(OnOverflow))
      },
      warningCollector
    );
    if (fields.id === void 0) {
      this.error([`A concurrency pool must have an ${codeQuote("id")} key`], node);
      fields.id = "";
    }
    if (fields["on-overflow"] === void 0) {
      this.error([`A concurrency pool must have an ${codeQuote("on-overflow")} key`], node);
      fields["on-overflow"] = "queue" /* Queue */;
    }
    const concurrencyPool = {
      id: fields.id,
      if: fields.if,
      capacity: fields.capacity ?? 1,
      onOverflow: fields["on-overflow"]
    };
    return concurrencyPool;
  };
  parseBaseLayer = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        os: this.parseStringableTemplate,
        tag: this.parseStringableTemplate,
        arch: this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.os === void 0) {
      this.error([`A base layer must have an ${codeQuote("os")} key`], node);
      fields.os = "";
    }
    if (fields.tag === void 0) {
      this.error([`A base layer must have a ${codeQuote("tag")} key`], node);
      fields.tag = "";
    } else if (/^\d+$/.test(fields.tag)) {
      fields.tag = `${fields.tag}.0`;
    }
    return {
      os: fields.os,
      tag: fields.tag,
      arch: fields.arch
    };
  };
  parseRunOn = async (node, warningCollector) => {
    if (YAML.isScalar(node) && node.value === null) {
      return void 0;
    }
    const { fields } = await this.parseObject(
      node,
      {
        github: this.parseGithubTriggers,
        gitlab: this.parseGitlabTriggers,
        cron: this.parseCronTriggers,
        cli: this.parseCliTrigger,
        dispatch: this.parseDispatchTriggers
      },
      warningCollector
    );
    return {
      github: fields.github ?? { mergeGroup: [], pullRequest: [], push: [] },
      gitlab: fields.gitlab ?? { push: [], tagPush: [], mergeRequest: [] },
      cron: fields.cron ?? [],
      // For compatibility with the old parser. Can be removed later.
      cli: fields.cli ?? { title: void 0, init: {} },
      dispatch: fields.dispatch ?? []
    };
  };
  parseGithubTriggers = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        push: this.parseGithubPushTriggers,
        pull_request: this.parseGithubPullRequestTriggers,
        merge_group: this.parseGithubMergeGroupTriggers
      },
      warningCollector
    );
    return {
      push: fields.push ?? [],
      pullRequest: fields.pull_request ?? [],
      mergeGroup: fields.merge_group ?? []
    };
  };
  parseGithubPushTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGithubPushTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGithubPushTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGithubPullRequestTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGithubPullRequestTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGithubPullRequestTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGithubMergeGroupTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGithubMergeGroupTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGithubMergeGroupTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGithubPushTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        "status-checks": this.parseGithubStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      statusChecks: fields["status-checks"] ?? []
    };
  };
  parseGithubPullRequestTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        actions: (actionList) => this.parseList(actionList, this.parseString, warningCollector),
        "status-checks": this.parseGithubStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      actions: fields.actions,
      statusChecks: fields["status-checks"] ?? []
    };
  };
  parseGithubMergeGroupTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        actions: (actionList) => this.parseList(actionList, this.parseString, warningCollector),
        "status-checks": this.parseGithubStatusChecks
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      actions: fields.actions,
      statusChecks: fields["status-checks"] ?? []
    };
  };
  parseGithubStatusChecks = async (node, warningCollector) => {
    return this.parseList(node, this.parseGithubStatusCheck, warningCollector);
  };
  parseGithubStatusCheck = async (node, warningCollector, start) => {
    const { fields } = await this.parseObject(
      node,
      {
        tasks: (taskListOrTask) => this.parseListOrValue(taskListOrTask, this.parseString, warningCollector, start),
        name: this.parseString
      },
      warningCollector
    );
    if (fields.tasks === void 0) {
      this.error([`A GitHub status check must specify the ${codeQuote("tasks")} it reports.`], node);
      fields.tasks = [];
    }
    if (typeof fields.tasks === "string") {
      fields.tasks = [fields.tasks];
    }
    return {
      tasks: fields.tasks,
      name: fields.name,
      status: "pending"
    };
  };
  parseGitlabTriggers = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        push: this.parseGitlabPushOrTagPushTriggers,
        "tag-push": this.parseGitlabPushOrTagPushTriggers,
        "merge-request": this.parseGitlabMergeRequestTriggers
      },
      warningCollector
    );
    return {
      push: fields.push ?? [],
      tagPush: fields["tag-push"] ?? [],
      mergeRequest: fields["merge-request"] ?? []
    };
  };
  parseGitlabPushOrTagPushTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGitlabPushOrTagPushTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGitlabPushOrTagPushTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGitlabMergeRequestTriggers = async (node, warningCollector, start) => {
    if (YAML.isMap(node) || isYamlNull(node)) {
      const trigger = await this.parseGitlabMergeRequestTrigger(node, warningCollector, start);
      return [trigger];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseGitlabMergeRequestTrigger, warningCollector);
    }
    this.error([`Expected one trigger, or a list of triggers`], node);
    return [];
  };
  parseGitlabPushOrTagPushTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title
    };
  };
  parseGitlabMergeRequestTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        actions: (actionList) => this.parseList(actionList, this.parseString, warningCollector)
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      actions: fields.actions
    };
  };
  parseCronTriggers = async (node, warningCollector) => {
    if (isYamlNull(node)) {
      return [];
    }
    const seenKeys = /* @__PURE__ */ new Set();
    const cronTriggerParser = this.parseCronTrigger(seenKeys);
    return this.parseList(node, cronTriggerParser, warningCollector);
  };
  parseCronTrigger = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        key: this.parseKey,
        schedule: this.parseString,
        branch: this.parseString,
        "reset-tool-cache": this.parseBoolean
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A cron trigger must have a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate cron ${codeQuote(fields.key)} found. Cron keys must be unique within a run definition.`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.schedule === void 0) {
      this.error([`A cron trigger must have a ${codeQuote("schedule")} key`], node);
      fields.schedule = "";
    }
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      key: fields.key,
      schedule: fields.schedule,
      branch: fields.branch,
      resetToolCache: fields["reset-tool-cache"]
    };
    return trigger;
  };
  parseCliTrigger = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        title: this.parseString
      },
      warningCollector
    );
    return {
      init: fields.init ?? {},
      title: fields.title
    };
  };
  parseDispatchTriggers = async (node, warningCollector) => {
    if (isYamlNull(node)) {
      return [];
    }
    const seenKeys = /* @__PURE__ */ new Set();
    const dispatchTriggerParser = this.parseDispatchTrigger(seenKeys);
    return this.parseList(node, dispatchTriggerParser, warningCollector);
  };
  parseDispatchTrigger = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        init: this.parseInit,
        if: this.parseExactExpression,
        target: this.parseTriggerTarget,
        title: this.parseStringTemplate,
        key: this.parseKey,
        params: (node2) => this.parseList(node2, this.parseDispatchParam, warningCollector)
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A dispatch trigger must have a globally unique ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate dispatch ${codeQuote(fields.key)} found. Dispatch keys must be globally unique.`], keyNode);
    }
    seenKeys.add(fields.key);
    const trigger = {
      init: fields.init ?? {},
      if: fields.if,
      target: fields.target,
      title: fields.title,
      key: fields.key,
      params: fields.params ?? []
    };
    return trigger;
  };
  parseDispatchParam = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return {
        key,
        name: void 0,
        description: void 0,
        default: void 0,
        required: false
      };
    }
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        name: this.parseString,
        description: this.parseString,
        default: this.parseString,
        required: this.parseBoolean
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A dispatch param must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    return {
      key: fields.key,
      name: fields.name,
      description: fields.description,
      default: fields.default,
      required: fields.required ?? false
    };
  };
  parseTriggerTarget = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return [key];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseKey, warningCollector, { minimumItems: 1 });
    }
    this.error(["Expected a task key, or a list of task keys"], node);
    return [];
  };
  parseRunToolCache = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        vault: this.parseString
      },
      warningCollector
    );
    if (fields.vault === void 0) {
      this.error([`Tool cache configurations must have a ${codeQuote("vault")} key`], node);
      fields.vault = "";
    }
    const toolCache = {
      vault: fields.vault
    };
    return toolCache;
  };
  parseTasksList = async (node, warningCollector, listStart) => {
    return this.parseList(node, this.parseTask, warningCollector, { listStart, minimumItems: 1 });
  };
  static FAKE_TASK = {
    type: "leaf" /* Leaf */,
    key: "#fake",
    dependencies: { type: "standard" /* Standard */, keys: [] },
    leaf: { type: "digest" /* Digest */, digest: "" },
    warningMessages: []
  };
  parseTask = async (node, _, start) => {
    const warningCollector = [];
    const errorMessage = `Expected a task with a ${codeQuote("run")} key, a leaf with a ${codeQuote("call")} key, or an embedded run with a ${codeQuote(
      "call"
    )} key`;
    if (!YAML.isMap(node)) {
      this.error([errorMessage], node);
      return _YamlParser.FAKE_TASK;
    }
    const taskFields = await this.parseGenericRecord(node, (n) => n.toString(), []);
    let task;
    if ("run" in taskFields) {
      task = await this.parseCommandTask(node, warningCollector, start);
    } else if ("call" in taskFields) {
      if (taskFields.call.trim().startsWith("${{")) {
        task = await this.parseEmbeddedRunTask(node, warningCollector, start);
      } else {
        task = await this.parseLeafTask(node, warningCollector, start);
      }
    } else {
      this.error([errorMessage], node);
      return _YamlParser.FAKE_TASK;
    }
    const end = node.range[1];
    task.rawSource = { definition: verifyExists(this.sourceMap[this.currentFileName]).slice(start, end), start, end };
    return task;
  };
  parseCommandTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        agent: this.parseAgent,
        key: this.parseKey,
        use: this.parseUse,
        after: this.parseAfter,
        if: this.parseExactExpression,
        filter: this.parseCommandFilter,
        cache: this.parseCache({ command: true }),
        run: this.parseCommand,
        "background-processes": this.parseBackgroundProcesses,
        outputs: this.parseOutputs,
        env: this.parseEnv,
        "env-config": this.parseEnvConfig,
        "timeout-minutes": (n) => this.parseNumber(n),
        "terminate-grace-period-seconds": (node2) => this.parseNumber(node2, { minimum: 0 }),
        "tool-cache": this.parseTaskToolCache,
        parallel: this.parseParallel,
        docker: this.parseDocker
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.run === void 0) {
      this.error([`A command task must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    let env = void 0;
    if (fields.env || fields["env-config"]) {
      env = {
        envVars: fields.env,
        inherit: fields["env-config"]?.inherit,
        merge: fields["env-config"]?.merge
      };
    }
    return {
      type: "command" /* Command */,
      agent: fields.agent ?? { disk: {} },
      key: fields.key,
      command: fields.run,
      dependencies: fields.use ?? { type: "standard" /* Standard */, keys: [] },
      backgroundProcesses: fields["background-processes"] ?? [],
      artifactPaths: fields.outputs?.artifactPaths ?? [],
      problemMatchers: fields.outputs?.problemMatchers ?? [],
      problemPaths: fields.outputs?.problemPaths ?? [],
      successExitCodes: fields.outputs?.successExitCodes ?? [],
      testResultsPaths: fields.outputs?.testResultsPaths ?? [],
      values: fields.outputs?.values ?? [],
      after: fields.after,
      cacheConfiguration: fields.cache,
      docker: fields.docker,
      env,
      filter: fields.filter,
      if: fields.if,
      parallel: fields.parallel,
      timeoutMinutes: fields["timeout-minutes"],
      terminateGracePeriodSeconds: fields["terminate-grace-period-seconds"],
      toolCache: fields["tool-cache"],
      warningMessages: warningCollector,
      outputFilesystemFilter: fields.outputs?.filesystem?.filter ?? {}
    };
  };
  parseLeafTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        use: this.parseUse,
        after: this.parseAfter,
        if: this.parseExactExpression,
        filter: this.parseWorkspaceFilter,
        cache: this.parseCache({ command: false }),
        call: this.parseLeafIdentifier,
        with: this.parseInit,
        env: this.parseEnv,
        "env-config": this.parseEnvConfig,
        parallel: this.parseParallel
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.call === void 0) {
      this.error([`Missing a ${codeQuote("call")} key with the name of the leaf`], node);
      fields.call = { type: "digest" /* Digest */, digest: "" };
    }
    let env = void 0;
    if (fields.env || fields["env-config"]) {
      env = {
        envVars: fields.env,
        inherit: fields["env-config"]?.inherit,
        merge: fields["env-config"]?.merge
      };
    }
    return {
      type: "leaf" /* Leaf */,
      key: fields.key,
      dependencies: fields.use ?? { type: "standard" /* Standard */, keys: [] },
      after: fields.after,
      if: fields.if,
      cacheConfiguration: fields.cache,
      parallel: fields.parallel,
      leaf: fields.call,
      filter: fields.filter ? { workspace: fields.filter } : void 0,
      parameters: fields.with,
      env,
      warningMessages: warningCollector
    };
  };
  parseLeafName = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_NAME = new RegExp("^\\s*([a-z0-9-]+\\/[a-z0-9-]+)\\s*$");
    if (parsed.match(RE_LEAF_NAME) === null) {
      this.error(
        [`Invalid leaf name; a leaf name must match the regex ${codeQuote(RE_LEAF_NAME.source)} (for example, ${codeQuote("mint/install-cli")})`],
        node
      );
    }
    return parsed;
  };
  parseLeafVersion = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_VERSION = new RegExp("^\\s*([0-9]+\\.[0-9]+\\.[0-9]+)\\s*$");
    if (parsed.match(RE_LEAF_VERSION) === null) {
      this.error(
        [`Invalid leaf version; a leaf version must match the regex ${codeQuote(RE_LEAF_VERSION.source)} (for example, ${codeQuote("1.0.2")})`],
        node
      );
    }
    return parsed;
  };
  parseLeafIdentifier = (node) => {
    const parsed = this.parseString(node);
    const RE_LEAF_NAME_VERSION = new RegExp("^\\s*([a-z0-9-]+\\/[a-z0-9-]+)\\s+([0-9]+\\.[0-9]+\\.[0-9]+)\\s*$");
    const RE_LEAF_DIGEST = new RegExp("^[a-f0-9]{64}$");
    const matchNameVersion = parsed.match(RE_LEAF_NAME_VERSION);
    if (matchNameVersion) {
      const [name, version] = matchNameVersion.slice(1);
      (0, import_node_assert6.default)(name && version, `Missing name or version after checking regex on "${parsed}"`);
      return { type: "name-version" /* NameVersion */, name, version };
    }
    const matchDigest = parsed.match(RE_LEAF_DIGEST);
    if (matchDigest) {
      return { type: "digest" /* Digest */, digest: parsed };
    }
    this.error([`Expected a leaf with a name and version (like ${codeQuote("mint/install-cli 1.0.0")}), or its digest.`], node);
    return { type: "digest" /* Digest */, digest: "" };
  };
  parseEmbeddedRunTask = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        after: this.parseAfter,
        if: this.parseExactExpression,
        cache: this.parseCache({ command: false }),
        parallel: this.parseParallel,
        call: this.parseEmbeddedRunDefinitionSource,
        init: this.parseInit,
        target: this.parseTriggerTarget
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A task must have a ${codeQuote("key")}`], node);
      fields.key = "";
    }
    if (fields.call === void 0) {
      this.error([`An embedded run must have a ${codeQuote("call")} key with the source of the embedded run`], node);
      fields.call = { type: "in-memory-mint-dir" /* InMemoryMintDir */, runDefinitionPath: "" };
    }
    return {
      type: "embedded-run" /* EmbeddedRun */,
      key: fields.key,
      after: fields.after,
      cacheConfiguration: fields.cache,
      if: fields.if,
      parallel: fields.parallel,
      runDefinitionSource: fields.call,
      parameters: fields.init,
      warningMessages: warningCollector,
      targets: typeof fields.target === "string" ? [fields.target] : fields.target
    };
  };
  parseEmbeddedRunDefinitionSource = (node) => {
    const value = this.parseString(node);
    const RE_IN_MEMORY_RUN_DEFINITION_PATH = new RegExp("^\\s*\\${{\\s*run\\.(mint-dir|dir)\\s*}}\\/(?<path>.+\\.[yY][aA]?[mM][lL])\\s*$");
    const matchInMemoryPath = value.match(RE_IN_MEMORY_RUN_DEFINITION_PATH);
    if (matchInMemoryPath) {
      const path = matchInMemoryPath.groups?.path;
      if (path === void 0) {
        throw new Error(`Did not expect to fail to match ${RE_IN_MEMORY_RUN_DEFINITION_PATH.source} against ${value} at this point`);
      }
      return { type: "in-memory-mint-dir" /* InMemoryMintDir */, runDefinitionPath: path };
    } else {
      const expression = this.parseExactExpression(node);
      return { type: "task-artifact" /* TaskArtifact */, expression };
    }
  };
  parseAgent = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        disk: this.parseAgentDisk,
        memory: this.parseStringTemplate,
        // this one is string, not stringable, because we expect [0-9]+gb
        cpus: this.parseStringableTemplate,
        // this one is stringable, not string, because we support a number
        "static-ips": this.parseStringTemplate,
        tmpfs: this.parseBoolean
      },
      warningCollector
    );
    return { memory: fields.memory, cpus: fields.cpus, disk: fields.disk ?? {}, staticIps: fields["static-ips"], tmpfs: fields.tmpfs };
  };
  parseAgentDisk = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return { size: await this.parseStringTemplate(node) };
    }
    const { fields } = await this.parseObject(
      node,
      {
        size: this.parseStringTemplate
      },
      warningCollector
    );
    return { size: fields.size };
  };
  parseUse = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      return this.parseUseTask(node, warningCollector, start);
    } else if (YAML.isSeq(node)) {
      return this.parseUseTaskList(node, warningCollector, start);
    }
    this.error([`Expected a task key or a list of task keys`], node);
    return { type: "standard" /* Standard */, keys: [] };
  };
  parseUseTask = async (node, warningCollector, start) => {
    const key = await this.parseKey(node, warningCollector, start);
    return { type: "standard" /* Standard */, keys: [key] };
  };
  parseUseTaskList = async (node, warningCollector) => {
    const keys = await this.parseList(node, this.parseKey, warningCollector);
    return { type: "standard" /* Standard */, keys };
  };
  parseAfter = async (node, warningCollector, start) => {
    if (YAML.isScalar(node) && node.toString().trim().startsWith("${{")) {
      return this.parseAfterExpression(node, warningCollector, start);
    } else if (YAML.isScalar(node)) {
      return this.parseAfterTask(node, warningCollector, start);
    } else if (YAML.isSeq(node)) {
      return this.parseAfterTaskList(node, warningCollector, start);
    }
    this.error([`Expected a task key, a list of task keys, or an expression`], node);
    return { type: 2 /* Template */, template: "true" };
  };
  parseAfterTask = async (node, warningCollector, start) => {
    const task = await this.parseKey(node, warningCollector, start);
    return { type: 0 /* Task */, task };
  };
  parseAfterTaskList = async (node, warningCollector) => {
    const tasks = await this.parseList(node, this.parseKey, warningCollector);
    return { type: 1 /* TaskList */, tasks };
  };
  parseAfterExpression = (node) => {
    const template = this.parseExactExpression(node);
    return { type: 2 /* Template */, template };
  };
  parseCommandFilter = async (node, warningCollector, start) => {
    if (!YAML.isMap(node)) {
      const workspace2 = await this.parseWorkspaceFilter(node, warningCollector, start);
      return { workspace: workspace2, artifacts: void 0 };
    }
    const { workspace, ...artifacts } = await this.parseGenericRecord(node, this.parseWorkspaceFilter, warningCollector, {
      keyParser: (node2) => {
        const key = this.parseString(node2);
        if (key === "" || key === "workspace")
          return key;
        if (key.startsWith("${{") && key.endsWith("}}")) {
          const checkedTemplate = this.checkTemplate(node2, key);
          if (checkedTemplate === "")
            return key;
          return checkedTemplate;
        }
        this.error([`Must be either ${codeQuote("workspace")} or an expression referencing an artifact.`], node2);
        return key;
      }
    });
    return { workspace, artifacts };
  };
  parseWorkspaceFilter = (node, warningCollector) => {
    if (YAML.isScalar(node) && node.toString().trim().startsWith("${{")) {
      return this.parseStringTemplate(node);
    }
    return this.parseList(node, this.parseFilterEntry, warningCollector);
  };
  parseFilterEntry = async (node, warningCollector) => {
    if (YAML.isMap(node)) {
      const { fields } = await this.parseObject(
        node,
        {
          path: this.parseStringTemplate,
          "cache-key": this.parseString
        },
        warningCollector
      );
      let cacheKey = fields["cache-key"];
      if (!cacheKey) {
        cacheKey = "included";
      }
      if (cacheKey !== "included" && cacheKey !== "excluded") {
        this.error(["`cacheKey` must either be `included` or `excluded`"], node);
        return "";
      }
      if (!fields.path) {
        this.error(["Expected an object with the fields `path` and `cacheKey`."], node);
        return "";
      }
      if (fields.path.startsWith("/") || fields.path.startsWith("!/")) {
        this.error(["Starting a filter entry path with `/` is forbidden. All filter entries are relative to the Mint workspace."], node);
      }
      return { path: fields.path, cacheKey };
    }
    const filterEntry = await this.parseStringTemplate(node);
    if (filterEntry.startsWith("/") || filterEntry.startsWith("!/")) {
      this.warning({
        warningCollector,
        node,
        message: "Starting a filter entry with `/` is deprecated. All filter entries are relative to the Mint workspace."
      });
    }
    return filterEntry;
  };
  parseCache = ({ command }) => async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      if (typeof node.value === "boolean") {
        return { enabled: node.value, ttl: void 0 };
      }
      return { enabled: this.parseExactExpression(node), ttl: void 0 };
    } else if (YAML.isMap(node)) {
      const configuration = await this.parseObject(
        node,
        {
          enabled: (node2) => {
            if (!YAML.isScalar(node2)) {
              this.error([`Expected a boolean or an expression`], node2);
              return true;
            }
            if (typeof node2.value === "boolean") {
              return node2.value;
            }
            return this.parseExactExpression(node2);
          },
          ttl: this.parseStringableTemplate
        },
        warningCollector
      );
      if (configuration.fields.enabled === void 0) {
        this.error([`The ${codeQuote("enabled")} field is required.`], node);
        configuration.fields.enabled = true;
      }
      if (!command && configuration.fields.ttl !== void 0) {
        this.error([`The ${codeQuote("ttl")} field is only configurable for commands.`], node);
        configuration.fields.ttl = void 0;
      }
      return { enabled: configuration.fields.enabled, ttl: configuration.fields.ttl };
    }
    if (command) {
      this.error([`Expected a boolean, an expression, or an object with ${codeQuote("enabled")} and ${codeQuote("ttl")} keys`], node);
    } else {
      this.error([`Expected a boolean, an expression, or an object with an ${codeQuote("enabled")} key`], node);
    }
    return { enabled: true, ttl: void 0 };
  };
  parseCommand = async (node, warningCollector) => {
    if (YAML.isSeq(node)) {
      const templateList = await this.parseList(node, this.parseStringableTemplate, warningCollector);
      return templateList.join("\n");
    }
    const template = await this.parseStringableTemplate(node);
    if (template.trim() === "") {
      this.error([`The ${codeQuote("run")} field must contain the command to run and must not be empty`], node);
    }
    return template;
  };
  parseDocker = (node) => {
    if (!YAML.isScalar(node)) {
      this.error([`Expected a boolean, 'preserve-data', or an expression`], node);
      return true;
    }
    if (typeof node.value === "boolean" || node.value === "preserve-data") {
      return node.value;
    }
    if (node.toString().startsWith("${{")) {
      return this.parseExactExpression(node);
    }
    this.error([`Expected a boolean, 'preserve-data', or an expression`], node);
    return true;
  };
  parseBackgroundProcesses = async (node, warningCollector) => {
    const seenKeys = /* @__PURE__ */ new Set();
    const backgroundProcessesParser = this.parseBackgroundProcess(seenKeys);
    return this.parseList(node, backgroundProcessesParser, warningCollector);
  };
  parseBackgroundProcessAfter = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const key = await this.parseKey(node, warningCollector, start);
      return [key];
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseKey, warningCollector);
    }
    this.error(["Expected a background process key, or a list of background process keys"], node);
    return [];
  };
  parseBackgroundProcess = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        run: this.parseCommand,
        "ready-check": this.parseReadyCheck,
        after: this.parseBackgroundProcessAfter,
        "terminate-grace-period-seconds": (node2) => this.parseNumber(node2, { minimum: 0 })
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`A background process must have a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`Duplicate background process ${codeQuote(fields.key)}`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.run === void 0) {
      this.error([`A background process must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    return {
      key: fields.key,
      run: fields.run,
      readyCheck: fields["ready-check"],
      terminateGracePeriodSeconds: fields["terminate-grace-period-seconds"],
      after: fields.after
    };
  };
  parseReadyCheck = async (node, ...args) => {
    if (YAML.isMap(node)) {
      return this.parseReadyCheckObject(node, ...args);
    } else if (YAML.isScalar(node) || YAML.isSeq(node)) {
      const run = await this.parseCommand(node, ...args);
      return { run };
    }
    this.error([`Expected a command to run, or an object with ${codeQuote("run")} and ${codeQuote("timeout-seconds")} keys`], node);
    return { run: "" };
  };
  parseReadyCheckObject = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        run: this.parseCommand,
        "timeout-seconds": (node2) => this.parseNumber(node2, { minimum: 1 })
      },
      warningCollector
    );
    if (fields.run === void 0) {
      this.error([`A ready check must have a ${codeQuote("run")} key with the command to run`], node);
      fields.run = "";
    }
    return {
      run: fields.run,
      timeoutSeconds: fields["timeout-seconds"]
    };
  };
  parseOutputs = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        "execution-status": this.parseOutputExecutionStatus,
        "test-results": this.parseOutputTestResults,
        values: this.parseOutputValues,
        problems: this.parseOutputProblems,
        artifacts: this.parseOutputArtifacts,
        filesystem: this.parseOutputFilesystem
      },
      warningCollector
    );
    return {
      successExitCodes: fields["execution-status"],
      testResultsPaths: fields["test-results"],
      values: fields.values,
      problemMatchers: fields.problems?.problemMatchers,
      problemPaths: fields.problems?.problemPaths,
      artifactPaths: fields.artifacts,
      filesystem: fields.filesystem
    };
  };
  parseOutputExecutionStatus = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        "success-exit-codes": (node2) => this.parseList(node2, (n) => this.parseNumber(n), warningCollector)
      },
      warningCollector
    );
    return fields["success-exit-codes"];
  };
  parseOutputTestResults = (node, warningCollector) => {
    return this.parseList(node, this.parseOutputTestResult, warningCollector);
  };
  parseOutputTestResult = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        path: this.parseString,
        options: this.parseOutputTestResultOptions
      },
      warningCollector
    );
    if (fields.path === void 0) {
      this.error([`A test result output must include a ${codeQuote("path")} key indicating the test result file`], node);
      fields.path = "";
    }
    return {
      path: fields.path,
      options: fields.options
    };
  };
  parseOutputTestResultOptions = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        framework: this.parseString,
        language: this.parseString
      },
      warningCollector
    );
    if (fields.framework === void 0) {
      this.error([`Options configured for a test result output must include ${codeQuote("framework")}`], node);
      fields.framework = "";
    }
    if (fields.language === void 0) {
      this.error([`Options configured for a test result output must include ${codeQuote("language")}`], node);
      fields.language = "";
    }
    return {
      framework: fields.framework,
      language: fields.language
    };
  };
  parseOutputValues = async (node, warningCollector) => {
    return this.parseList(node, this.parseString, warningCollector);
  };
  parseOutputProblems = async (node, warningCollector) => {
    const problemOutputs = await this.parseList(node, this.parseProblemMatcherOrProblemPath, warningCollector);
    const problemMatchers = [];
    const problemPaths = [];
    for (const problemOutput of problemOutputs) {
      if (Array.isArray(problemOutput)) {
        problemMatchers.push(...problemOutput);
      } else {
        problemPaths.push(problemOutput);
      }
    }
    return { problemMatchers, problemPaths };
  };
  parseProblemMatcherOrProblemPath = async (node, warningCollector, start) => {
    const errorMessage = `Expected a problem matcher with a ${codeQuote("matcher")} key, a problems path with a ${codeQuote("path")} key`;
    if (!YAML.isMap(node)) {
      this.error([errorMessage], node);
      return [];
    }
    const matcherField = node.items.find((field) => field.key.toString() === "matcher");
    const pathField = node.items.find((field) => field.key.toString() === "path");
    if (matcherField) {
      return this.parseProblemMatcher(node, warningCollector, start);
    }
    if (pathField) {
      return this.parseProblemPath(node, warningCollector, start);
    }
    this.error([errorMessage], node);
    return [];
  };
  parseProblemMatcher = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        matcher: this.parseString
      },
      warningCollector
    );
    const { matcher } = fields;
    if (matcher === void 0) {
      this.error([`A problem matcher must include a ${codeQuote("matcher")} key indicating the name or URL of the matcher`], node);
      return [];
    }
    const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "matcher"))[1];
    let nonValidatedMatcherConfig;
    if (isBuiltinProblemMatcher(matcher)) {
      nonValidatedMatcherConfig = BUILT_IN_PROBLEM_MATCHERS[matcher];
    } else if (URL.canParse(matcher)) {
      try {
        nonValidatedMatcherConfig = await fetch(matcher).then((res) => res.json());
      } catch (_) {
        this.warning({ warningCollector, message: `Failed to load problem matcher config from the URL ${matcher}`, node: keyNode });
        return [];
      }
    } else {
      this.warning({ warningCollector, message: `Invalid problem matcher URL ${matcher}`, node: keyNode });
      return [];
    }
    if (!value_exports2.Check(TNonValidatedMatcherConfig, nonValidatedMatcherConfig)) {
      const errorMessage = formatTypeErrors(TNonValidatedMatcherConfig, nonValidatedMatcherConfig, "parsing problem matcher");
      this.warning({ warningCollector, message: errorMessage, node: keyNode });
      return [];
    }
    const validated = validateMatcherConfig(nonValidatedMatcherConfig);
    if (!validated.valid) {
      this.warning({
        warningCollector,
        message: [`Invalid problem matcher config:`, ...validated.errors.map((s) => s.message)].join("\n"),
        node: keyNode
      });
      return [];
    }
    return validated.value.problemMatcher;
  };
  parseProblemPath = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        path: this.parseString,
        format: (node2) => this.parseTypeBox(
          node2,
          Union([Literal("auto"), Literal("problem-json"), Literal("github-annotation-json"), Literal("github-annotations-action-json")])
        )
      },
      warningCollector
    );
    if (fields.path === void 0) {
      this.error([`A problem path must include a ${codeQuote("path")} key with the filename the problems are in`], node);
      fields.path = "";
    }
    return {
      path: fields.path,
      format: fields.format ?? "auto"
    };
  };
  parseOutputArtifacts = async (node, warningCollector) => {
    const seenKeys = /* @__PURE__ */ new Set();
    const parser = this.parseOutputArtifact(seenKeys);
    return await this.parseList(node, parser, warningCollector);
  };
  parseOutputFilesystem = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        filter: this.parseOutputFilesystemFilter
      },
      warningCollector
    );
    return {
      filter: fields.filter
    };
  };
  parseOutputFilesystemFilter = async (node, warningCollector) => {
    if (YAML.isSeq(node)) {
      return {
        workspace: await this.parseList(node, this.parseOutputFilesystemWorkspaceFilterEntry, warningCollector)
      };
    }
    const { fields } = await this.parseObject(
      node,
      {
        workspace: (node2, warningCollector2) => this.parseList(node2, this.parseOutputFilesystemWorkspaceFilterEntry, warningCollector2),
        system: (node2, warningCollector2) => this.parseList(node2, this.parseOutputFilesystemSystemFilterEntry, warningCollector2)
      },
      warningCollector
    );
    return {
      workspace: fields.workspace,
      system: fields.system
    };
  };
  parseOutputFilesystemWorkspaceFilterEntry = (node) => {
    const filterEntry = this.parseString(node);
    if (filterEntry.startsWith("/") || filterEntry.startsWith("!/")) {
      const filterEntryWithoutLeadingSlash = filterEntry.startsWith("/") ? filterEntry.slice(1) : filterEntry.slice(2);
      this.error(
        [
          "Filter entries for the workspace cannot start with `/`. All workspace filter entries are relative to the Mint workspace. Try `" + filterEntryWithoutLeadingSlash + "` instead."
        ],
        node
      );
    }
    return filterEntry;
  };
  parseOutputFilesystemSystemFilterEntry = (node) => {
    const filterEntry = this.parseString(node);
    const startsWithSlashOrAsterisk = /!?[/|*]/.test(filterEntry);
    if (!startsWithSlashOrAsterisk) {
      const filterEntryWithLeadingSlash = filterEntry.startsWith("!") ? "!/" + filterEntry.slice(1) : "/" + filterEntry;
      this.error(["Filter entries for the system must start with `/` or `*`. Try `" + filterEntryWithLeadingSlash + "` instead."], node);
    }
    return filterEntry;
  };
  parseOutputArtifact = (seenKeys) => async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        key: this.parseKey,
        path: this.parseStringTemplate
      },
      warningCollector
    );
    if (fields.key === void 0) {
      this.error([`An artifact must include a ${codeQuote("key")}`], node);
      fields.key = "";
    } else if (seenKeys.has(fields.key)) {
      const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "key"))[1];
      this.error([`The artifact ${codeQuote(fields.key)} is duplicate`], keyNode);
    }
    seenKeys.add(fields.key);
    if (fields.path === void 0) {
      this.error([`An artifact must include a ${codeQuote("path")}`], node);
      fields.path = "";
    }
    return { key: fields.key, path: fields.path };
  };
  parseEnv = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseEnvDescriptor, warningCollector);
  };
  parseEnvDescriptor = async (node, warningCollector, start) => {
    const errorMessage = `Expected a value for this environment variable, or an object with a ${codeQuote("value")} key and optional ${codeQuote(
      "cache-key"
    )} key, or an object with a ${codeQuote("cache-key")} key`;
    if (YAML.isScalar(node)) {
      return this.parseEnvValue(node, warningCollector, start);
    }
    if (YAML.isMap(node)) {
      return this.parseEnvObject(node, warningCollector, start);
    }
    this.error([errorMessage], node);
    return { value: void 0, cacheKey: "included" /* Included */ };
  };
  parseEnvValue = async (node) => {
    const value = await this.parseStringableTemplate(node);
    return { value, cacheKey: "included" /* Included */ };
  };
  parseEnvObject = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        value: this.parseStringableTemplate,
        cache: this.parseBoolean,
        "cache-key": (node2) => this.parseTypeBox(node2, this.TEnvCacheKey)
      },
      warningCollector
    );
    if (fields.cache !== void 0) {
      if (!this.warnedAboutUsingCacheInsteadOfCacheKey) {
        const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "cache"))[1];
        this.warning({
          warningCollector,
          message: `The ${codeQuote("cache")} property in ${codeQuote("env")} is deprecated.`,
          advice: `Use ${codeQuote("cache-key")} instead.`,
          docs: `See ${"https://www.rwx.com/docs/mint/environment-variables#affecting-the-cache-key" /* EnvironmentVariablesCacheKey */} to learn about configuring the cache key for environment variables`,
          node: keyNode
        });
      }
      if (fields["cache-key"] !== void 0) {
        const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "cache"))[1];
        this.error([`Cannot specify both ${codeQuote("cache")} and ${codeQuote("cache-key")}`], keyNode);
      }
      if (fields.value === void 0) {
        this.error([`An environment variable must have a ${codeQuote("value")}`], node);
      }
      const cacheKey2 = fields.cache ? "included" /* Included */ : "excluded" /* Excluded */;
      return { value: fields.value, cacheKey: cacheKey2 };
    }
    if (fields.value === void 0 && fields["cache-key"] === void 0) {
      this.error([`Must provide the property ${codeQuote("value")}, ${codeQuote("cache-key")}, or both.`], node);
    }
    fields["cache-key"] = fields["cache-key"] ?? "included";
    const cacheKey = this.mapEnvironmentVariableCacheKey(fields["cache-key"]);
    return { value: fields.value, cacheKey };
  };
  TEnvCacheKey = Type.Union([Type.Literal("included"), Type.Literal("excluded")]);
  mapEnvironmentVariableCacheKey(cacheKey) {
    switch (cacheKey) {
      case "included":
        return "included" /* Included */;
      case "excluded":
        return "excluded" /* Excluded */;
    }
  }
  parseEnvConfig = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        inherit: this.parseEnvInherit,
        merge: this.parseEnvMerge
      },
      warningCollector
    );
    return {
      inherit: fields.inherit,
      merge: fields.merge
    };
  };
  parseEnvInherit = async (node, warningCollector) => {
    if (YAML.isScalar(node) && node.value === "all-used-tasks") {
      return "all-used-tasks";
    } else if (YAML.isSeq(node)) {
      const tasks = await this.parseList(node, this.parseKey, warningCollector);
      return tasks;
    }
    this.error([`Expected the string ${codeQuote("all-used-tasks")} or a list of task keys to inherit from`], node);
    return [];
  };
  parseEnvMerge = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseEnvMergeStrategy, warningCollector);
  };
  parseEnvMergeStrategy = async (node, warningCollector) => {
    const { fields, keyNodes } = await this.parseObject(
      node,
      {
        strategy: (node2) => this.parseTypeBox(node2, Union([Literal("join"), Literal("override")])),
        by: this.parseString
      },
      warningCollector
    );
    const { strategy, by } = fields;
    if (strategy === void 0) {
      this.error([`An merge configuration must include a ${codeQuote("strategy")} key with value ${codeQuote("join")} or ${codeQuote("override")}`], node);
      return { strategy: "override" };
    }
    const keyNode = verifyExists(Object.entries(keyNodes).find((entry) => entry[0] === "strategy"))[1];
    switch (strategy) {
      case "join": {
        if (by === void 0) {
          this.error(
            [`The ${codeQuote("join")} strategy requires a ${codeQuote("by")} key with the string to join environment variable values by`],
            keyNode
          );
        }
        return { strategy, by: by ?? "" };
      }
      case "override": {
        if (by !== void 0) {
          this.error([`The ${codeQuote("override")} strategy cannot include any additional properties`], keyNode);
        }
        return { strategy };
      }
    }
  };
  parseTaskToolCache = (node) => {
    if (YAML.isScalar(node) && node.value === true) {
      return { type: "task-key" /* TaskKey */ };
    }
    if (YAML.isScalar(node) && typeof node.value === "string" && node.value) {
      return { type: "literal-string" /* LiteralString */, value: node.value };
    }
    this.error([`Expected ${codeQuote("true")} or a string tool cache identifier.`], node);
    return { type: "task-key" /* TaskKey */ };
  };
  parseParallel = async (node, warningCollector, start) => {
    if (YAML.isScalar(node)) {
      const parallelism = await this.parseParallelismTotal(node, warningCollector, start);
      return { key: null, tasksLimit: null, parallelism };
    }
    if (YAML.isMap(node)) {
      return this.parseParallelObject(node, warningCollector, start);
    }
    this.error(
      ["Expected a positive number, an expression, an object specifying the total, an object specifying the matrix, or an object specifying the values."],
      node
    );
    return { key: null, tasksLimit: null, parallelism: { type: "total" /* Total */, total: "1" } };
  };
  parseParallelismTotal = (node) => {
    let total;
    if (YAML.isScalar(node) && typeof node.value === "number") {
      const number = this.parseNumber(node, { minimum: 1 });
      total = String(number);
    } else if (node.toString().startsWith("${{")) {
      total = this.parseExactExpression(node);
    } else {
      this.error([`Expected a positive number or an expression`], node);
      total = "";
    }
    return { type: "total" /* Total */, total };
  };
  parseParallelObject = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        key: this.parseStringTemplate,
        "tasks-limit": this.parseParallelismTasksLimit,
        total: this.parseParallelismTotal,
        matrix: this.parseParallelismMatrix,
        values: this.parseParallelismValues
      },
      warningCollector
    );
    const parallelConfigurationsProvided = [];
    if (fields.total) {
      parallelConfigurationsProvided.push("total");
    }
    if (fields.matrix) {
      parallelConfigurationsProvided.push("matrix");
    }
    if (fields.values) {
      parallelConfigurationsProvided.push("values");
    }
    if (parallelConfigurationsProvided.length > 1) {
      const list = parallelConfigurationsProvided.map(codeQuote).join(", ");
      this.error([`The properties ${list} are mutually exclusive. Please provide only one.`], node);
    }
    let parallelism = fields.total ?? fields.matrix ?? fields.values;
    if (parallelism === void 0) {
      this.error([`One of the properties ${codeQuote("total")}, ${codeQuote("matrix")}, or ${codeQuote("values")} must be provided`], node);
      parallelism = { type: "total" /* Total */, total: "1" };
    }
    return {
      key: fields.key ?? null,
      tasksLimit: fields["tasks-limit"] ?? null,
      parallelism
    };
  };
  parseParallelismMatrix = async (node, warningCollector) => {
    const matrix = await this.parseGenericRecord(node, this.parseMatrixValue, warningCollector);
    return { type: "matrix" /* Matrix */, matrix };
  };
  parseMatrixValue = async (node, warningCollector) => {
    if (YAML.isScalar(node)) {
      return this.parseStringableTemplate(node);
    }
    if (YAML.isSeq(node)) {
      return this.parseList(node, this.parseStringableTemplate, warningCollector);
    }
    this.error([`Expected a template string, or a list of template strings`], node);
    return [];
  };
  parseParallelismValues = async (node, warningCollector) => {
    let values;
    if (node.toString().startsWith("${{")) {
      values = this.parseExactExpression(node);
    } else if (YAML.isSeq(node)) {
      values = await this.parseList(node, this.parseParallelismValueObject, warningCollector, { minimumItems: 1 });
      let expectedKeys;
      for (const value of values) {
        const currentKeys = new Set(Object.keys(value));
        if (expectedKeys === void 0) {
          expectedKeys = currentKeys;
        }
        if (!setEqual(expectedKeys, currentKeys)) {
          this.error([`All parallel values must have the same keys`], node);
          break;
        }
        if (currentKeys.size === 0) {
          this.error([`${codeQuote("values")} cannot include an empty object`], node);
          break;
        }
      }
    } else {
      this.error([`Expected an expression or a list of objects`], node);
      values = "";
    }
    return { type: "values" /* Values */, values };
  };
  parseParallelismTasksLimit = (node) => {
    return this.parseNumber(node, { minimum: 1, maximum: MAXIMUM_PARALLEL_TASKS_LIMIT });
  };
  parseParallelismValueObject = (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseStringableTemplate, warningCollector);
  };
  parseKey = (node) => {
    const TKeyDsl = Type.Union([Type.String({ pattern: KEY_PATTERN }), Type.Boolean()], {
      errorMessage: `A valid key must be a string matching the pattern ${KEY_PATTERN}`
    });
    return String(this.parseTypeBox(node, TKeyDsl));
  };
  parseInit = (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseStringableTemplate, warningCollector);
  };
  parseLeafSpecParameters = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseLeafSpecParameter, warningCollector);
  };
  parseLeafSpecParameter = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        description: this.parseString,
        required: this.parseBoolean,
        default: this.parseStringableNoExpression
      },
      warningCollector
    );
    if (fields.description === void 0) {
      this.error([`A description for this leaf is required`], node);
      fields.description = "";
    }
    return {
      description: fields.description,
      default: fields.default,
      required: fields.required
    };
  };
  parseLeafSpecOutputs = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        values: this.parseLeafSpecOutputValues,
        "values-from": (valuesFrom) => this.parseList(valuesFrom, this.parseString, warningCollector)
      },
      warningCollector
    );
    return {
      values: fields.values,
      valuesFrom: fields["values-from"]
    };
  };
  parseLeafSpecOutputValues = async (node, warningCollector) => {
    return this.parseGenericRecord(node, this.parseLeafSpecOutputValue, warningCollector);
  };
  parseLeafSpecOutputValue = async (node, warningCollector) => {
    const { fields } = await this.parseObject(
      node,
      {
        description: this.parseString,
        value: this.parseStringableTemplate
      },
      warningCollector
    );
    if (fields.value === void 0) {
      this.error([`A value for this leaf output is required`], node);
      fields.value = "";
    }
    return {
      description: fields.description,
      value: fields.value
    };
  };
  parseObject = async (map3, parsers, warningCollector, hiddenKeys) => {
    let parserKeys = Object.keys(parsers);
    if (hiddenKeys) {
      parserKeys = parserKeys.filter((key) => !hiddenKeys.has(key));
    }
    const expectedKeys = parserKeys.sort().map(codeQuote).join(", ");
    if (YAML.isScalar(map3) && map3.value === null) {
      return { fields: {}, keyNodes: {} };
    }
    if (!YAML.isMap(map3)) {
      this.error([`Expected an object with properties ${expectedKeys}`], map3);
      return { fields: {}, keyNodes: {} };
    }
    let fields = {};
    let keyNodes = {};
    for (const { key: maybeAliasedKey, value } of map3.items) {
      const [key] = this.synchronousDealias(maybeAliasedKey);
      if (value === null) {
        this.error([`Unexpected "null" value`], key);
        continue;
      } else {
        await this.dealias(value, async (value2) => {
          if (YAML.isScalar(key) && key.value === "<<") {
            if (YAML.isSeq(value2)) {
              for (const item of value2.items) {
                const anchorKeyResults = await this.dealias(item, (item2) => this.parseObject(item2, parsers, warningCollector));
                fields = { ...fields, ...anchorKeyResults.fields };
                keyNodes = { ...keyNodes, ...anchorKeyResults.keyNodes };
              }
            } else {
              const anchoredObjectResults = await this.parseObject(value2, parsers, warningCollector);
              fields = { ...fields, ...anchoredObjectResults.fields };
              keyNodes = { ...keyNodes, ...anchoredObjectResults.keyNodes };
            }
          } else {
            if (!YAML.isScalar(key) || typeof key.value !== "string") {
              this.error([`Unexpected property ${codeQuote(key.toString())}`, `Expected one of the following keys: ${expectedKeys}`], key);
              return void 0;
            }
            const keyName = key.value;
            const parser = parsers[keyName];
            if (parser === void 0) {
              const errorMessageLines = [`Unexpected property ${codeQuote(key.toString())}`, `Expected one of the following keys: ${expectedKeys}`];
              const bestMatch = didYouMean(key.toString(), parserKeys);
              if (bestMatch) {
                errorMessageLines.push(`Did you mean ${codeQuote(bestMatch)}?`);
              }
              (0, import_node_assert6.default)(isNonEmptyArray(errorMessageLines));
              this.error(errorMessageLines, key);
              return void 0;
            }
            const parsed = await parser(value2, warningCollector, key.range[1]);
            fields[keyName] = parsed;
            keyNodes[keyName] = key;
          }
        });
      }
    }
    return { fields, keyNodes };
  };
  parseGenericRecord = async (node, valueParser, warningCollector, { minimumKeys = 0, keyParser = this.parseString } = {}) => {
    if (!YAML.isMap(node)) {
      this.error([`Expected an object with string properties`], node);
      return {};
    }
    if (node.items.length < minimumKeys) {
      this.error([`Expected at least ${minimumKeys} ${minimumKeys === 1 ? "key" : "keys"}`], node);
    }
    let result = {};
    for (const { key: maybeAliasedKey, value } of node.items) {
      const [key] = this.synchronousDealias(maybeAliasedKey);
      const keyName = keyParser(key);
      if (value === null) {
        this.error([`Unexpected "null" value`], key);
        continue;
      }
      await this.dealias(value, async (value2) => {
        if (YAML.isScalar(key) && key.value === "<<") {
          if (YAML.isSeq(value2)) {
            for (const item of value2.items) {
              const anchorKeyValue = await this.dealias(item, (item2) => this.parseGenericRecord(item2, valueParser, warningCollector, { minimumKeys }));
              result = { ...result, ...anchorKeyValue };
            }
          } else {
            const anchorKeyValue = await this.parseGenericRecord(value2, valueParser, warningCollector, { minimumKeys });
            result = { ...result, ...anchorKeyValue };
          }
        } else {
          const keyValue = await valueParser(value2, warningCollector, key.range[1]);
          result[keyName] = keyValue;
        }
      });
    }
    return result;
  };
  parseListOrValue = (node, parser, warningCollector, start) => {
    if (YAML.isSeq(node)) {
      return this.parseList(node, parser, warningCollector);
    }
    return parser(node, warningCollector, start);
  };
  parseList = async (seq, parser, warningCollector, { listStart = seq.range[0], minimumItems = 0, seenSnippets } = {}) => {
    if (!YAML.isSeq(seq)) {
      this.error([`Expected a list`], seq);
      return [];
    }
    if (seq.items.length < minimumItems) {
      this.error([`Expected at least ${minimumItems} ${minimumItems === 1 ? "item" : "items"}`], seq);
      return [];
    }
    const result = [];
    let previousEnd = listStart;
    const previousFileName = this.currentFileName;
    for (let item of seq.items) {
      const itemEnd = item.range[1];
      const snippetsSeenInThisCycle = seenSnippets || /* @__PURE__ */ new Set();
      const { node, snippetFileName, success } = await this.dealias(item, (item2) => this.parseSnippetInclude(item2));
      if (!success) {
        continue;
      }
      if (snippetFileName) {
        if (snippetsSeenInThisCycle.has(snippetFileName)) {
          if (snippetFileName === this.currentFileName) {
            this.error(["A snippet cannot include itself"], item, snippetFileName);
          } else {
            this.error([`Snippet include cycle detected: ${snippetFileName} -> ${this.currentFileName} -> ${snippetFileName}`], item, snippetFileName);
          }
          continue;
        }
        snippetsSeenInThisCycle.add(snippetFileName);
        const { line, column } = this.locationOfIndex(item.range[0], previousFileName);
        this.stack.push({ fileName: previousFileName, line, column, name: "include" });
        item = node;
        this.currentFileName = snippetFileName;
        previousEnd = item.range[0];
      }
      await this.dealias(item, async (item2) => {
        if (YAML.isSeq(item2)) {
          const nestedResults = await this.parseList(item2, parser, warningCollector, { seenSnippets: snippetsSeenInThisCycle });
          result.push(...nestedResults);
        } else {
          result.push(await parser(item2, warningCollector, previousEnd));
        }
        previousEnd = itemEnd;
        if (snippetFileName) {
          this.currentFileName = previousFileName;
          this.stack.pop();
        }
      });
    }
    return result;
  };
  parseSnippetInclude = (node) => {
    if (!YAML.isMap(node)) {
      return { node, success: true };
    }
    const includePair = node.items.find((pair) => YAML.isScalar(pair.key) && pair.key.value === "include");
    if (!includePair) {
      return { node, success: true };
    }
    if (!YAML.isScalar(includePair.value) || typeof includePair.value.value !== "string") {
      this.error(["The value of `include` must be the filename of the snippet you want to include."], node);
      return { node, success: false };
    }
    const snippetName = includePair.value.value;
    if (!snippetName.startsWith("_")) {
      this.error(["The filename of a snippet must start with `_`"], node);
      return { node, success: false };
    }
    const snippet = this.snippets.get(snippetName);
    if (snippet) {
      return { node: snippet.yamlNode, snippetFileName: snippet.filePath, success: true };
    } else {
      const availableSnippets = [...this.snippets.keys()];
      const availableSnippetsText = availableSnippets.length > 0 ? `Available snippets: ${availableSnippets.join(", ")}` : "No snippets are available.";
      this.error([`Snippet file not found: ${snippetName}. ${availableSnippetsText}`], node);
      return { node, success: false };
    }
  };
  parseString = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "string") {
      this.error([`Expected a string`], node);
      return "";
    }
    return node.value;
  };
  parseBoolean = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "boolean") {
      this.error([`Expected a boolean`], node);
      return false;
    }
    return node.value;
  };
  parseNumber = (node, { minimum, maximum } = {}) => {
    if (!YAML.isScalar(node) || typeof node.value !== "number") {
      this.error([`Expected a number`], node);
      return -1;
    }
    const num = node.value;
    if (minimum !== void 0 && num < minimum) {
      this.error([`Expected a minimum of ${codeQuote(String(minimum))}`], node);
    }
    if (maximum !== void 0 && num > maximum) {
      this.error([`Expected a maximum of ${codeQuote(String(maximum))}`], node);
    }
    return num;
  };
  parseStringable = (node) => {
    if (!YAML.isScalar(node) || typeof node.value !== "boolean" && typeof node.value !== "string" && typeof node.value !== "number") {
      this.error([`Expected a string, number, or boolean read as a string.`], node);
      return "fake";
    }
    return String(node.value);
  };
  parseStringTemplate = async (node) => {
    const templateString = this.parseString(node);
    return Promise.resolve(this.checkTemplate(node, templateString));
  };
  parseStringableTemplate = async (node) => {
    const templateString = this.parseStringable(node);
    return Promise.resolve(this.checkTemplate(node, templateString));
  };
  parseStringableNoExpression = async (node) => {
    const templateString = this.parseStringable(node);
    return Promise.resolve(this.checkNoExpression(node, templateString));
  };
  parseExactExpression = (node) => {
    const TExactExpression = TBrandedString({
      pattern: "^\\$\\{\\{.*\\}\\}$",
      errorMessage: `Expected an expression like ${codeQuote("${{ run.id }}")}.`
    });
    const template = this.parseTypeBox(node, TExactExpression);
    return this.checkTemplate(node, template);
  };
  checkTemplate = (node, value) => {
    try {
      parseTemplate(value);
      return value;
    } catch (e) {
      if (e instanceof ParsingError) {
        this.error([e.messageWithAdvice], node);
        return "";
      }
      throw e;
    }
  };
  checkNoExpression = (node, value) => {
    let isTemplate;
    try {
      const { expressions } = parseTemplate(value);
      isTemplate = expressions.length > 0;
    } catch (_e) {
      isTemplate = false;
    }
    if (isTemplate) {
      this.error(["This value includes expressions, but expressions are not allowed in this context"], node);
    }
    return value;
  };
  parseTypeBox = (node, schema) => {
    const value = node.toJSON();
    if (!value_exports2.Check(schema, value)) {
      if (typeof schema.errorMessage === "string") {
        this.error([schema.errorMessage], node);
      } else {
        const errorMessage = formatTypeErrors(schema, value, "parsing value");
        this.error([errorMessage], node);
      }
    }
    return value;
  };
  locationOfIndex(index, fileName) {
    const location = verifyExists(this.linesMap[fileName]).locationForIndex(index);
    if (location === null)
      return { line: 0, column: 0 };
    const { line, column } = location;
    return { line: line + 1, column: column + 1 };
  }
  error(messageLines, node, fileName) {
    if (!fileName) {
      fileName = this.currentFileName;
    }
    const { line, column } = this.locationOfIndex(node.range[0], fileName);
    this.messages.push({ message: messageLines.join("\n"), severity: "error", stackTrace: [...this.stack, { fileName, line, column }] });
  }
  warning({
    warningCollector,
    message,
    node,
    advice,
    docs
  }) {
    const { line, column } = this.locationOfIndex(node.range[0], this.currentFileName);
    const stackEntry = { fileName: this.currentFileName, line, column };
    warningCollector.push(
      buildMessage({
        type: "warning" /* Warning */,
        message: [message],
        advice: advice ? [advice] : [],
        docs: docs ?? null,
        stackTrace: [...this.stack, stackEntry],
        frame: this.generateCodeFrame(stackEntry)
      })
    );
  }
  generateCodeFrame({ line, column, fileName }) {
    const frameLines = verifyExists(this.sourceMap[fileName]).split("\n");
    const lineNumbers = [line - 2, line - 1, line, line + 1, line + 2].filter((l) => !!frameLines[l - 1]);
    const maxLineNumberLength = Math.max(...lineNumbers.map((l) => l.toString().length));
    return lineNumbers.map((lineNumber) => {
      const lineString = `${lineNumber.toString().padStart(maxLineNumberLength, " ")} | ${frameLines[lineNumber - 1]}`;
      if (lineNumber === line) {
        return `> ${lineString}
  ${"".padStart(maxLineNumberLength, " ")} | ${"".padStart(column - 1, " ")}^`;
      } else {
        return `  ${lineString}`;
      }
    }).join("\n");
  }
  formatMessages() {
    const errors = [];
    for (const message of this.messages) {
      const formatted = this.formatMessage(message);
      switch (message.severity) {
        case "error": {
          errors.push(formatted);
          break;
        }
      }
    }
    return { errors };
  }
  formatMessage(parserMessage) {
    const lastStackEntry = verifyExists(parserMessage.stackTrace.findLast((e) => e));
    return {
      type: "parse-error" /* ParseError */,
      message: parserMessage.message,
      stackTrace: parserMessage.stackTrace,
      line: lastStackEntry.line,
      column: lastStackEntry.column,
      fileName: lastStackEntry.fileName,
      frame: this.generateCodeFrame(lastStackEntry)
    };
  }
};
function isYamlNull(node) {
  return YAML.isScalar(node) && node.value === null;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  YamlParser
});
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
